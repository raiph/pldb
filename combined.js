var autocompleteJs = [
  {
    "label": "05AB1E",
    "id": "05ab1e",
    "url": "/concepts/05ab1e.html"
  },
  {
    "label": "1.pak",
    "id": "1-pak",
    "url": "/concepts/1-pak.html"
  },
  {
    "label": "IBM 1620",
    "id": "1620sps",
    "url": "/concepts/1620sps.html"
  },
  {
    "label": "1C Enterprise Script",
    "id": "1c-enterprise",
    "url": "/concepts/1c-enterprise.html"
  },
  {
    "label": "2-pak",
    "id": "2-pak",
    "url": "/concepts/2-pak.html"
  },
  {
    "label": "20-GATE",
    "id": "20-gate",
    "url": "/concepts/20-gate.html"
  },
  {
    "label": "2lisp",
    "id": "2lisp",
    "url": "/concepts/2lisp.html"
  },
  {
    "label": "2OBJ",
    "id": "2obj",
    "url": "/concepts/2obj.html"
  },
  {
    "label": "3-LISP",
    "id": "3-lisp",
    "url": "/concepts/3-lisp.html"
  },
  {
    "label": "3APL",
    "id": "3apl",
    "url": "/concepts/3apl.html"
  },
  {
    "label": "3D Logo",
    "id": "3d-logo",
    "url": "/concepts/3d-logo.html"
  },
  {
    "label": "3DComposer",
    "id": "3dcomposer",
    "url": "/concepts/3dcomposer.html"
  },
  {
    "label": "3DS",
    "id": "3ds",
    "url": "/concepts/3ds.html"
  },
  {
    "label": "3D Manufacturing Format",
    "id": "3mf",
    "url": "/concepts/3mf.html"
  },
  {
    "label": "3RIP",
    "id": "3rip",
    "url": "/concepts/3rip.html"
  },
  {
    "label": "4G",
    "id": "4g-standard",
    "url": "/concepts/4g-standard.html"
  },
  {
    "label": "4th Dimension",
    "id": "4th-dimension",
    "url": "/concepts/4th-dimension.html"
  },
  {
    "label": "51forth",
    "id": "51forth",
    "url": "/concepts/51forth.html"
  },
  {
    "label": "6gunz",
    "id": "6gunz",
    "url": "/concepts/6gunz.html"
  },
  {
    "label": "8th",
    "id": "8th",
    "url": "/concepts/8th.html"
  },
  {
    "label": "A-0 system",
    "id": "a-0-system",
    "url": "/concepts/a-0-system.html"
  },
  {
    "label": "A#",
    "id": "a-sharp",
    "url": "/concepts/a-sharp.html"
  },
  {
    "label": "A51 Assembly",
    "id": "a51",
    "url": "/concepts/a51.html"
  },
  {
    "label": "Avionics Architecture Design Language",
    "id": "aadl",
    "url": "/concepts/aadl.html"
  },
  {
    "label": "Advanced Authoring Format",
    "id": "aaf",
    "url": "/concepts/aaf.html"
  },
  {
    "label": "AArch64",
    "id": "aarch64",
    "url": "/concepts/aarch64.html"
  },
  {
    "label": "Aardappel",
    "id": "aardappel",
    "url": "/concepts/aardappel.html"
  },
  {
    "label": "Aardvark",
    "id": "aardvark",
    "url": "/concepts/aardvark.html"
  },
  {
    "label": "Abacus",
    "id": "abacus-machine",
    "url": "/concepts/abacus-machine.html"
  },
  {
    "label": "ABAL",
    "id": "abal",
    "url": "/concepts/abal.html"
  },
  {
    "label": "ABAP",
    "id": "abap",
    "url": "/concepts/abap.html"
  },
  {
    "label": "Abbreviated Test Language for All Systems",
    "id": "abbreviated-test-language-for-all-systems",
    "url": "/concepts/abbreviated-test-language-for-all-systems.html"
  },
  {
    "label": "ABC 80",
    "id": "abc-80",
    "url": "/concepts/abc-80.html"
  },
  {
    "label": "ABC ALGOL",
    "id": "abc-algol",
    "url": "/concepts/abc-algol.html"
  },
  {
    "label": "ABC",
    "id": "abc",
    "url": "/concepts/abc.html"
  },
  {
    "label": "ABCL/c+",
    "id": "abcl-cp",
    "url": "/concepts/abcl-cp.html"
  },
  {
    "label": "ABCL/f",
    "id": "abcl-f",
    "url": "/concepts/abcl-f.html"
  },
  {
    "label": "Armed Bear Common Lisp",
    "id": "abcl-lang",
    "url": "/concepts/abcl-lang.html"
  },
  {
    "label": "Actor-Based Concurrent Language",
    "id": "abcl",
    "url": "/concepts/abcl.html"
  },
  {
    "label": "ABC++",
    "id": "abcpp",
    "url": "/concepts/abcpp.html"
  },
  {
    "label": "ABEL",
    "id": "abel",
    "url": "/concepts/abel.html"
  },
  {
    "label": "ABLE",
    "id": "able",
    "url": "/concepts/able.html"
  },
  {
    "label": "Augmented Backus-Naur Form",
    "id": "abnf",
    "url": "/concepts/abnf.html"
  },
  {
    "label": "abs",
    "id": "abs",
    "url": "/concepts/abs.html"
  },
  {
    "label": "ABSET",
    "id": "abset",
    "url": "/concepts/abset.html"
  },
  {
    "label": "Abstract State Machine Language",
    "id": "abstract-state-machine-language",
    "url": "/concepts/abstract-state-machine-language.html"
  },
  {
    "label": "Abstracto",
    "id": "abstracto",
    "url": "/concepts/abstracto.html"
  },
  {
    "label": "ABSYS",
    "id": "absys",
    "url": "/concepts/absys.html"
  },
  {
    "label": "AC Toolbox",
    "id": "ac-toolbox",
    "url": "/concepts/ac-toolbox.html"
  },
  {
    "label": "ACCENT",
    "id": "accent",
    "url": "/concepts/accent.html"
  },
  {
    "label": "Ace Editor",
    "id": "ace",
    "url": "/concepts/ace.html"
  },
  {
    "label": "ACL",
    "id": "acl",
    "url": "/concepts/acl.html"
  },
  {
    "label": "ACL2",
    "id": "acl2",
    "url": "/concepts/acl2.html"
  },
  {
    "label": "Acme",
    "id": "acme",
    "url": "/concepts/acme.html"
  },
  {
    "label": "Acore",
    "id": "acore",
    "url": "/concepts/acore.html"
  },
  {
    "label": "Acorn Atom",
    "id": "acorn-atom",
    "url": "/concepts/acorn-atom.html"
  },
  {
    "label": "acorn-lang",
    "id": "acorn-lang",
    "url": "/concepts/acorn-lang.html"
  },
  {
    "label": "ACORN",
    "id": "acorn",
    "url": "/concepts/acorn.html"
  },
  {
    "label": "Acornsoft Logo",
    "id": "acornsoft-logo",
    "url": "/concepts/acornsoft-logo.html"
  },
  {
    "label": "ACOS",
    "id": "acos",
    "url": "/concepts/acos.html"
  },
  {
    "label": "ACSI-Matic",
    "id": "acsi-matic",
    "url": "/concepts/acsi-matic.html"
  },
  {
    "label": "ACSL",
    "id": "acsl",
    "url": "/concepts/acsl.html"
  },
  {
    "label": "ACT-III",
    "id": "act-iii",
    "url": "/concepts/act-iii.html"
  },
  {
    "label": "ACT ONE",
    "id": "act-one",
    "url": "/concepts/act-one.html"
  },
  {
    "label": "Actalk",
    "id": "actalk",
    "url": "/concepts/actalk.html"
  },
  {
    "label": "Action Code Script",
    "id": "action-code-script",
    "url": "/concepts/action-code-script.html"
  },
  {
    "label": "Action!",
    "id": "action",
    "url": "/concepts/action.html"
  },
  {
    "label": "ActionScript",
    "id": "actionscript",
    "url": "/concepts/actionscript.html"
  },
  {
    "label": "Active Language I",
    "id": "active-language-i",
    "url": "/concepts/active-language-i.html"
  },
  {
    "label": "Active-U-Datalog",
    "id": "active-u-datalog",
    "url": "/concepts/active-u-datalog.html"
  },
  {
    "label": "ActiveVFP",
    "id": "activevfp",
    "url": "/concepts/activevfp.html"
  },
  {
    "label": "ActivityPub",
    "id": "activity-pub",
    "url": "/concepts/activity-pub.html"
  },
  {
    "label": "Actor",
    "id": "actor",
    "url": "/concepts/actor.html"
  },
  {
    "label": "Actors",
    "id": "actors",
    "url": "/concepts/actors.html"
  },
  {
    "label": "Actus",
    "id": "actus",
    "url": "/concepts/actus.html"
  },
  {
    "label": "Ad-hoc",
    "id": "ad-hoc",
    "url": "/concepts/ad-hoc.html"
  },
  {
    "label": "Ada 95",
    "id": "ada-95",
    "url": "/concepts/ada-95.html"
  },
  {
    "label": "Ada 9X",
    "id": "ada-9x",
    "url": "/concepts/ada-9x.html"
  },
  {
    "label": "Ada/TL",
    "id": "ada-tl",
    "url": "/concepts/ada-tl.html"
  },
  {
    "label": "Ada",
    "id": "ada",
    "url": "/concepts/ada.html"
  },
  {
    "label": "ADABTPL",
    "id": "adabtpl",
    "url": "/concepts/adabtpl.html"
  },
  {
    "label": "Adagio",
    "id": "adagio",
    "url": "/concepts/adagio.html"
  },
  {
    "label": "adam-standard",
    "id": "adam-standard",
    "url": "/concepts/adam-standard.html"
  },
  {
    "label": "ADAM",
    "id": "adam",
    "url": "/concepts/adam.html"
  },
  {
    "label": "adamant",
    "id": "adamant",
    "url": "/concepts/adamant.html"
  },
  {
    "label": "Adaplex",
    "id": "adaplex",
    "url": "/concepts/adaplex.html"
  },
  {
    "label": "Address",
    "id": "address",
    "url": "/concepts/address.html"
  },
  {
    "label": "Adenine",
    "id": "adenine-programming-language",
    "url": "/concepts/adenine-programming-language.html"
  },
  {
    "label": "Adept",
    "id": "adept",
    "url": "/concepts/adept.html"
  },
  {
    "label": "ADES II",
    "id": "ades-ii",
    "url": "/concepts/ades-ii.html"
  },
  {
    "label": "ADES",
    "id": "ades",
    "url": "/concepts/ades.html"
  },
  {
    "label": "Aditi",
    "id": "aditi",
    "url": "/concepts/aditi.html"
  },
  {
    "label": "ADLIB",
    "id": "adlib",
    "url": "/concepts/adlib.html"
  },
  {
    "label": "Adobe Font Metrics",
    "id": "adobe-font-metrics",
    "url": "/concepts/adobe-font-metrics.html"
  },
  {
    "label": "ADS-B",
    "id": "ads-b-standard",
    "url": "/concepts/ads-b-standard.html"
  },
  {
    "label": "Advanced Continuous Simulation Language",
    "id": "advanced-continuous-simulation-language",
    "url": "/concepts/advanced-continuous-simulation-language.html"
  },
  {
    "label": "Advice Taker",
    "id": "advice-taker",
    "url": "/concepts/advice-taker.html"
  },
  {
    "label": "AED",
    "id": "aed",
    "url": "/concepts/aed.html"
  },
  {
    "label": "AEPL",
    "id": "aepl",
    "url": "/concepts/aepl.html"
  },
  {
    "label": "AESOP",
    "id": "aesop",
    "url": "/concepts/aesop.html"
  },
  {
    "label": "Afnix",
    "id": "afnix",
    "url": "/concepts/afnix.html"
  },
  {
    "label": "AFS",
    "id": "afs",
    "url": "/concepts/afs.html"
  },
  {
    "label": "Agda",
    "id": "agda",
    "url": "/concepts/agda.html"
  },
  {
    "label": "Agent-K",
    "id": "agent-k",
    "url": "/concepts/agent-k.html"
  },
  {
    "label": "AgentSpeak",
    "id": "agentspeak",
    "url": "/concepts/agentspeak.html"
  },
  {
    "label": "AGL",
    "id": "agl",
    "url": "/concepts/agl.html"
  },
  {
    "label": "Agora",
    "id": "agora",
    "url": "/concepts/agora.html"
  },
  {
    "label": "Adventure Game Studio Script",
    "id": "ags-script",
    "url": "/concepts/ags-script.html"
  },
  {
    "label": "Aheui",
    "id": "aheui",
    "url": "/concepts/aheui.html"
  },
  {
    "label": "AIDA",
    "id": "aida",
    "url": "/concepts/aida.html"
  },
  {
    "label": "AIDS",
    "id": "aids",
    "url": "/concepts/aids.html"
  },
  {
    "label": "AIL",
    "id": "ail",
    "url": "/concepts/ail.html"
  },
  {
    "label": "Aime",
    "id": "aime",
    "url": "/concepts/aime.html"
  },
  {
    "label": "AIML",
    "id": "aiml",
    "url": "/concepts/aiml.html"
  },
  {
    "label": "AIMMS",
    "id": "aimms",
    "url": "/concepts/aimms.html"
  },
  {
    "label": "AIR",
    "id": "air",
    "url": "/concepts/air.html"
  },
  {
    "label": "Airtable",
    "id": "airtable-app",
    "url": "/concepts/airtable-app.html"
  },
  {
    "label": "Alternate Instruction Set",
    "id": "ais",
    "url": "/concepts/ais.html"
  },
  {
    "label": "Aith",
    "id": "aith",
    "url": "/concepts/aith.html"
  },
  {
    "label": "AKL",
    "id": "akl",
    "url": "/concepts/akl.html"
  },
  {
    "label": "AL",
    "id": "al",
    "url": "/concepts/al.html"
  },
  {
    "label": "ALADIN",
    "id": "aladin",
    "url": "/concepts/aladin.html"
  },
  {
    "label": "Alambik",
    "id": "alambik",
    "url": "/concepts/alambik.html"
  },
  {
    "label": "alan",
    "id": "alan",
    "url": "/concepts/alan.html"
  },
  {
    "label": "ALBA",
    "id": "alba",
    "url": "/concepts/alba.html"
  },
  {
    "label": "albatross",
    "id": "albatross",
    "url": "/concepts/albatross.html"
  },
  {
    "label": "ALCOR",
    "id": "alcor",
    "url": "/concepts/alcor.html"
  },
  {
    "label": "Aldat",
    "id": "aldat",
    "url": "/concepts/aldat.html"
  },
  {
    "label": "ALDES",
    "id": "aldes",
    "url": "/concepts/aldes.html"
  },
  {
    "label": "Aldor",
    "id": "aldor",
    "url": "/concepts/aldor.html"
  },
  {
    "label": "Aldwych",
    "id": "aldwych",
    "url": "/concepts/aldwych.html"
  },
  {
    "label": "a Lisp Environment",
    "id": "ale",
    "url": "/concepts/ale.html"
  },
  {
    "label": "ALEC",
    "id": "alec",
    "url": "/concepts/alec.html"
  },
  {
    "label": "ALEF",
    "id": "alef",
    "url": "/concepts/alef.html"
  },
  {
    "label": "ALEPH",
    "id": "aleph",
    "url": "/concepts/aleph.html"
  },
  {
    "label": "Algebraic Logic Functional",
    "id": "alf",
    "url": "/concepts/alf.html"
  },
  {
    "label": "alfred",
    "id": "alfred",
    "url": "/concepts/alfred.html"
  },
  {
    "label": "Algae",
    "id": "algae",
    "url": "/concepts/algae.html"
  },
  {
    "label": "Algebraic Compiler",
    "id": "algebraic-compiler",
    "url": "/concepts/algebraic-compiler.html"
  },
  {
    "label": "Algebraic modeling language",
    "id": "algebraic-modeling-language",
    "url": "/concepts/algebraic-modeling-language.html"
  },
  {
    "label": "ALGEM",
    "id": "algem",
    "url": "/concepts/algem.html"
  },
  {
    "label": "ALGERNON",
    "id": "algernon",
    "url": "/concepts/algernon.html"
  },
  {
    "label": "ALGO",
    "id": "algo",
    "url": "/concepts/algo.html"
  },
  {
    "label": "algobox",
    "id": "algobox",
    "url": "/concepts/algobox.html"
  },
  {
    "label": "ALGOL 58",
    "id": "algol-58",
    "url": "/concepts/algol-58.html"
  },
  {
    "label": "ALGOL 60",
    "id": "algol-60",
    "url": "/concepts/algol-60.html"
  },
  {
    "label": "ALGOL 68-R",
    "id": "algol-68-r",
    "url": "/concepts/algol-68-r.html"
  },
  {
    "label": "ALGOL 68-RT",
    "id": "algol-68-rt",
    "url": "/concepts/algol-68-rt.html"
  },
  {
    "label": "ALGOL 68",
    "id": "algol-68",
    "url": "/concepts/algol-68.html"
  },
  {
    "label": "ALGOL-E",
    "id": "algol-e",
    "url": "/concepts/algol-e.html"
  },
  {
    "label": "ALGOL N",
    "id": "algol-n",
    "url": "/concepts/algol-n.html"
  },
  {
    "label": "ALGOL W",
    "id": "algol-w",
    "url": "/concepts/algol-w.html"
  },
  {
    "label": "ALGOL X",
    "id": "algol-x",
    "url": "/concepts/algol-x.html"
  },
  {
    "label": "Algol",
    "id": "algol",
    "url": "/concepts/algol.html"
  },
  {
    "label": "ALGY",
    "id": "algy",
    "url": "/concepts/algy.html"
  },
  {
    "label": "Alice",
    "id": "alice",
    "url": "/concepts/alice.html"
  },
  {
    "label": "ALJABR",
    "id": "aljabr",
    "url": "/concepts/aljabr.html"
  },
  {
    "label": "Allegro Common Lisp",
    "id": "allegro-common-lisp",
    "url": "/concepts/allegro-common-lisp.html"
  },
  {
    "label": "ALLO",
    "id": "allo",
    "url": "/concepts/allo.html"
  },
  {
    "label": "Alloy",
    "id": "alloy",
    "url": "/concepts/alloy.html"
  },
  {
    "label": "Alma-0",
    "id": "alma-0",
    "url": "/concepts/alma-0.html"
  },
  {
    "label": "Alma",
    "id": "alma-007",
    "url": "/concepts/alma-007.html"
  },
  {
    "label": "Alma-O",
    "id": "alma-o",
    "url": "/concepts/alma-o.html"
  },
  {
    "label": "Alma",
    "id": "alma",
    "url": "/concepts/alma.html"
  },
  {
    "label": "ALMIR",
    "id": "almir",
    "url": "/concepts/almir.html"
  },
  {
    "label": "Almquist shell",
    "id": "almquist-shell",
    "url": "/concepts/almquist-shell.html"
  },
  {
    "label": "ALOHAnet",
    "id": "alohanet",
    "url": "/concepts/alohanet.html"
  },
  {
    "label": "Alonzo",
    "id": "alonzo",
    "url": "/concepts/alonzo.html"
  },
  {
    "label": "Alpaca",
    "id": "alpaca",
    "url": "/concepts/alpaca.html"
  },
  {
    "label": "ALPAK",
    "id": "alpak",
    "url": "/concepts/alpak.html"
  },
  {
    "label": "Alpha",
    "id": "alpha-programming-language",
    "url": "/concepts/alpha-programming-language.html"
  },
  {
    "label": "AlphaBasic",
    "id": "alphabasic",
    "url": "/concepts/alphabasic.html"
  },
  {
    "label": "AlphaPop",
    "id": "alphapop",
    "url": "/concepts/alphapop.html"
  },
  {
    "label": "Alphard",
    "id": "alphard-programming-language",
    "url": "/concepts/alphard-programming-language.html"
  },
  {
    "label": "AlpHard",
    "id": "alphard",
    "url": "/concepts/alphard.html"
  },
  {
    "label": "Alpine Abuild",
    "id": "alpine-abuild",
    "url": "/concepts/alpine-abuild.html"
  },
  {
    "label": "ALPS",
    "id": "alps",
    "url": "/concepts/alps.html"
  },
  {
    "label": "ALTAC",
    "id": "altac",
    "url": "/concepts/altac.html"
  },
  {
    "label": "Altair BASIC",
    "id": "altair-basic",
    "url": "/concepts/altair-basic.html"
  },
  {
    "label": "Altibase",
    "id": "altibase",
    "url": "/concepts/altibase.html"
  },
  {
    "label": "ALTRAN",
    "id": "altran",
    "url": "/concepts/altran.html"
  },
  {
    "label": "Alumina",
    "id": "alumina",
    "url": "/concepts/alumina.html"
  },
  {
    "label": "amalthea",
    "id": "amalthea",
    "url": "/concepts/amalthea.html"
  },
  {
    "label": "Amanda",
    "id": "amanda",
    "url": "/concepts/amanda.html"
  },
  {
    "label": "Amazon DynamoDB",
    "id": "amazon-dynamodb",
    "url": "/concepts/amazon-dynamodb.html"
  },
  {
    "label": "Amazon RDS",
    "id": "amazon-rds",
    "url": "/concepts/amazon-rds.html"
  },
  {
    "label": "Amber",
    "id": "amber",
    "url": "/concepts/amber.html"
  },
  {
    "label": "AmbientTalk",
    "id": "ambienttalk",
    "url": "/concepts/ambienttalk.html"
  },
  {
    "label": "AMBIT/G",
    "id": "ambit-g",
    "url": "/concepts/ambit-g.html"
  },
  {
    "label": "AMBIT/L",
    "id": "ambit-l",
    "url": "/concepts/ambit-l.html"
  },
  {
    "label": "AMBIT",
    "id": "ambit",
    "url": "/concepts/ambit.html"
  },
  {
    "label": "AMBUSH",
    "id": "ambush",
    "url": "/concepts/ambush.html"
  },
  {
    "label": "Amiga E",
    "id": "amiga-e",
    "url": "/concepts/amiga-e.html"
  },
  {
    "label": "Amigas",
    "id": "amiga-programming-languages",
    "url": "/concepts/amiga-programming-languages.html"
  },
  {
    "label": "AmigaBASIC",
    "id": "amigabasic",
    "url": "/concepts/amigabasic.html"
  },
  {
    "label": "AMOS",
    "id": "amos",
    "url": "/concepts/amos.html"
  },
  {
    "label": "Ampère's Circuital Equation",
    "id": "amperes-circuital-equation",
    "url": "/concepts/amperes-circuital-equation.html"
  },
  {
    "label": "AMPL",
    "id": "ampl",
    "url": "/concepts/ampl.html"
  },
  {
    "label": "AMPPL-I",
    "id": "amppl-i",
    "url": "/concepts/amppl-i.html"
  },
  {
    "label": "AMPPL-II",
    "id": "amppl-ii",
    "url": "/concepts/amppl-ii.html"
  },
  {
    "label": "Advanced Message Queuing Protocol",
    "id": "amqp",
    "url": "/concepts/amqp.html"
  },
  {
    "label": "AMTRAN 70",
    "id": "amtran-70",
    "url": "/concepts/amtran-70.html"
  },
  {
    "label": "AMTRAN",
    "id": "amtran",
    "url": "/concepts/amtran.html"
  },
  {
    "label": "Amulet",
    "id": "amulet",
    "url": "/concepts/amulet.html"
  },
  {
    "label": "ana",
    "id": "ana",
    "url": "/concepts/ana.html"
  },
  {
    "label": "Analytical engine",
    "id": "analytical-engine-machine",
    "url": "/concepts/analytical-engine-machine.html"
  },
  {
    "label": "And/Or",
    "id": "and-or",
    "url": "/concepts/and-or.html"
  },
  {
    "label": "Andante",
    "id": "andante",
    "url": "/concepts/andante.html"
  },
  {
    "label": "Andorra-I",
    "id": "andorra-i",
    "url": "/concepts/andorra-i.html"
  },
  {
    "label": "Andorra",
    "id": "andorra",
    "url": "/concepts/andorra.html"
  },
  {
    "label": "Android",
    "id": "android",
    "url": "/concepts/android.html"
  },
  {
    "label": "Angelscript",
    "id": "angelscript",
    "url": "/concepts/angelscript.html"
  },
  {
    "label": "angr",
    "id": "angr",
    "url": "/concepts/angr.html"
  },
  {
    "label": "ANNA",
    "id": "anna",
    "url": "/concepts/anna.html"
  },
  {
    "label": "ANS MUMPS",
    "id": "ans-mumps",
    "url": "/concepts/ans-mumps.html"
  },
  {
    "label": "ANSI BASIC",
    "id": "ansi-basic",
    "url": "/concepts/ansi-basic.html"
  },
  {
    "label": "Ant Build System",
    "id": "ant-build-system",
    "url": "/concepts/ant-build-system.html"
  },
  {
    "label": "Ante",
    "id": "ante-esolang",
    "url": "/concepts/ante-esolang.html"
  },
  {
    "label": "Ante",
    "id": "ante",
    "url": "/concepts/ante.html"
  },
  {
    "label": "antha",
    "id": "antha",
    "url": "/concepts/antha.html"
  },
  {
    "label": "ANTLR",
    "id": "antlr",
    "url": "/concepts/antlr.html"
  },
  {
    "label": "Apache Cassandra",
    "id": "apache-cassandra",
    "url": "/concepts/apache-cassandra.html"
  },
  {
    "label": "Apache Derby",
    "id": "apache-derby",
    "url": "/concepts/apache-derby.html"
  },
  {
    "label": "Apache Hbase",
    "id": "apache-hbase",
    "url": "/concepts/apache-hbase.html"
  },
  {
    "label": "Apache Phoenix",
    "id": "apache-phoenix",
    "url": "/concepts/apache-phoenix.html"
  },
  {
    "label": "Velocity",
    "id": "apache-velocity",
    "url": "/concepts/apache-velocity.html"
  },
  {
    "label": "APACHE",
    "id": "apache",
    "url": "/concepts/apache.html"
  },
  {
    "label": "ApacheConf",
    "id": "apacheconf",
    "url": "/concepts/apacheconf.html"
  },
  {
    "label": "APAR",
    "id": "apar",
    "url": "/concepts/apar.html"
  },
  {
    "label": "APAREL",
    "id": "aparel",
    "url": "/concepts/aparel.html"
  },
  {
    "label": "APE100",
    "id": "ape100",
    "url": "/concepts/ape100.html"
  },
  {
    "label": "ApeScript",
    "id": "apescript",
    "url": "/concepts/apescript.html"
  },
  {
    "label": "Apex",
    "id": "apex",
    "url": "/concepts/apex.html"
  },
  {
    "label": "API Blueprint",
    "id": "api-blueprint",
    "url": "/concepts/api-blueprint.html"
  },
  {
    "label": "APL-GPSS",
    "id": "apl-gpss",
    "url": "/concepts/apl-gpss.html"
  },
  {
    "label": "APL/HP",
    "id": "apl-hp",
    "url": "/concepts/apl-hp.html"
  },
  {
    "label": "APL/Z80",
    "id": "apl-z80",
    "url": "/concepts/apl-z80.html"
  },
  {
    "label": "APL",
    "id": "apl",
    "url": "/concepts/apl.html"
  },
  {
    "label": "APL2",
    "id": "apl2",
    "url": "/concepts/apl2.html"
  },
  {
    "label": "aplette",
    "id": "aplette",
    "url": "/concepts/aplette.html"
  },
  {
    "label": "APLGOL-2",
    "id": "aplgol-2",
    "url": "/concepts/aplgol-2.html"
  },
  {
    "label": "APLGOL",
    "id": "aplgol",
    "url": "/concepts/aplgol.html"
  },
  {
    "label": "APLO",
    "id": "aplo",
    "url": "/concepts/aplo.html"
  },
  {
    "label": "A+",
    "id": "aplus",
    "url": "/concepts/aplus.html"
  },
  {
    "label": "A++",
    "id": "aplusplus",
    "url": "/concepts/aplusplus.html"
  },
  {
    "label": "APLX",
    "id": "aplx",
    "url": "/concepts/aplx.html"
  },
  {
    "label": "AGC",
    "id": "apollo-guidance-computer",
    "url": "/concepts/apollo-guidance-computer.html"
  },
  {
    "label": "APOSTLE",
    "id": "apostle",
    "url": "/concepts/apostle.html"
  },
  {
    "label": "appcode-editor",
    "id": "appcode-editor",
    "url": "/concepts/appcode-editor.html"
  },
  {
    "label": "APPL/A",
    "id": "appl-a",
    "url": "/concepts/appl-a.html"
  },
  {
    "label": "Apple I",
    "id": "apple-1-machine",
    "url": "/concepts/apple-1-machine.html"
  },
  {
    "label": "Apple BASIC",
    "id": "apple-basic",
    "url": "/concepts/apple-basic.html"
  },
  {
    "label": "Apple ProDOS",
    "id": "apple-prodos",
    "url": "/concepts/apple-prodos.html"
  },
  {
    "label": "Applescript",
    "id": "applescript",
    "url": "/concepts/applescript.html"
  },
  {
    "label": "Applesoft BASIC",
    "id": "applesoft-basic",
    "url": "/concepts/applesoft-basic.html"
  },
  {
    "label": "APPLOG",
    "id": "applog",
    "url": "/concepts/applog.html"
  },
  {
    "label": "april",
    "id": "april",
    "url": "/concepts/april.html"
  },
  {
    "label": "APROL",
    "id": "aprol",
    "url": "/concepts/aprol.html"
  },
  {
    "label": "APSE",
    "id": "apse",
    "url": "/concepts/apse.html"
  },
  {
    "label": "APT Debian",
    "id": "apt-pm",
    "url": "/concepts/apt-pm.html"
  },
  {
    "label": "Automatically Programmed Tool",
    "id": "apt",
    "url": "/concepts/apt.html"
  },
  {
    "label": "aQasm",
    "id": "aqasm",
    "url": "/concepts/aqasm.html"
  },
  {
    "label": "AQL",
    "id": "aql",
    "url": "/concepts/aql.html"
  },
  {
    "label": "Aquarius Prolog",
    "id": "aquarius-prolog",
    "url": "/concepts/aquarius-prolog.html"
  },
  {
    "label": "Hindu-Arabic numeral system",
    "id": "arabic-numerals",
    "url": "/concepts/arabic-numerals.html"
  },
  {
    "label": "ARABLAN",
    "id": "arablan",
    "url": "/concepts/arablan.html"
  },
  {
    "label": "ArangoDB",
    "id": "arango-db",
    "url": "/concepts/arango-db.html"
  },
  {
    "label": "arbortext-command-language",
    "id": "arbortext-command-language",
    "url": "/concepts/arbortext-command-language.html"
  },
  {
    "label": "Arc Assembly",
    "id": "arc-assembly",
    "url": "/concepts/arc-assembly.html"
  },
  {
    "label": "ARC processor",
    "id": "arc-isa",
    "url": "/concepts/arc-isa.html"
  },
  {
    "label": "Arc",
    "id": "arc",
    "url": "/concepts/arc.html"
  },
  {
    "label": "ARCHI",
    "id": "archi",
    "url": "/concepts/archi.html"
  },
  {
    "label": "ArchieML",
    "id": "archieml",
    "url": "/concepts/archieml.html"
  },
  {
    "label": "Arctic",
    "id": "arctic",
    "url": "/concepts/arctic.html"
  },
  {
    "label": "Arden syntax",
    "id": "arden-syntax",
    "url": "/concepts/arden-syntax.html"
  },
  {
    "label": "Arduino Programming Language",
    "id": "arduino",
    "url": "/concepts/arduino.html"
  },
  {
    "label": "arend",
    "id": "arend",
    "url": "/concepts/arend.html"
  },
  {
    "label": "aretext",
    "id": "aretext",
    "url": "/concepts/aretext.html"
  },
  {
    "label": "ARexx",
    "id": "arexx",
    "url": "/concepts/arexx.html"
  },
  {
    "label": "arezzo-notation",
    "id": "arezzo-notation",
    "url": "/concepts/arezzo-notation.html"
  },
  {
    "label": "Argdown",
    "id": "argdown",
    "url": "/concepts/argdown.html"
  },
  {
    "label": "Argon",
    "id": "argon",
    "url": "/concepts/argon.html"
  },
  {
    "label": "Argos",
    "id": "argos",
    "url": "/concepts/argos.html"
  },
  {
    "label": "Argus",
    "id": "argus",
    "url": "/concepts/argus.html"
  },
  {
    "label": "ARITH-MATIC",
    "id": "arith-matic",
    "url": "/concepts/arith-matic.html"
  },
  {
    "label": "Arjuna",
    "id": "arjuna",
    "url": "/concepts/arjuna.html"
  },
  {
    "label": "Ark",
    "id": "ark-lang",
    "url": "/concepts/ark-lang.html"
  },
  {
    "label": "ARK",
    "id": "ark",
    "url": "/concepts/ark.html"
  },
  {
    "label": "ArkScript",
    "id": "arkscript",
    "url": "/concepts/arkscript.html"
  },
  {
    "label": "ARM Templates",
    "id": "arm-templates",
    "url": "/concepts/arm-templates.html"
  },
  {
    "label": "ARM",
    "id": "arm",
    "url": "/concepts/arm.html"
  },
  {
    "label": "Armani",
    "id": "armani",
    "url": "/concepts/armani.html"
  },
  {
    "label": "arret",
    "id": "arret",
    "url": "/concepts/arret.html"
  },
  {
    "label": "Apache Arrow",
    "id": "arrow-format",
    "url": "/concepts/arrow-format.html"
  },
  {
    "label": "arrow",
    "id": "arrow",
    "url": "/concepts/arrow.html"
  },
  {
    "label": "ARTA",
    "id": "arta",
    "url": "/concepts/arta.html"
  },
  {
    "label": "ARTSPEAK",
    "id": "artspeak",
    "url": "/concepts/artspeak.html"
  },
  {
    "label": "Arturo",
    "id": "arturo",
    "url": "/concepts/arturo.html"
  },
  {
    "label": "arvelie-format",
    "id": "arvelie-format",
    "url": "/concepts/arvelie-format.html"
  },
  {
    "label": "ASCII Armor",
    "id": "ascii-armor",
    "url": "/concepts/ascii-armor.html"
  },
  {
    "label": "ASCII",
    "id": "ascii",
    "url": "/concepts/ascii.html"
  },
  {
    "label": "AsciiDoc",
    "id": "asciidoc",
    "url": "/concepts/asciidoc.html"
  },
  {
    "label": "AsciiDots",
    "id": "asciidots",
    "url": "/concepts/asciidots.html"
  },
  {
    "label": "AsciiMath",
    "id": "asciimath",
    "url": "/concepts/asciimath.html"
  },
  {
    "label": "ASDF",
    "id": "asdf",
    "url": "/concepts/asdf.html"
  },
  {
    "label": "ASF+SDF",
    "id": "asf-sdf",
    "url": "/concepts/asf-sdf.html"
  },
  {
    "label": "ASHMEDAI",
    "id": "ashmedai",
    "url": "/concepts/ashmedai.html"
  },
  {
    "label": "ASIC",
    "id": "asic-programming-language",
    "url": "/concepts/asic-programming-language.html"
  },
  {
    "label": "Asm.js",
    "id": "asmjs",
    "url": "/concepts/asmjs.html"
  },
  {
    "label": "ASN.1",
    "id": "asn-1",
    "url": "/concepts/asn-1.html"
  },
  {
    "label": "ASP.NET",
    "id": "asp.net",
    "url": "/concepts/asp.net.html"
  },
  {
    "label": "ASP",
    "id": "asp",
    "url": "/concepts/asp.html"
  },
  {
    "label": "AspectC++",
    "id": "aspectcpp",
    "url": "/concepts/aspectcpp.html"
  },
  {
    "label": "AspectJ",
    "id": "aspectj",
    "url": "/concepts/aspectj.html"
  },
  {
    "label": "ASPEN",
    "id": "aspen",
    "url": "/concepts/aspen.html"
  },
  {
    "label": "ASPOL",
    "id": "aspol",
    "url": "/concepts/aspol.html"
  },
  {
    "label": "Assembly language",
    "id": "assembly-language",
    "url": "/concepts/assembly-language.html"
  },
  {
    "label": "AssemblyScript",
    "id": "assemblyscript",
    "url": "/concepts/assemblyscript.html"
  },
  {
    "label": "associons",
    "id": "associons",
    "url": "/concepts/associons.html"
  },
  {
    "label": "Asspegique",
    "id": "asspegique",
    "url": "/concepts/asspegique.html"
  },
  {
    "label": "Astatine",
    "id": "astatine",
    "url": "/concepts/astatine.html"
  },
  {
    "label": "Asterisk",
    "id": "asterisk",
    "url": "/concepts/asterisk.html"
  },
  {
    "label": "asterius-compiler",
    "id": "asterius-compiler",
    "url": "/concepts/asterius-compiler.html"
  },
  {
    "label": "ASTLOG",
    "id": "astlog",
    "url": "/concepts/astlog.html"
  },
  {
    "label": "astro",
    "id": "astro",
    "url": "/concepts/astro.html"
  },
  {
    "label": "astroml",
    "id": "astroml",
    "url": "/concepts/astroml.html"
  },
  {
    "label": "Asymptote",
    "id": "asymptote",
    "url": "/concepts/asymptote.html"
  },
  {
    "label": "Atari BASIC",
    "id": "atari-basic",
    "url": "/concepts/atari-basic.html"
  },
  {
    "label": "Atari Microsoft BASIC",
    "id": "atari-microsoft-basic",
    "url": "/concepts/atari-microsoft-basic.html"
  },
  {
    "label": "Atari ST BASIC",
    "id": "atari-st-basic",
    "url": "/concepts/atari-st-basic.html"
  },
  {
    "label": "Atlas Autocode",
    "id": "atlas-autocode",
    "url": "/concepts/atlas-autocode.html"
  },
  {
    "label": "ATLAS Transformation Language",
    "id": "atlas",
    "url": "/concepts/atlas.html"
  },
  {
    "label": "Atmel AVR",
    "id": "atmel-avr",
    "url": "/concepts/atmel-avr.html"
  },
  {
    "label": "ATOL",
    "id": "atol",
    "url": "/concepts/atol.html"
  },
  {
    "label": "Atom",
    "id": "atom-editor",
    "url": "/concepts/atom-editor.html"
  },
  {
    "label": "Atom",
    "id": "atom",
    "url": "/concepts/atom.html"
  },
  {
    "label": "Atomese",
    "id": "atomese",
    "url": "/concepts/atomese.html"
  },
  {
    "label": "atomo",
    "id": "atomo",
    "url": "/concepts/atomo.html"
  },
  {
    "label": "Atomos",
    "id": "atomos",
    "url": "/concepts/atomos.html"
  },
  {
    "label": "atomspace",
    "id": "atomspace",
    "url": "/concepts/atomspace.html"
  },
  {
    "label": "ATS",
    "id": "ats",
    "url": "/concepts/ats.html"
  },
  {
    "label": "Attic numerals",
    "id": "attic-numerals",
    "url": "/concepts/attic-numerals.html"
  },
  {
    "label": "attoparsec",
    "id": "attoparsec",
    "url": "/concepts/attoparsec.html"
  },
  {
    "label": "atx",
    "id": "atx",
    "url": "/concepts/atx.html"
  },
  {
    "label": "aubit-4gl",
    "id": "aubit-4gl",
    "url": "/concepts/aubit-4gl.html"
  },
  {
    "label": "Augeas",
    "id": "augeas",
    "url": "/concepts/augeas.html"
  },
  {
    "label": "Augment",
    "id": "augment",
    "url": "/concepts/augment.html"
  },
  {
    "label": "AUI",
    "id": "aui",
    "url": "/concepts/aui.html"
  },
  {
    "label": "AUR",
    "id": "aur-pm",
    "url": "/concepts/aur-pm.html"
  },
  {
    "label": "Aurora",
    "id": "aurora",
    "url": "/concepts/aurora.html"
  },
  {
    "label": "Austral",
    "id": "austral",
    "url": "/concepts/austral.html"
  },
  {
    "label": "AUTASIM",
    "id": "autasim",
    "url": "/concepts/autasim.html"
  },
  {
    "label": "AUTOCAD",
    "id": "autocad-app",
    "url": "/concepts/autocad-app.html"
  },
  {
    "label": "Autocode",
    "id": "autocode",
    "url": "/concepts/autocode.html"
  },
  {
    "label": "AUTOCODER II",
    "id": "autocoder-ii",
    "url": "/concepts/autocoder-ii.html"
  },
  {
    "label": "AUTOCODER III",
    "id": "autocoder-iii",
    "url": "/concepts/autocoder-iii.html"
  },
  {
    "label": "AUTOCODER",
    "id": "autocoder",
    "url": "/concepts/autocoder.html"
  },
  {
    "label": "Autoconf",
    "id": "autoconf",
    "url": "/concepts/autoconf.html"
  },
  {
    "label": "AUTODRAFT",
    "id": "autodraft",
    "url": "/concepts/autodraft.html"
  },
  {
    "label": "AUTOGRP",
    "id": "autogrp",
    "url": "/concepts/autogrp.html"
  },
  {
    "label": "AutoHotkey",
    "id": "autohotkey",
    "url": "/concepts/autohotkey.html"
  },
  {
    "label": "AutoIt",
    "id": "autoit",
    "url": "/concepts/autoit.html"
  },
  {
    "label": "AutoLISP",
    "id": "autolisp",
    "url": "/concepts/autolisp.html"
  },
  {
    "label": "AUTOLOFT",
    "id": "autoloft",
    "url": "/concepts/autoloft.html"
  },
  {
    "label": "AUTOMAST",
    "id": "automast",
    "url": "/concepts/automast.html"
  },
  {
    "label": "Automator",
    "id": "automator",
    "url": "/concepts/automator.html"
  },
  {
    "label": "AUTOmatic PROgramming of Machine Tools",
    "id": "autopromt",
    "url": "/concepts/autopromt.html"
  },
  {
    "label": "Avail",
    "id": "avail",
    "url": "/concepts/avail.html"
  },
  {
    "label": "Avalon/Common LISP",
    "id": "avalon-common-lisp",
    "url": "/concepts/avalon-common-lisp.html"
  },
  {
    "label": "Averest",
    "id": "averest",
    "url": "/concepts/averest.html"
  },
  {
    "label": "AviSynth",
    "id": "avi-synth",
    "url": "/concepts/avi-synth.html"
  },
  {
    "label": "Atmel AVR instruction set",
    "id": "avr",
    "url": "/concepts/avr.html"
  },
  {
    "label": "avro",
    "id": "avro",
    "url": "/concepts/avro.html"
  },
  {
    "label": "awk",
    "id": "awk",
    "url": "/concepts/awk.html"
  },
  {
    "label": "awl",
    "id": "awl",
    "url": "/concepts/awl.html"
  },
  {
    "label": "AWS",
    "id": "aws",
    "url": "/concepts/aws.html"
  },
  {
    "label": "axcess",
    "id": "axcess",
    "url": "/concepts/axcess.html"
  },
  {
    "label": "Axiom",
    "id": "axiom-computer-algebra-system",
    "url": "/concepts/axiom-computer-algebra-system.html"
  },
  {
    "label": "AXIOM",
    "id": "axiom",
    "url": "/concepts/axiom.html"
  },
  {
    "label": "axt-format",
    "id": "axt-format",
    "url": "/concepts/axt-format.html"
  },
  {
    "label": "Aztec C",
    "id": "aztec-c",
    "url": "/concepts/aztec-c.html"
  },
  {
    "label": "Microsoft Azure",
    "id": "azure",
    "url": "/concepts/azure.html"
  },
  {
    "label": "B-LINE",
    "id": "b-line",
    "url": "/concepts/b-line.html"
  },
  {
    "label": "B",
    "id": "b",
    "url": "/concepts/b.html"
  },
  {
    "label": "B3 IR",
    "id": "b3-ir",
    "url": "/concepts/b3-ir.html"
  },
  {
    "label": "B32 Business Basic",
    "id": "b32-business-basic",
    "url": "/concepts/b32-business-basic.html"
  },
  {
    "label": "B4Tran",
    "id": "b4tran",
    "url": "/concepts/b4tran.html"
  },
  {
    "label": "BABEL",
    "id": "babel",
    "url": "/concepts/babel.html"
  },
  {
    "label": "Baby modula-3",
    "id": "baby-modula-3",
    "url": "/concepts/baby-modula-3.html"
  },
  {
    "label": "Babylonian numerals",
    "id": "babylonian-numerals",
    "url": "/concepts/babylonian-numerals.html"
  },
  {
    "label": "BACK",
    "id": "back",
    "url": "/concepts/back.html"
  },
  {
    "label": "badlanguage",
    "id": "badlanguage",
    "url": "/concepts/badlanguage.html"
  },
  {
    "label": "bag-format",
    "id": "bag-format",
    "url": "/concepts/bag-format.html"
  },
  {
    "label": "Balanced ternary",
    "id": "balanced-ternary-notation",
    "url": "/concepts/balanced-ternary-notation.html"
  },
  {
    "label": "BALG",
    "id": "balg",
    "url": "/concepts/balg.html"
  },
  {
    "label": "BALGOL",
    "id": "balgol",
    "url": "/concepts/balgol.html"
  },
  {
    "label": "BaLinda Lisp",
    "id": "balinda-lisp",
    "url": "/concepts/balinda-lisp.html"
  },
  {
    "label": "ballerina-central-pm",
    "id": "ballerina-central-pm",
    "url": "/concepts/ballerina-central-pm.html"
  },
  {
    "label": "Ballerina",
    "id": "ballerina",
    "url": "/concepts/ballerina.html"
  },
  {
    "label": "BALM",
    "id": "balm",
    "url": "/concepts/balm.html"
  },
  {
    "label": "BALSA",
    "id": "balsa",
    "url": "/concepts/balsa.html"
  },
  {
    "label": "baltazar",
    "id": "baltazar",
    "url": "/concepts/baltazar.html"
  },
  {
    "label": "Baltík",
    "id": "baltik",
    "url": "/concepts/baltik.html"
  },
  {
    "label": "Binary Alignment Map",
    "id": "bam-format",
    "url": "/concepts/bam-format.html"
  },
  {
    "label": "bamboo",
    "id": "bamboo",
    "url": "/concepts/bamboo.html"
  },
  {
    "label": "BANCStar",
    "id": "bancstar-programming-language",
    "url": "/concepts/bancstar-programming-language.html"
  },
  {
    "label": "BARE",
    "id": "bare",
    "url": "/concepts/bare.html"
  },
  {
    "label": "Barrel",
    "id": "barrel",
    "url": "/concepts/barrel.html"
  },
  {
    "label": "Bartok",
    "id": "bartok",
    "url": "/concepts/bartok.html"
  },
  {
    "label": "Base64",
    "id": "base64",
    "url": "/concepts/base64.html"
  },
  {
    "label": "BASEBALL",
    "id": "baseball",
    "url": "/concepts/baseball.html"
  },
  {
    "label": "BASEL",
    "id": "basel",
    "url": "/concepts/basel.html"
  },
  {
    "label": "Bash",
    "id": "bash",
    "url": "/concepts/bash.html"
  },
  {
    "label": "BASIC-11",
    "id": "basic-11",
    "url": "/concepts/basic-11.html"
  },
  {
    "label": "Basic-256",
    "id": "basic-256",
    "url": "/concepts/basic-256.html"
  },
  {
    "label": "BASIC A+",
    "id": "basic-ap",
    "url": "/concepts/basic-ap.html"
  },
  {
    "label": "BASIC-E",
    "id": "basic-e",
    "url": "/concepts/basic-e.html"
  },
  {
    "label": "Basic PDP-1 Lisp",
    "id": "basic-pdp-1-lisp",
    "url": "/concepts/basic-pdp-1-lisp.html"
  },
  {
    "label": "BASIC-PLUS",
    "id": "basic-plus",
    "url": "/concepts/basic-plus.html"
  },
  {
    "label": "BASIC Programming",
    "id": "basic-programming",
    "url": "/concepts/basic-programming.html"
  },
  {
    "label": "BASIC Stamp",
    "id": "basic-stamp",
    "url": "/concepts/basic-stamp.html"
  },
  {
    "label": "BASIC",
    "id": "basic",
    "url": "/concepts/basic.html"
  },
  {
    "label": "BASIC09",
    "id": "basic09",
    "url": "/concepts/basic09.html"
  },
  {
    "label": "Basic4android",
    "id": "basic4android",
    "url": "/concepts/basic4android.html"
  },
  {
    "label": "Basic4GL",
    "id": "basic4gl",
    "url": "/concepts/basic4gl.html"
  },
  {
    "label": "Basic4ppc",
    "id": "basic4ppc",
    "url": "/concepts/basic4ppc.html"
  },
  {
    "label": "BASICODE",
    "id": "basicode",
    "url": "/concepts/basicode.html"
  },
  {
    "label": "BasicX",
    "id": "basicx",
    "url": "/concepts/basicx.html"
  },
  {
    "label": "BASIL",
    "id": "basil",
    "url": "/concepts/basil.html"
  },
  {
    "label": "Basis Codec",
    "id": "basis-universal-format",
    "url": "/concepts/basis-universal-format.html"
  },
  {
    "label": "Batari Basic",
    "id": "batari-basic",
    "url": "/concepts/batari-basic.html"
  },
  {
    "label": "Batchfile",
    "id": "batch",
    "url": "/concepts/batch.html"
  },
  {
    "label": "Battlestar",
    "id": "battlestar",
    "url": "/concepts/battlestar.html"
  },
  {
    "label": "bawk",
    "id": "bawk",
    "url": "/concepts/bawk.html"
  },
  {
    "label": "Bayer Expressions",
    "id": "bayer-expressions",
    "url": "/concepts/bayer-expressions.html"
  },
  {
    "label": "Bayes' Equation",
    "id": "bayes-equation",
    "url": "/concepts/bayes-equation.html"
  },
  {
    "label": "baysick",
    "id": "baysick",
    "url": "/concepts/baysick.html"
  },
  {
    "label": "Bazel",
    "id": "bazel",
    "url": "/concepts/bazel.html"
  },
  {
    "label": "BBC BASIC",
    "id": "bbc-basic",
    "url": "/concepts/bbc-basic.html"
  },
  {
    "label": "BBCode",
    "id": "bbcode",
    "url": "/concepts/bbcode.html"
  },
  {
    "label": "BBj",
    "id": "bbj",
    "url": "/concepts/bbj.html"
  },
  {
    "label": "BBN-LISP",
    "id": "bbn-lisp",
    "url": "/concepts/bbn-lisp.html"
  },
  {
    "label": "BBx",
    "id": "bbx",
    "url": "/concepts/bbx.html"
  },
  {
    "label": "BC NELIAC",
    "id": "bc-neliac",
    "url": "/concepts/bc-neliac.html"
  },
  {
    "label": "basic calculator",
    "id": "bc",
    "url": "/concepts/bc.html"
  },
  {
    "label": "BCPL",
    "id": "bcpl",
    "url": "/concepts/bcpl.html"
  },
  {
    "label": "BCX",
    "id": "bcx",
    "url": "/concepts/bcx.html"
  },
  {
    "label": "BDL",
    "id": "bdl",
    "url": "/concepts/bdl.html"
  },
  {
    "label": "beads-lang",
    "id": "beads-lang",
    "url": "/concepts/beads-lang.html"
  },
  {
    "label": "beagle",
    "id": "beagle",
    "url": "/concepts/beagle.html"
  },
  {
    "label": "BEAM Bytecode",
    "id": "beam-bytecode",
    "url": "/concepts/beam-bytecode.html"
  },
  {
    "label": "BEAM Erlang virtual machine",
    "id": "beam-vm",
    "url": "/concepts/beam-vm.html"
  },
  {
    "label": "BeanShell",
    "id": "beanshell",
    "url": "/concepts/beanshell.html"
  },
  {
    "label": "Beatnik",
    "id": "beatnik",
    "url": "/concepts/beatnik.html"
  },
  {
    "label": "beautiful-report-language",
    "id": "beautiful-report-language",
    "url": "/concepts/beautiful-report-language.html"
  },
  {
    "label": "BeBasic",
    "id": "bebasic",
    "url": "/concepts/bebasic.html"
  },
  {
    "label": "Browser Extensible Data Format",
    "id": "bed-format",
    "url": "/concepts/bed-format.html"
  },
  {
    "label": "BEDSOCS",
    "id": "bedsocs",
    "url": "/concepts/bedsocs.html"
  },
  {
    "label": "bee",
    "id": "bee",
    "url": "/concepts/bee.html"
  },
  {
    "label": "BeeBasic",
    "id": "beebasic",
    "url": "/concepts/beebasic.html"
  },
  {
    "label": "BEEF",
    "id": "beef-lang",
    "url": "/concepts/beef-lang.html"
  },
  {
    "label": "beef-lang",
    "id": "beef",
    "url": "/concepts/beef.html"
  },
  {
    "label": "BEFLIX",
    "id": "beflix",
    "url": "/concepts/beflix.html"
  },
  {
    "label": "Befunge",
    "id": "befunge",
    "url": "/concepts/befunge.html"
  },
  {
    "label": "BML",
    "id": "behavior-markup-language",
    "url": "/concepts/behavior-markup-language.html"
  },
  {
    "label": "Biological Expression Language",
    "id": "bel-lang",
    "url": "/concepts/bel-lang.html"
  },
  {
    "label": "Bel",
    "id": "bel",
    "url": "/concepts/bel.html"
  },
  {
    "label": "BER",
    "id": "ber",
    "url": "/concepts/ber.html"
  },
  {
    "label": "Berkeley DB",
    "id": "berkeley-db-lib",
    "url": "/concepts/berkeley-db-lib.html"
  },
  {
    "label": "Berkeley DB",
    "id": "berkeleydb",
    "url": "/concepts/berkeleydb.html"
  },
  {
    "label": "Berry",
    "id": "berry",
    "url": "/concepts/berry.html"
  },
  {
    "label": "BESYS",
    "id": "besys",
    "url": "/concepts/besys.html"
  },
  {
    "label": "Beta BASIC",
    "id": "beta-basic",
    "url": "/concepts/beta-basic.html"
  },
  {
    "label": "BETA Project",
    "id": "beta-project",
    "url": "/concepts/beta-project.html"
  },
  {
    "label": "Beta-Prolog",
    "id": "beta-prolog",
    "url": "/concepts/beta-prolog.html"
  },
  {
    "label": "BETA",
    "id": "beta",
    "url": "/concepts/beta.html"
  },
  {
    "label": "BGRAF2",
    "id": "bgraf2",
    "url": "/concepts/bgraf2.html"
  },
  {
    "label": "BHSL",
    "id": "bhsl",
    "url": "/concepts/bhsl.html"
  },
  {
    "label": "BibTeX",
    "id": "bibtex",
    "url": "/concepts/bibtex.html"
  },
  {
    "label": "Bicep",
    "id": "bicep",
    "url": "/concepts/bicep.html"
  },
  {
    "label": "Biferno",
    "id": "biferno",
    "url": "/concepts/biferno.html"
  },
  {
    "label": "Bigloo",
    "id": "bigloo",
    "url": "/concepts/bigloo.html"
  },
  {
    "label": "BIGMAC",
    "id": "bigmac",
    "url": "/concepts/bigmac.html"
  },
  {
    "label": "bigWig format",
    "id": "bigwig-format",
    "url": "/concepts/bigwig-format.html"
  },
  {
    "label": "Bigwig Programming Language",
    "id": "bigwig-programming-language",
    "url": "/concepts/bigwig-programming-language.html"
  },
  {
    "label": "BIGWIG",
    "id": "bigwig",
    "url": "/concepts/bigwig.html"
  },
  {
    "label": "Binary Equation",
    "id": "binary-equation",
    "url": "/concepts/binary-equation.html"
  },
  {
    "label": "Binary Ninja",
    "id": "binary-ninja",
    "url": "/concepts/binary-ninja.html"
  },
  {
    "label": "Binary notation",
    "id": "binary-notation",
    "url": "/concepts/binary-notation.html"
  },
  {
    "label": "binaryen",
    "id": "binaryen",
    "url": "/concepts/binaryen.html"
  },
  {
    "label": "BIND",
    "id": "bind-app",
    "url": "/concepts/bind-app.html"
  },
  {
    "label": "Bioconductor",
    "id": "bioconductor-pm",
    "url": "/concepts/bioconductor-pm.html"
  },
  {
    "label": "BIOMOD",
    "id": "biomod",
    "url": "/concepts/biomod.html"
  },
  {
    "label": "bioscript",
    "id": "bioscript",
    "url": "/concepts/bioscript.html"
  },
  {
    "label": "BIOSSIM",
    "id": "biossim",
    "url": "/concepts/biossim.html"
  },
  {
    "label": "BIPLAN",
    "id": "biplan",
    "url": "/concepts/biplan.html"
  },
  {
    "label": "BIRD",
    "id": "bird",
    "url": "/concepts/bird.html"
  },
  {
    "label": "Birkbeck Assembly",
    "id": "birkbeck-assembly",
    "url": "/concepts/birkbeck-assembly.html"
  },
  {
    "label": "Bison",
    "id": "bison",
    "url": "/concepts/bison.html"
  },
  {
    "label": "Bison++",
    "id": "bisonpp",
    "url": "/concepts/bisonpp.html"
  },
  {
    "label": "Bistro",
    "id": "bistro-programming-language",
    "url": "/concepts/bistro-programming-language.html"
  },
  {
    "label": "Bit array",
    "id": "bitarray",
    "url": "/concepts/bitarray.html"
  },
  {
    "label": "BitBake",
    "id": "bitbake",
    "url": "/concepts/bitbake.html"
  },
  {
    "label": "BitC",
    "id": "bitc",
    "url": "/concepts/bitc.html"
  },
  {
    "label": "Bizubee",
    "id": "bizubee",
    "url": "/concepts/bizubee.html"
  },
  {
    "label": "bjou",
    "id": "bjou",
    "url": "/concepts/bjou.html"
  },
  {
    "label": "Bla",
    "id": "bla",
    "url": "/concepts/bla.html"
  },
  {
    "label": "BlackCoffee",
    "id": "blackcoffee",
    "url": "/concepts/blackcoffee.html"
  },
  {
    "label": "Blacklight",
    "id": "blacklight",
    "url": "/concepts/blacklight.html"
  },
  {
    "label": "Blade",
    "id": "blade-lang",
    "url": "/concepts/blade-lang.html"
  },
  {
    "label": "Blade",
    "id": "blade",
    "url": "/concepts/blade.html"
  },
  {
    "label": "BLAKE",
    "id": "blake-hash-function",
    "url": "/concepts/blake-hash-function.html"
  },
  {
    "label": "blank",
    "id": "blank",
    "url": "/concepts/blank.html"
  },
  {
    "label": "BLAZE 2",
    "id": "blaze-2",
    "url": "/concepts/blaze-2.html"
  },
  {
    "label": "BLAZE",
    "id": "blaze",
    "url": "/concepts/blaze.html"
  },
  {
    "label": "BlazeX",
    "id": "blazex",
    "url": "/concepts/blazex.html"
  },
  {
    "label": "Binary Lambda Calculus",
    "id": "blc",
    "url": "/concepts/blc.html"
  },
  {
    "label": "Blender",
    "id": "blender-app",
    "url": "/concepts/blender-app.html"
  },
  {
    "label": "BLISS",
    "id": "bliss",
    "url": "/concepts/bliss.html"
  },
  {
    "label": "Blitz3D",
    "id": "blitz3d",
    "url": "/concepts/blitz3d.html"
  },
  {
    "label": "BlitzBasic",
    "id": "blitzbasic",
    "url": "/concepts/blitzbasic.html"
  },
  {
    "label": "BlitzMax",
    "id": "blitzmax",
    "url": "/concepts/blitzmax.html"
  },
  {
    "label": "BlitzPlus",
    "id": "blitzplus",
    "url": "/concepts/blitzplus.html"
  },
  {
    "label": "Blockly",
    "id": "blockly",
    "url": "/concepts/blockly.html"
  },
  {
    "label": "blockml",
    "id": "blockml",
    "url": "/concepts/blockml.html"
  },
  {
    "label": "bloom",
    "id": "bloom",
    "url": "/concepts/bloom.html"
  },
  {
    "label": "BLOOMS",
    "id": "blooms",
    "url": "/concepts/blooms.html"
  },
  {
    "label": "BlooP",
    "id": "bloop",
    "url": "/concepts/bloop.html"
  },
  {
    "label": "Blox",
    "id": "blox",
    "url": "/concepts/blox.html"
  },
  {
    "label": "Blue",
    "id": "blue-programming-language",
    "url": "/concepts/blue-programming-language.html"
  },
  {
    "label": "blue",
    "id": "blue",
    "url": "/concepts/blue.html"
  },
  {
    "label": "Blueprints",
    "id": "blueprints",
    "url": "/concepts/blueprints.html"
  },
  {
    "label": "Bluespec",
    "id": "bluespec",
    "url": "/concepts/bluespec.html"
  },
  {
    "label": "blur-markup-language",
    "id": "blur-markup-language",
    "url": "/concepts/blur-markup-language.html"
  },
  {
    "label": "blz",
    "id": "blz",
    "url": "/concepts/blz.html"
  },
  {
    "label": "BMD",
    "id": "bmd",
    "url": "/concepts/bmd.html"
  },
  {
    "label": "bml",
    "id": "bml",
    "url": "/concepts/bml.html"
  },
  {
    "label": "BMP file format",
    "id": "bmp-format",
    "url": "/concepts/bmp-format.html"
  },
  {
    "label": "BNF",
    "id": "bnf",
    "url": "/concepts/bnf.html"
  },
  {
    "label": "boa",
    "id": "boa",
    "url": "/concepts/boa.html"
  },
  {
    "label": "Bob",
    "id": "bob",
    "url": "/concepts/bob.html"
  },
  {
    "label": "bog",
    "id": "bog",
    "url": "/concepts/bog.html"
  },
  {
    "label": "BOIL",
    "id": "boil",
    "url": "/concepts/boil.html"
  },
  {
    "label": "Bolin",
    "id": "bolin",
    "url": "/concepts/bolin.html"
  },
  {
    "label": "BOLT",
    "id": "bolt",
    "url": "/concepts/bolt.html"
  },
  {
    "label": "Bon",
    "id": "bon-programming-language",
    "url": "/concepts/bon-programming-language.html"
  },
  {
    "label": "Boo",
    "id": "boo",
    "url": "/concepts/boo.html"
  },
  {
    "label": "Boogie",
    "id": "boogie",
    "url": "/concepts/boogie.html"
  },
  {
    "label": "Boomerang Decompiler",
    "id": "boomerang-decompiler",
    "url": "/concepts/boomerang-decompiler.html"
  },
  {
    "label": "Boost C++ libraries",
    "id": "boost-lib",
    "url": "/concepts/boost-lib.html"
  },
  {
    "label": "Booster",
    "id": "booster",
    "url": "/concepts/booster.html"
  },
  {
    "label": "Borneo",
    "id": "borneo",
    "url": "/concepts/borneo.html"
  },
  {
    "label": "Boron",
    "id": "boron",
    "url": "/concepts/boron.html"
  },
  {
    "label": "bosque",
    "id": "bosque",
    "url": "/concepts/bosque.html"
  },
  {
    "label": "Bossam Rule Language",
    "id": "bossam",
    "url": "/concepts/bossam.html"
  },
  {
    "label": "Bounce",
    "id": "bounce-lang",
    "url": "/concepts/bounce-lang.html"
  },
  {
    "label": "Bounce",
    "id": "bounce",
    "url": "/concepts/bounce.html"
  },
  {
    "label": "Bourne shell",
    "id": "bourne-shell",
    "url": "/concepts/bourne-shell.html"
  },
  {
    "label": "Boxer",
    "id": "boxer",
    "url": "/concepts/boxer.html"
  },
  {
    "label": "Boxx",
    "id": "boxx",
    "url": "/concepts/boxx.html"
  },
  {
    "label": "BPEL",
    "id": "bpel",
    "url": "/concepts/bpel.html"
  },
  {
    "label": "bpkg-pm",
    "id": "bpkg-pm",
    "url": "/concepts/bpkg-pm.html"
  },
  {
    "label": "BPL",
    "id": "bpl",
    "url": "/concepts/bpl.html"
  },
  {
    "label": "BPMN",
    "id": "bpmn",
    "url": "/concepts/bpmn.html"
  },
  {
    "label": "Basic Petri Net Programming Notation",
    "id": "bpn2",
    "url": "/concepts/bpn2.html"
  },
  {
    "label": "BQN",
    "id": "bqn",
    "url": "/concepts/bqn.html"
  },
  {
    "label": "brackets-editor",
    "id": "brackets-editor",
    "url": "/concepts/brackets-editor.html"
  },
  {
    "label": "Brain-Flak",
    "id": "brain-flak",
    "url": "/concepts/brain-flak.html"
  },
  {
    "label": "Brainfuck",
    "id": "brainfuck",
    "url": "/concepts/brainfuck.html"
  },
  {
    "label": "Breccia",
    "id": "breccia",
    "url": "/concepts/breccia.html"
  },
  {
    "label": "BridgeTalk",
    "id": "bridgetalk",
    "url": "/concepts/bridgetalk.html"
  },
  {
    "label": "BrightScript",
    "id": "brightscript-lang",
    "url": "/concepts/brightscript-lang.html"
  },
  {
    "label": "Brisk",
    "id": "brisk",
    "url": "/concepts/brisk.html"
  },
  {
    "label": "BRL",
    "id": "brl",
    "url": "/concepts/brl.html"
  },
  {
    "label": "Bro",
    "id": "bro",
    "url": "/concepts/bro.html"
  },
  {
    "label": "Broccoli",
    "id": "broccoli-1",
    "url": "/concepts/broccoli-1.html"
  },
  {
    "label": "Broccoli",
    "id": "broccoli-2",
    "url": "/concepts/broccoli-2.html"
  },
  {
    "label": "Broccoli",
    "id": "broccoli",
    "url": "/concepts/broccoli.html"
  },
  {
    "label": "brooks-programming-language",
    "id": "brooks-programming-language",
    "url": "/concepts/brooks-programming-language.html"
  },
  {
    "label": "BrouHaHa",
    "id": "brouhaha",
    "url": "/concepts/brouhaha.html"
  },
  {
    "label": "BRUIN",
    "id": "brown-university-interactive-language",
    "url": "/concepts/brown-university-interactive-language.html"
  },
  {
    "label": "bscript-interpreter",
    "id": "bscript-interpreter",
    "url": "/concepts/bscript-interpreter.html"
  },
  {
    "label": "BScript",
    "id": "bscript",
    "url": "/concepts/bscript.html"
  },
  {
    "label": "BSML",
    "id": "bsml",
    "url": "/concepts/bsml.html"
  },
  {
    "label": "BSP",
    "id": "bsp",
    "url": "/concepts/bsp.html"
  },
  {
    "label": "Bucardo",
    "id": "bucardo",
    "url": "/concepts/bucardo.html"
  },
  {
    "label": "Bucklescript",
    "id": "bucklescript",
    "url": "/concepts/bucklescript.html"
  },
  {
    "label": "BuddyScript",
    "id": "buddyscript",
    "url": "/concepts/buddyscript.html"
  },
  {
    "label": "BUGSYS",
    "id": "bugsys",
    "url": "/concepts/bugsys.html"
  },
  {
    "label": "BullFrog",
    "id": "bullfrog",
    "url": "/concepts/bullfrog.html"
  },
  {
    "label": "Bun",
    "id": "bun",
    "url": "/concepts/bun.html"
  },
  {
    "label": "BUSH",
    "id": "bush",
    "url": "/concepts/bush.html"
  },
  {
    "label": "Business application language",
    "id": "business-application-language",
    "url": "/concepts/business-application-language.html"
  },
  {
    "label": "Business Basic",
    "id": "business-basic",
    "url": "/concepts/business-basic.html"
  },
  {
    "label": "Business Object Notation",
    "id": "business-object-notation",
    "url": "/concepts/business-object-notation.html"
  },
  {
    "label": "BPML",
    "id": "business-process-modeling-language",
    "url": "/concepts/business-process-modeling-language.html"
  },
  {
    "label": "business-rule-language",
    "id": "business-rule-language",
    "url": "/concepts/business-rule-language.html"
  },
  {
    "label": "Butterfly Common LISP",
    "id": "butterfly-common-lisp",
    "url": "/concepts/butterfly-common-lisp.html"
  },
  {
    "label": "buzz",
    "id": "buzz",
    "url": "/concepts/buzz.html"
  },
  {
    "label": "bx",
    "id": "bx",
    "url": "/concepts/bx.html"
  },
  {
    "label": "bytecode-modeling-language",
    "id": "bytecode-modeling-language",
    "url": "/concepts/bytecode-modeling-language.html"
  },
  {
    "label": "ByteLisp",
    "id": "bytelisp",
    "url": "/concepts/bytelisp.html"
  },
  {
    "label": "Bython",
    "id": "bython",
    "url": "/concepts/bython.html"
  },
  {
    "label": "Bywater BASIC",
    "id": "bywater-basic",
    "url": "/concepts/bywater-basic.html"
  },
  {
    "label": "C--",
    "id": "c--",
    "url": "/concepts/c--.html"
  },
  {
    "label": "C/AL",
    "id": "c-al",
    "url": "/concepts/c-al.html"
  },
  {
    "label": "C^3",
    "id": "c-cubed",
    "url": "/concepts/c-cubed.html"
  },
  {
    "label": "C flat",
    "id": "c-flat",
    "url": "/concepts/c-flat.html"
  },
  {
    "label": "C∀",
    "id": "c-for-all",
    "url": "/concepts/c-for-all.html"
  },
  {
    "label": "C Header Files",
    "id": "c-headers",
    "url": "/concepts/c-headers.html"
  },
  {
    "label": "C shell",
    "id": "c-shell",
    "url": "/concepts/c-shell.html"
  },
  {
    "label": "c-smile",
    "id": "c-smile",
    "url": "/concepts/c-smile.html"
  },
  {
    "label": "c-talk",
    "id": "c-talk",
    "url": "/concepts/c-talk.html"
  },
  {
    "label": "C",
    "id": "c",
    "url": "/concepts/c.html"
  },
  {
    "label": "C2",
    "id": "c2",
    "url": "/concepts/c2.html"
  },
  {
    "label": "C3",
    "id": "c3",
    "url": "/concepts/c3.html"
  },
  {
    "label": "CA-Realizer",
    "id": "ca-realizer",
    "url": "/concepts/ca-realizer.html"
  },
  {
    "label": "CA-Telon",
    "id": "ca-telon",
    "url": "/concepts/ca-telon.html"
  },
  {
    "label": "ca65 Assembly",
    "id": "ca65-assembly",
    "url": "/concepts/ca65-assembly.html"
  },
  {
    "label": "CABAL",
    "id": "cabal",
    "url": "/concepts/cabal.html"
  },
  {
    "label": "Caché Basic",
    "id": "cache-basic",
    "url": "/concepts/cache-basic.html"
  },
  {
    "label": "Caché ObjectScript",
    "id": "cache-objectscript",
    "url": "/concepts/cache-objectscript.html"
  },
  {
    "label": "Cactus",
    "id": "cactus",
    "url": "/concepts/cactus.html"
  },
  {
    "label": "Cadence SKILL",
    "id": "cadence-skill",
    "url": "/concepts/cadence-skill.html"
  },
  {
    "label": "cado-systems-technical-information",
    "id": "cado-systems-technical-information",
    "url": "/concepts/cado-systems-technical-information.html"
  },
  {
    "label": "CafeObj",
    "id": "cafeobj",
    "url": "/concepts/cafeobj.html"
  },
  {
    "label": "Caffeine",
    "id": "caffeine",
    "url": "/concepts/caffeine.html"
  },
  {
    "label": "CAGES",
    "id": "cages",
    "url": "/concepts/cages.html"
  },
  {
    "label": "CAISYS",
    "id": "caisys",
    "url": "/concepts/caisys.html"
  },
  {
    "label": "CAJOLE",
    "id": "cajole",
    "url": "/concepts/cajole.html"
  },
  {
    "label": "CAL Actor Language",
    "id": "cal",
    "url": "/concepts/cal.html"
  },
  {
    "label": "calc_var",
    "id": "calc-var",
    "url": "/concepts/calc-var.html"
  },
  {
    "label": "calc",
    "id": "calc",
    "url": "/concepts/calc.html"
  },
  {
    "label": "Calc4",
    "id": "calc4",
    "url": "/concepts/calc4.html"
  },
  {
    "label": "Cali-Lang",
    "id": "cali-lang",
    "url": "/concepts/cali-lang.html"
  },
  {
    "label": "Caltech Intermediate Form",
    "id": "caltech-intermediate-form",
    "url": "/concepts/caltech-intermediate-form.html"
  },
  {
    "label": "Calypso",
    "id": "calypso",
    "url": "/concepts/calypso.html"
  },
  {
    "label": "Content Assembly Mechanism",
    "id": "cam",
    "url": "/concepts/cam.html"
  },
  {
    "label": "CAMAC",
    "id": "camac",
    "url": "/concepts/camac.html"
  },
  {
    "label": "Cambridge Algebra System",
    "id": "camal",
    "url": "/concepts/camal.html"
  },
  {
    "label": "CAMIL",
    "id": "camil",
    "url": "/concepts/camil.html"
  },
  {
    "label": "Caml",
    "id": "caml",
    "url": "/concepts/caml.html"
  },
  {
    "label": "candor",
    "id": "candor",
    "url": "/concepts/candor.html"
  },
  {
    "label": "Candy Codes",
    "id": "candy-codes",
    "url": "/concepts/candy-codes.html"
  },
  {
    "label": "Candy",
    "id": "candy",
    "url": "/concepts/candy.html"
  },
  {
    "label": "Cane",
    "id": "cane",
    "url": "/concepts/cane.html"
  },
  {
    "label": "CaPSL",
    "id": "canon-capsl",
    "url": "/concepts/canon-capsl.html"
  },
  {
    "label": "Cantor",
    "id": "cantor",
    "url": "/concepts/cantor.html"
  },
  {
    "label": "Cap'n Proto",
    "id": "capn-proto",
    "url": "/concepts/capn-proto.html"
  },
  {
    "label": "Common Authentication Protocol Specification Language",
    "id": "capsl",
    "url": "/concepts/capsl.html"
  },
  {
    "label": "Capsule",
    "id": "capsule",
    "url": "/concepts/capsule.html"
  },
  {
    "label": "capybara",
    "id": "capybara",
    "url": "/concepts/capybara.html"
  },
  {
    "label": "Caramel",
    "id": "caramel",
    "url": "/concepts/caramel.html"
  },
  {
    "label": "Carbon",
    "id": "carbon",
    "url": "/concepts/carbon.html"
  },
  {
    "label": "carp",
    "id": "carp",
    "url": "/concepts/carp.html"
  },
  {
    "label": "Carpet",
    "id": "carpet",
    "url": "/concepts/carpet.html"
  },
  {
    "label": "carth",
    "id": "carth",
    "url": "/concepts/carth.html"
  },
  {
    "label": "CartoCSS",
    "id": "cartocss",
    "url": "/concepts/cartocss.html"
  },
  {
    "label": "Casio BASIC",
    "id": "casio-basic",
    "url": "/concepts/casio-basic.html"
  },
  {
    "label": "CASSANDRE",
    "id": "cassandre",
    "url": "/concepts/cassandre.html"
  },
  {
    "label": "cat",
    "id": "cat",
    "url": "/concepts/cat.html"
  },
  {
    "label": "Catala",
    "id": "catala",
    "url": "/concepts/catala.html"
  },
  {
    "label": "Catalysis",
    "id": "catalysis",
    "url": "/concepts/catalysis.html"
  },
  {
    "label": "categorical-query-language",
    "id": "categorical-query-language",
    "url": "/concepts/categorical-query-language.html"
  },
  {
    "label": "Cayenne",
    "id": "cayenne",
    "url": "/concepts/cayenne.html"
  },
  {
    "label": "CAYLEY",
    "id": "cayley",
    "url": "/concepts/cayley.html"
  },
  {
    "label": "CBASIC",
    "id": "cbasic",
    "url": "/concepts/cbasic.html"
  },
  {
    "label": "CBOR",
    "id": "cbor",
    "url": "/concepts/cbor.html"
  },
  {
    "label": "CCal",
    "id": "ccal",
    "url": "/concepts/ccal.html"
  },
  {
    "label": "Continuity of Care Document",
    "id": "ccd",
    "url": "/concepts/ccd.html"
  },
  {
    "label": "CCEL",
    "id": "ccel",
    "url": "/concepts/ccel.html"
  },
  {
    "label": "Continuity of Care Record",
    "id": "ccr",
    "url": "/concepts/ccr.html"
  },
  {
    "label": "CCS",
    "id": "ccs",
    "url": "/concepts/ccs.html"
  },
  {
    "label": "Clinical Document Architecture",
    "id": "cda",
    "url": "/concepts/cda.html"
  },
  {
    "label": "CBOR data definition language",
    "id": "cddl",
    "url": "/concepts/cddl.html"
  },
  {
    "label": "Common Data Format",
    "id": "cdf",
    "url": "/concepts/cdf.html"
  },
  {
    "label": "CDL",
    "id": "cdl",
    "url": "/concepts/cdl.html"
  },
  {
    "label": "CDL++",
    "id": "cdlpp",
    "url": "/concepts/cdlpp.html"
  },
  {
    "label": "CECIL",
    "id": "cecil",
    "url": "/concepts/cecil.html"
  },
  {
    "label": "Cedar Fortran",
    "id": "cedar-fortran",
    "url": "/concepts/cedar-fortran.html"
  },
  {
    "label": "Cedar",
    "id": "cedar",
    "url": "/concepts/cedar.html"
  },
  {
    "label": "CEEMAC",
    "id": "ceemac",
    "url": "/concepts/ceemac.html"
  },
  {
    "label": "CELIP",
    "id": "celip",
    "url": "/concepts/celip.html"
  },
  {
    "label": "Cell",
    "id": "cell",
    "url": "/concepts/cell.html"
  },
  {
    "label": "CELLSIM",
    "id": "cellsim",
    "url": "/concepts/cellsim.html"
  },
  {
    "label": "Celsius WebScript",
    "id": "celsius-webscript",
    "url": "/concepts/celsius-webscript.html"
  },
  {
    "label": "Ceprol",
    "id": "ceprol",
    "url": "/concepts/ceprol.html"
  },
  {
    "label": "Cesil",
    "id": "cesil",
    "url": "/concepts/cesil.html"
  },
  {
    "label": "Céu",
    "id": "ceu",
    "url": "/concepts/ceu.html"
  },
  {
    "label": "Ceylon",
    "id": "ceylon",
    "url": "/concepts/ceylon.html"
  },
  {
    "label": "CFEngine",
    "id": "cfengine",
    "url": "/concepts/cfengine.html"
  },
  {
    "label": "CFML",
    "id": "cfml",
    "url": "/concepts/cfml.html"
  },
  {
    "label": "CFScript",
    "id": "cfscript",
    "url": "/concepts/cfscript.html"
  },
  {
    "label": "Cg",
    "id": "cg",
    "url": "/concepts/cg.html"
  },
  {
    "label": "CGOL",
    "id": "cgol",
    "url": "/concepts/cgol.html"
  },
  {
    "label": "Ch computer programming",
    "id": "ch",
    "url": "/concepts/ch.html"
  },
  {
    "label": "chain-format",
    "id": "chain-format",
    "url": "/concepts/chain-format.html"
  },
  {
    "label": "CHAIN",
    "id": "chain-programming-language",
    "url": "/concepts/chain-programming-language.html"
  },
  {
    "label": "Conway chained arrow notation",
    "id": "chained-arrow-notation",
    "url": "/concepts/chained-arrow-notation.html"
  },
  {
    "label": "chaiscript",
    "id": "chaiscript",
    "url": "/concepts/chaiscript.html"
  },
  {
    "label": "CHAMP",
    "id": "champ",
    "url": "/concepts/champ.html"
  },
  {
    "label": "chaos-lang",
    "id": "chaos-lang",
    "url": "/concepts/chaos-lang.html"
  },
  {
    "label": "Chapel",
    "id": "chapel",
    "url": "/concepts/chapel.html"
  },
  {
    "label": "chappe-code",
    "id": "chappe-code",
    "url": "/concepts/chappe-code.html"
  },
  {
    "label": "Charcoal",
    "id": "charcoal",
    "url": "/concepts/charcoal.html"
  },
  {
    "label": "Charity",
    "id": "charity",
    "url": "/concepts/charity.html"
  },
  {
    "label": "charly",
    "id": "charly",
    "url": "/concepts/charly.html"
  },
  {
    "label": "CHARM++",
    "id": "charmpp",
    "url": "/concepts/charmpp.html"
  },
  {
    "label": "Charrette Ada",
    "id": "charrette-ada",
    "url": "/concepts/charrette-ada.html"
  },
  {
    "label": "chartio-app",
    "id": "chartio-app",
    "url": "/concepts/chartio-app.html"
  },
  {
    "label": "CHARYBDIS",
    "id": "charybdis",
    "url": "/concepts/charybdis.html"
  },
  {
    "label": "chatterbot",
    "id": "chatterbot",
    "url": "/concepts/chatterbot.html"
  },
  {
    "label": "checked-c",
    "id": "checked-c",
    "url": "/concepts/checked-c.html"
  },
  {
    "label": "checkout",
    "id": "checkout",
    "url": "/concepts/checkout.html"
  },
  {
    "label": "CheetahTemplate",
    "id": "cheetah",
    "url": "/concepts/cheetah.html"
  },
  {
    "label": "chef",
    "id": "chef",
    "url": "/concepts/chef.html"
  },
  {
    "label": "ChemTrains",
    "id": "chemtrains",
    "url": "/concepts/chemtrains.html"
  },
  {
    "label": "Cheri",
    "id": "cheri",
    "url": "/concepts/cheri.html"
  },
  {
    "label": "chevrotain",
    "id": "chevrotain",
    "url": "/concepts/chevrotain.html"
  },
  {
    "label": "chibicc",
    "id": "chibicc",
    "url": "/concepts/chibicc.html"
  },
  {
    "label": "chicken-lang",
    "id": "chicken-lang",
    "url": "/concepts/chicken-lang.html"
  },
  {
    "label": "CHICKEN",
    "id": "chicken",
    "url": "/concepts/chicken.html"
  },
  {
    "label": "Chicon",
    "id": "chicon",
    "url": "/concepts/chicon.html"
  },
  {
    "label": "Chika",
    "id": "chika",
    "url": "/concepts/chika.html"
  },
  {
    "label": "CHILL",
    "id": "chill",
    "url": "/concepts/chill.html"
  },
  {
    "label": "Chimera",
    "id": "chimera",
    "url": "/concepts/chimera.html"
  },
  {
    "label": "Chinese BASIC",
    "id": "chinese-basic",
    "url": "/concepts/chinese-basic.html"
  },
  {
    "label": "CHIP-8",
    "id": "chip-8",
    "url": "/concepts/chip-8.html"
  },
  {
    "label": "CHIP",
    "id": "chip-programming-language",
    "url": "/concepts/chip-programming-language.html"
  },
  {
    "label": "Chipmunk Basic",
    "id": "chipmunk-basic",
    "url": "/concepts/chipmunk-basic.html"
  },
  {
    "label": "chirp",
    "id": "chirp",
    "url": "/concepts/chirp.html"
  },
  {
    "label": "chisel",
    "id": "chisel",
    "url": "/concepts/chisel.html"
  },
  {
    "label": "chocolatey-pm",
    "id": "chocolatey-pm",
    "url": "/concepts/chocolatey-pm.html"
  },
  {
    "label": "Chomski",
    "id": "chomski",
    "url": "/concepts/chomski.html"
  },
  {
    "label": "Chrome",
    "id": "chrome-programming-language",
    "url": "/concepts/chrome-programming-language.html"
  },
  {
    "label": "Chronolog",
    "id": "chronolog",
    "url": "/concepts/chronolog.html"
  },
  {
    "label": "ChronologMC",
    "id": "chronologmc",
    "url": "/concepts/chronologmc.html"
  },
  {
    "label": "ChronologZ",
    "id": "chronologz",
    "url": "/concepts/chronologz.html"
  },
  {
    "label": "chrysaLisp",
    "id": "chrysalisp",
    "url": "/concepts/chrysalisp.html"
  },
  {
    "label": "Ch",
    "id": "chuck",
    "url": "/concepts/chuck.html"
  },
  {
    "label": "Ciao",
    "id": "ciao-programming-language",
    "url": "/concepts/ciao-programming-language.html"
  },
  {
    "label": "Ciel",
    "id": "ciel",
    "url": "/concepts/ciel.html"
  },
  {
    "label": "Crystallographic Information File",
    "id": "cif",
    "url": "/concepts/cif.html"
  },
  {
    "label": "Cigale",
    "id": "cigale",
    "url": "/concepts/cigale.html"
  },
  {
    "label": "CIL",
    "id": "cil",
    "url": "/concepts/cil.html"
  },
  {
    "label": "CIL",
    "id": "cilk",
    "url": "/concepts/cilk.html"
  },
  {
    "label": "cimfast",
    "id": "cimfast",
    "url": "/concepts/cimfast.html"
  },
  {
    "label": "CIMS PL/I",
    "id": "cims-pl-i",
    "url": "/concepts/cims-pl-i.html"
  },
  {
    "label": "CIR",
    "id": "cir",
    "url": "/concepts/cir.html"
  },
  {
    "label": "circa",
    "id": "circa",
    "url": "/concepts/circa.html"
  },
  {
    "label": "CIRCAL",
    "id": "circal",
    "url": "/concepts/circal.html"
  },
  {
    "label": "circle-lang",
    "id": "circle-lang",
    "url": "/concepts/circle-lang.html"
  },
  {
    "label": "Cirru",
    "id": "cirru",
    "url": "/concepts/cirru.html"
  },
  {
    "label": "Cish",
    "id": "cish",
    "url": "/concepts/cish.html"
  },
  {
    "label": "Ć",
    "id": "cito",
    "url": "/concepts/cito.html"
  },
  {
    "label": "Citrine",
    "id": "citrine",
    "url": "/concepts/citrine.html"
  },
  {
    "label": "cityhash-hash-function",
    "id": "cityhash-hash-function",
    "url": "/concepts/cityhash-hash-function.html"
  },
  {
    "label": "cixl",
    "id": "cixl",
    "url": "/concepts/cixl.html"
  },
  {
    "label": "CL-I",
    "id": "cl-i",
    "url": "/concepts/cl-i.html"
  },
  {
    "label": "CLAIRE",
    "id": "claire",
    "url": "/concepts/claire.html"
  },
  {
    "label": "Common Lisp with Arc Macros and Procedures",
    "id": "clamp",
    "url": "/concepts/clamp.html"
  },
  {
    "label": "CLANGER",
    "id": "clanger",
    "url": "/concepts/clanger.html"
  },
  {
    "label": "Clarion",
    "id": "clarion",
    "url": "/concepts/clarion.html"
  },
  {
    "label": "clarity",
    "id": "clarity",
    "url": "/concepts/clarity.html"
  },
  {
    "label": "Claro",
    "id": "claro",
    "url": "/concepts/claro.html"
  },
  {
    "label": "Clascal",
    "id": "clascal",
    "url": "/concepts/clascal.html"
  },
  {
    "label": "clash",
    "id": "clash",
    "url": "/concepts/clash.html"
  },
  {
    "label": "CLASS",
    "id": "class",
    "url": "/concepts/class.html"
  },
  {
    "label": "Classic-Ada",
    "id": "classic-ada",
    "url": "/concepts/classic-ada.html"
  },
  {
    "label": "ClassiC",
    "id": "classic",
    "url": "/concepts/classic.html"
  },
  {
    "label": "Clausal Language",
    "id": "clausal-lang",
    "url": "/concepts/clausal-lang.html"
  },
  {
    "label": "clay",
    "id": "clay",
    "url": "/concepts/clay.html"
  },
  {
    "label": "Clean",
    "id": "clean",
    "url": "/concepts/clean.html"
  },
  {
    "label": "cleanlang",
    "id": "cleanlang",
    "url": "/concepts/cleanlang.html"
  },
  {
    "label": "CLEAR",
    "id": "clear",
    "url": "/concepts/clear.html"
  },
  {
    "label": "Clear Language for Expressing Orders",
    "id": "cleo",
    "url": "/concepts/cleo.html"
  },
  {
    "label": "CLeogo",
    "id": "cleogo",
    "url": "/concepts/cleogo.html"
  },
  {
    "label": "CLEOPATRA",
    "id": "cleopatra",
    "url": "/concepts/cleopatra.html"
  },
  {
    "label": "Assembly CLI",
    "id": "cli-assembly",
    "url": "/concepts/cli-assembly.html"
  },
  {
    "label": "Click",
    "id": "click",
    "url": "/concepts/click.html"
  },
  {
    "label": "clickpath",
    "id": "clickpath",
    "url": "/concepts/clickpath.html"
  },
  {
    "label": "clike",
    "id": "clike",
    "url": "/concepts/clike.html"
  },
  {
    "label": "clion-editor",
    "id": "clion-editor",
    "url": "/concepts/clion-editor.html"
  },
  {
    "label": "Clipper",
    "id": "clipper",
    "url": "/concepts/clipper.html"
  },
  {
    "label": "CLIPS",
    "id": "clips",
    "url": "/concepts/clips.html"
  },
  {
    "label": "CLISP",
    "id": "clisp",
    "url": "/concepts/clisp.html"
  },
  {
    "label": "CLIST",
    "id": "clist",
    "url": "/concepts/clist.html"
  },
  {
    "label": "CLiX markup",
    "id": "clix",
    "url": "/concepts/clix.html"
  },
  {
    "label": "cloc",
    "id": "cloc",
    "url": "/concepts/cloc.html"
  },
  {
    "label": "cloe",
    "id": "cloe",
    "url": "/concepts/cloe.html"
  },
  {
    "label": "clojars-pm",
    "id": "clojars-pm",
    "url": "/concepts/clojars-pm.html"
  },
  {
    "label": "Clojure",
    "id": "clojure",
    "url": "/concepts/clojure.html"
  },
  {
    "label": "ClojureScript",
    "id": "clojurescript",
    "url": "/concepts/clojurescript.html"
  },
  {
    "label": "CLOS",
    "id": "clos",
    "url": "/concepts/clos.html"
  },
  {
    "label": "Closure Templates",
    "id": "closure-templates",
    "url": "/concepts/closure-templates.html"
  },
  {
    "label": "Cloud Firestore Security Rules",
    "id": "cloud-firestore-security-rules",
    "url": "/concepts/cloud-firestore-security-rules.html"
  },
  {
    "label": "CLOVER",
    "id": "clover",
    "url": "/concepts/clover.html"
  },
  {
    "label": "clox",
    "id": "clox",
    "url": "/concepts/clox.html"
  },
  {
    "label": "CLP*",
    "id": "clp-star",
    "url": "/concepts/clp-star.html"
  },
  {
    "label": "CLPR",
    "id": "clpr",
    "url": "/concepts/clpr.html"
  },
  {
    "label": "CLU",
    "id": "clu",
    "url": "/concepts/clu.html"
  },
  {
    "label": "CLX",
    "id": "clx",
    "url": "/concepts/clx.html"
  },
  {
    "label": "CMake",
    "id": "cmake",
    "url": "/concepts/cmake.html"
  },
  {
    "label": "CMIX",
    "id": "cmix",
    "url": "/concepts/cmix.html"
  },
  {
    "label": "CMN",
    "id": "cmn",
    "url": "/concepts/cmn.html"
  },
  {
    "label": "CMS-2",
    "id": "cms-2",
    "url": "/concepts/cms-2.html"
  },
  {
    "label": "EXEC",
    "id": "cms-exec",
    "url": "/concepts/cms-exec.html"
  },
  {
    "label": "CMS Pipelines",
    "id": "cms-pipelines",
    "url": "/concepts/cms-pipelines.html"
  },
  {
    "label": "CMU Common Lisp",
    "id": "cmu-common-lisp",
    "url": "/concepts/cmu-common-lisp.html"
  },
  {
    "label": "co-dfns",
    "id": "co-dfns",
    "url": "/concepts/co-dfns.html"
  },
  {
    "label": "co2",
    "id": "co2",
    "url": "/concepts/co2.html"
  },
  {
    "label": "COBLOC",
    "id": "cobloc",
    "url": "/concepts/cobloc.html"
  },
  {
    "label": "Cobol.NET",
    "id": "cobol-net",
    "url": "/concepts/cobol-net.html"
  },
  {
    "label": "COBOL",
    "id": "cobol",
    "url": "/concepts/cobol.html"
  },
  {
    "label": "CobolScript",
    "id": "cobolscript",
    "url": "/concepts/cobolscript.html"
  },
  {
    "label": "Cobra",
    "id": "cobra",
    "url": "/concepts/cobra.html"
  },
  {
    "label": "Coco/R",
    "id": "coco-r",
    "url": "/concepts/coco-r.html"
  },
  {
    "label": "Coco",
    "id": "coco",
    "url": "/concepts/coco.html"
  },
  {
    "label": "cocoapods-pm",
    "id": "cocoapods-pm",
    "url": "/concepts/cocoapods-pm.html"
  },
  {
    "label": "Coconut",
    "id": "coconut",
    "url": "/concepts/coconut.html"
  },
  {
    "label": "Coda web development software",
    "id": "coda-editor",
    "url": "/concepts/coda-editor.html"
  },
  {
    "label": "code-blocks-editor",
    "id": "code-blocks-editor",
    "url": "/concepts/code-blocks-editor.html"
  },
  {
    "label": "codecept",
    "id": "codecept",
    "url": "/concepts/codecept.html"
  },
  {
    "label": "codeflow",
    "id": "codeflow",
    "url": "/concepts/codeflow.html"
  },
  {
    "label": "CodeGear Delphi",
    "id": "codegear-delphi",
    "url": "/concepts/codegear-delphi.html"
  },
  {
    "label": "codelite-editor",
    "id": "codelite-editor",
    "url": "/concepts/codelite-editor.html"
  },
  {
    "label": "CodeMirror",
    "id": "codemirror",
    "url": "/concepts/codemirror.html"
  },
  {
    "label": "CodeQL",
    "id": "codeql",
    "url": "/concepts/codeql.html"
  },
  {
    "label": "CODIL",
    "id": "codil",
    "url": "/concepts/codil.html"
  },
  {
    "label": "Common Object File Format",
    "id": "coff",
    "url": "/concepts/coff.html"
  },
  {
    "label": "COFFEE Cinema 4D",
    "id": "coffee-cinema-4d",
    "url": "/concepts/coffee-cinema-4d.html"
  },
  {
    "label": "coffeepp",
    "id": "coffeepp",
    "url": "/concepts/coffeepp.html"
  },
  {
    "label": "CoffeeScript",
    "id": "coffeescript",
    "url": "/concepts/coffeescript.html"
  },
  {
    "label": "CogMap",
    "id": "cogmap",
    "url": "/concepts/cogmap.html"
  },
  {
    "label": "COGO",
    "id": "cogo",
    "url": "/concepts/cogo.html"
  },
  {
    "label": "coherence",
    "id": "coherence",
    "url": "/concepts/coherence.html"
  },
  {
    "label": "Coherent Parallel C",
    "id": "coherent-parallel-c",
    "url": "/concepts/coherent-parallel-c.html"
  },
  {
    "label": "coi-protocol",
    "id": "coi-protocol",
    "url": "/concepts/coi-protocol.html"
  },
  {
    "label": "CokeScript",
    "id": "cokescript",
    "url": "/concepts/cokescript.html"
  },
  {
    "label": "COL",
    "id": "col",
    "url": "/concepts/col.html"
  },
  {
    "label": "ColaScript",
    "id": "colascript",
    "url": "/concepts/colascript.html"
  },
  {
    "label": "COLASL",
    "id": "colasl",
    "url": "/concepts/colasl.html"
  },
  {
    "label": "COLD-K",
    "id": "cold-k",
    "url": "/concepts/cold-k.html"
  },
  {
    "label": "ColdFusion Components",
    "id": "coldfusion-components",
    "url": "/concepts/coldfusion-components.html"
  },
  {
    "label": "ColdFusion",
    "id": "coldfusion",
    "url": "/concepts/coldfusion.html"
  },
  {
    "label": "COLLADA",
    "id": "collada",
    "url": "/concepts/collada.html"
  },
  {
    "label": "Color BASIC",
    "id": "color-basic",
    "url": "/concepts/color-basic.html"
  },
  {
    "label": "ColorForth",
    "id": "colorforth",
    "url": "/concepts/colorforth.html"
  },
  {
    "label": "COMAL",
    "id": "comal",
    "url": "/concepts/comal.html"
  },
  {
    "label": "Combined Log Format",
    "id": "combined-log-format",
    "url": "/concepts/combined-log-format.html"
  },
  {
    "label": "comby",
    "id": "comby",
    "url": "/concepts/comby.html"
  },
  {
    "label": "COMFY",
    "id": "comfy",
    "url": "/concepts/comfy.html"
  },
  {
    "label": "COMIT",
    "id": "comit",
    "url": "/concepts/comit.html"
  },
  {
    "label": "comm",
    "id": "comm",
    "url": "/concepts/comm.html"
  },
  {
    "label": "COMMEN",
    "id": "commen",
    "url": "/concepts/commen.html"
  },
  {
    "label": "Commodore BASIC",
    "id": "commodore-basic",
    "url": "/concepts/commodore-basic.html"
  },
  {
    "label": "Common Lisp",
    "id": "common-lisp",
    "url": "/concepts/common-lisp.html"
  },
  {
    "label": "Common Log Format",
    "id": "common-log-format",
    "url": "/concepts/common-log-format.html"
  },
  {
    "label": "CWL",
    "id": "common-workflow-language",
    "url": "/concepts/common-workflow-language.html"
  },
  {
    "label": "CommonLoops",
    "id": "commonloops",
    "url": "/concepts/commonloops.html"
  },
  {
    "label": "commonmark",
    "id": "commonmark",
    "url": "/concepts/commonmark.html"
  },
  {
    "label": "Compact Application Solution Language",
    "id": "compact-application-solution-language",
    "url": "/concepts/compact-application-solution-language.html"
  },
  {
    "label": "Compiler-Compiler",
    "id": "compiler-compiler",
    "url": "/concepts/compiler-compiler.html"
  },
  {
    "label": "Complex-Prolog",
    "id": "complex-prolog",
    "url": "/concepts/complex-prolog.html"
  },
  {
    "label": "COMPONENT PASCAL",
    "id": "component-pascal",
    "url": "/concepts/component-pascal.html"
  },
  {
    "label": "Computer Compiler",
    "id": "computer-compiler",
    "url": "/concepts/computer-compiler.html"
  },
  {
    "label": "COMPUTEST",
    "id": "computest",
    "url": "/concepts/computest.html"
  },
  {
    "label": "COMSKEE",
    "id": "comskee",
    "url": "/concepts/comskee.html"
  },
  {
    "label": "COMSL",
    "id": "comsl",
    "url": "/concepts/comsl.html"
  },
  {
    "label": "COMSOL Script",
    "id": "comsol-script",
    "url": "/concepts/comsol-script.html"
  },
  {
    "label": "COMTRAN",
    "id": "comtran",
    "url": "/concepts/comtran.html"
  },
  {
    "label": "CONA",
    "id": "cona",
    "url": "/concepts/cona.html"
  },
  {
    "label": "Conan Center",
    "id": "conan-center-pm",
    "url": "/concepts/conan-center-pm.html"
  },
  {
    "label": "Conan",
    "id": "conan-pm",
    "url": "/concepts/conan-pm.html"
  },
  {
    "label": "ConC",
    "id": "conc",
    "url": "/concepts/conc.html"
  },
  {
    "label": "concept-script",
    "id": "concept-script",
    "url": "/concepts/concept-script.html"
  },
  {
    "label": "Conceptual",
    "id": "conceptual",
    "url": "/concepts/conceptual.html"
  },
  {
    "label": "Concert/C",
    "id": "concert-c",
    "url": "/concepts/concert-c.html"
  },
  {
    "label": "Concise Encoding",
    "id": "concise-encoding",
    "url": "/concepts/concise-encoding.html"
  },
  {
    "label": "concordance",
    "id": "concordance",
    "url": "/concepts/concordance.html"
  },
  {
    "label": "CONCUR",
    "id": "concur",
    "url": "/concepts/concur.html"
  },
  {
    "label": "concurnas",
    "id": "concurnas",
    "url": "/concepts/concurnas.html"
  },
  {
    "label": "ConCurr",
    "id": "concurr",
    "url": "/concepts/concurr.html"
  },
  {
    "label": "Concurrent C++",
    "id": "concurrent-cpp",
    "url": "/concepts/concurrent-cpp.html"
  },
  {
    "label": "Concurrent METATEM",
    "id": "concurrent-metatem",
    "url": "/concepts/concurrent-metatem.html"
  },
  {
    "label": "Concurrent ML",
    "id": "concurrent-ml",
    "url": "/concepts/concurrent-ml.html"
  },
  {
    "label": "Concurrent Pascal",
    "id": "concurrent-pascal",
    "url": "/concepts/concurrent-pascal.html"
  },
  {
    "label": "Concurrent Prolog",
    "id": "concurrent-prolog",
    "url": "/concepts/concurrent-prolog.html"
  },
  {
    "label": "Cone",
    "id": "cone",
    "url": "/concepts/cone.html"
  },
  {
    "label": "Confluence",
    "id": "confluence",
    "url": "/concepts/confluence.html"
  },
  {
    "label": "conGolog",
    "id": "congolog",
    "url": "/concepts/congolog.html"
  },
  {
    "label": "CONLAN",
    "id": "conlan",
    "url": "/concepts/conlan.html"
  },
  {
    "label": "CoNLL-U",
    "id": "conll-u",
    "url": "/concepts/conll-u.html"
  },
  {
    "label": "ConMan",
    "id": "conman",
    "url": "/concepts/conman.html"
  },
  {
    "label": "Connection Machine LISP",
    "id": "connection-machine-lisp",
    "url": "/concepts/connection-machine-lisp.html"
  },
  {
    "label": "Connection Machine",
    "id": "connection-machine",
    "url": "/concepts/connection-machine.html"
  },
  {
    "label": "CONNIVER",
    "id": "conniver",
    "url": "/concepts/conniver.html"
  },
  {
    "label": "CONSIM",
    "id": "consim",
    "url": "/concepts/consim.html"
  },
  {
    "label": "ConstraintLisp",
    "id": "constraintlisp",
    "url": "/concepts/constraintlisp.html"
  },
  {
    "label": "CONSTRAINTS",
    "id": "constraints",
    "url": "/concepts/constraints.html"
  },
  {
    "label": "Consul",
    "id": "consul",
    "url": "/concepts/consul.html"
  },
  {
    "label": "Context Diff",
    "id": "context-diff",
    "url": "/concepts/context-diff.html"
  },
  {
    "label": "contracts.coffee",
    "id": "contracts.coffee",
    "url": "/concepts/contracts.coffee.html"
  },
  {
    "label": "CONTRANS",
    "id": "contrans",
    "url": "/concepts/contrans.html"
  },
  {
    "label": "converge",
    "id": "converge",
    "url": "/concepts/converge.html"
  },
  {
    "label": "CONVERT",
    "id": "convert",
    "url": "/concepts/convert.html"
  },
  {
    "label": "cooC",
    "id": "cooc",
    "url": "/concepts/cooc.html"
  },
  {
    "label": "Classroom Object Oriented Language",
    "id": "cool",
    "url": "/concepts/cool.html"
  },
  {
    "label": "Matrix Market Coordinate Format",
    "id": "coordinate-format",
    "url": "/concepts/coordinate-format.html"
  },
  {
    "label": "COPAS",
    "id": "copas",
    "url": "/concepts/copas.html"
  },
  {
    "label": "COPE",
    "id": "cope",
    "url": "/concepts/cope.html"
  },
  {
    "label": "Copilot",
    "id": "copilot",
    "url": "/concepts/copilot.html"
  },
  {
    "label": "Coq",
    "id": "coq",
    "url": "/concepts/coq.html"
  },
  {
    "label": "cor",
    "id": "cor",
    "url": "/concepts/cor.html"
  },
  {
    "label": "CORAL 64",
    "id": "coral-64",
    "url": "/concepts/coral-64.html"
  },
  {
    "label": "Coral",
    "id": "coral-lang",
    "url": "/concepts/coral-lang.html"
  },
  {
    "label": "CORAL",
    "id": "coral",
    "url": "/concepts/coral.html"
  },
  {
    "label": "Coral++",
    "id": "coralpp",
    "url": "/concepts/coralpp.html"
  },
  {
    "label": "CorbaScript",
    "id": "corbascript",
    "url": "/concepts/corbascript.html"
  },
  {
    "label": "CORC",
    "id": "corc",
    "url": "/concepts/corc.html"
  },
  {
    "label": "CorelScript",
    "id": "corelscript",
    "url": "/concepts/corelscript.html"
  },
  {
    "label": "corescript",
    "id": "corescript",
    "url": "/concepts/corescript.html"
  },
  {
    "label": "Corman Common Lisp",
    "id": "corman-common-lisp",
    "url": "/concepts/corman-common-lisp.html"
  },
  {
    "label": "Cornell University Programming Language",
    "id": "cornell-university-programming-language",
    "url": "/concepts/cornell-university-programming-language.html"
  },
  {
    "label": "CorVision",
    "id": "corvision",
    "url": "/concepts/corvision.html"
  },
  {
    "label": "cosh",
    "id": "cosh",
    "url": "/concepts/cosh.html"
  },
  {
    "label": "CosmicOS",
    "id": "cosmicos",
    "url": "/concepts/cosmicos.html"
  },
  {
    "label": "COSMO",
    "id": "cosmo",
    "url": "/concepts/cosmo.html"
  },
  {
    "label": "Cosmos",
    "id": "cosmos",
    "url": "/concepts/cosmos.html"
  },
  {
    "label": "Cotton",
    "id": "cotton",
    "url": "/concepts/cotton.html"
  },
  {
    "label": "Couchbase Mobile",
    "id": "couchbase-mobile",
    "url": "/concepts/couchbase-mobile.html"
  },
  {
    "label": "Couchbase",
    "id": "couchbase",
    "url": "/concepts/couchbase.html"
  },
  {
    "label": "CouchDB",
    "id": "couchdb",
    "url": "/concepts/couchdb.html"
  },
  {
    "label": "Coulomb's Equation",
    "id": "coulombs-equation",
    "url": "/concepts/coulombs-equation.html"
  },
  {
    "label": "COWSEL",
    "id": "cowsel",
    "url": "/concepts/cowsel.html"
  },
  {
    "label": "CP",
    "id": "cp",
    "url": "/concepts/cp.html"
  },
  {
    "label": "cpan-pm",
    "id": "cpan-pm",
    "url": "/concepts/cpan-pm.html"
  },
  {
    "label": "cperl",
    "id": "cperl",
    "url": "/concepts/cperl.html"
  },
  {
    "label": "CPL",
    "id": "cpl",
    "url": "/concepts/cpl.html"
  },
  {
    "label": "C++",
    "id": "cpp",
    "url": "/concepts/cpp.html"
  },
  {
    "label": "cql",
    "id": "cql",
    "url": "/concepts/cql.html"
  },
  {
    "label": "CQLF",
    "id": "cqlf",
    "url": "/concepts/cqlf.html"
  },
  {
    "label": "CQL++",
    "id": "cqlpp",
    "url": "/concepts/cqlpp.html"
  },
  {
    "label": "crack",
    "id": "crack",
    "url": "/concepts/crack.html"
  },
  {
    "label": "CRAM file format",
    "id": "cram-format",
    "url": "/concepts/cram-format.html"
  },
  {
    "label": "cran-pm",
    "id": "cran-pm",
    "url": "/concepts/cran-pm.html"
  },
  {
    "label": "Cranelift",
    "id": "cranelift-ir",
    "url": "/concepts/cranelift-ir.html"
  },
  {
    "label": "crates-pm",
    "id": "crates-pm",
    "url": "/concepts/crates-pm.html"
  },
  {
    "label": "Creative Basic",
    "id": "creative-basic",
    "url": "/concepts/creative-basic.html"
  },
  {
    "label": "Crema",
    "id": "crema",
    "url": "/concepts/crema.html"
  },
  {
    "label": "Creole",
    "id": "creole",
    "url": "/concepts/creole.html"
  },
  {
    "label": "crmsh",
    "id": "crmsh",
    "url": "/concepts/crmsh.html"
  },
  {
    "label": "Croc",
    "id": "croc",
    "url": "/concepts/croc.html"
  },
  {
    "label": "Croma",
    "id": "croma",
    "url": "/concepts/croma.html"
  },
  {
    "label": "crush",
    "id": "crush",
    "url": "/concepts/crush.html"
  },
  {
    "label": "Cryptol",
    "id": "cryptol",
    "url": "/concepts/cryptol.html"
  },
  {
    "label": "Crystal",
    "id": "crystal",
    "url": "/concepts/crystal.html"
  },
  {
    "label": "CS-Script",
    "id": "cs-script",
    "url": "/concepts/cs-script.html"
  },
  {
    "label": "CodeStudAssembler",
    "id": "csa",
    "url": "/concepts/csa.html"
  },
  {
    "label": "C#",
    "id": "csharp",
    "url": "/concepts/csharp.html"
  },
  {
    "label": "CSL",
    "id": "csl",
    "url": "/concepts/csl.html"
  },
  {
    "label": "CSMP",
    "id": "csmp",
    "url": "/concepts/csmp.html"
  },
  {
    "label": "CSON",
    "id": "cson",
    "url": "/concepts/cson.html"
  },
  {
    "label": "Csound",
    "id": "csound",
    "url": "/concepts/csound.html"
  },
  {
    "label": "CSP-OZ-DC",
    "id": "csp-oz-dc",
    "url": "/concepts/csp-oz-dc.html"
  },
  {
    "label": "CSP-OZ",
    "id": "csp-oz",
    "url": "/concepts/csp-oz.html"
  },
  {
    "label": "CSP",
    "id": "csp",
    "url": "/concepts/csp.html"
  },
  {
    "label": "CSpydr",
    "id": "cspydr",
    "url": "/concepts/cspydr.html"
  },
  {
    "label": "CSS Doodle",
    "id": "css-doodle",
    "url": "/concepts/css-doodle.html"
  },
  {
    "label": "CSS",
    "id": "css",
    "url": "/concepts/css.html"
  },
  {
    "label": "CSSA",
    "id": "cssa",
    "url": "/concepts/cssa.html"
  },
  {
    "label": "CST",
    "id": "cst",
    "url": "/concepts/cst.html"
  },
  {
    "label": "CSV",
    "id": "csv",
    "url": "/concepts/csv.html"
  },
  {
    "label": "CSV++",
    "id": "csvpp",
    "url": "/concepts/csvpp.html"
  },
  {
    "label": "CSVw",
    "id": "csvw",
    "url": "/concepts/csvw.html"
  },
  {
    "label": "cT",
    "id": "ct",
    "url": "/concepts/ct.html"
  },
  {
    "label": "ctalk-lang",
    "id": "ctalk-lang",
    "url": "/concepts/ctalk-lang.html"
  },
  {
    "label": "ctalk",
    "id": "ctalk",
    "url": "/concepts/ctalk.html"
  },
  {
    "label": "ctan-pm",
    "id": "ctan-pm",
    "url": "/concepts/ctan-pm.html"
  },
  {
    "label": "ctr",
    "id": "ctr",
    "url": "/concepts/ctr.html"
  },
  {
    "label": "Steinberg Cubase",
    "id": "cubase",
    "url": "/concepts/cubase.html"
  },
  {
    "label": "CUBE",
    "id": "cube",
    "url": "/concepts/cube.html"
  },
  {
    "label": "CUDA",
    "id": "cuda",
    "url": "/concepts/cuda.html"
  },
  {
    "label": "CueCat",
    "id": "cuecat",
    "url": "/concepts/cuecat.html"
  },
  {
    "label": "Cue",
    "id": "cuelang",
    "url": "/concepts/cuelang.html"
  },
  {
    "label": "Culler-Fried System",
    "id": "culler-fried-system",
    "url": "/concepts/culler-fried-system.html"
  },
  {
    "label": "Cullinet",
    "id": "cullinet",
    "url": "/concepts/cullinet.html"
  },
  {
    "label": "cuneiform",
    "id": "cuneiform",
    "url": "/concepts/cuneiform.html"
  },
  {
    "label": "CUPID",
    "id": "cupid",
    "url": "/concepts/cupid.html"
  },
  {
    "label": "CuPit-2",
    "id": "cupit-2",
    "url": "/concepts/cupit-2.html"
  },
  {
    "label": "Curl",
    "id": "curl",
    "url": "/concepts/curl.html"
  },
  {
    "label": "Curly",
    "id": "curly",
    "url": "/concepts/curly.html"
  },
  {
    "label": "Curry",
    "id": "curry",
    "url": "/concepts/curry.html"
  },
  {
    "label": "curv",
    "id": "curv",
    "url": "/concepts/curv.html"
  },
  {
    "label": "cuscus",
    "id": "cuscus",
    "url": "/concepts/cuscus.html"
  },
  {
    "label": "Committee on Uniform Security Identification Procedures",
    "id": "cusip",
    "url": "/concepts/cusip.html"
  },
  {
    "label": "CVL",
    "id": "cvl",
    "url": "/concepts/cvl.html"
  },
  {
    "label": "CWEB",
    "id": "cweb",
    "url": "/concepts/cweb.html"
  },
  {
    "label": "cx",
    "id": "cx",
    "url": "/concepts/cx.html"
  },
  {
    "label": "Cyber",
    "id": "cyber",
    "url": "/concepts/cyber.html"
  },
  {
    "label": "CYBIL",
    "id": "cybil",
    "url": "/concepts/cybil.html"
  },
  {
    "label": "CYCL",
    "id": "cycl",
    "url": "/concepts/cycl.html"
  },
  {
    "label": "Cyclone",
    "id": "cyclone",
    "url": "/concepts/cyclone.html"
  },
  {
    "label": "Cycript",
    "id": "cycript",
    "url": "/concepts/cycript.html"
  },
  {
    "label": "Cymbal",
    "id": "cymbal",
    "url": "/concepts/cymbal.html"
  },
  {
    "label": "Cypher Query Language",
    "id": "cypher",
    "url": "/concepts/cypher.html"
  },
  {
    "label": "CypherText",
    "id": "cyphertext",
    "url": "/concepts/cyphertext.html"
  },
  {
    "label": "Cython",
    "id": "cython",
    "url": "/concepts/cython.html"
  },
  {
    "label": "cytosol",
    "id": "cytosol",
    "url": "/concepts/cytosol.html"
  },
  {
    "label": "D data language specification",
    "id": "d-data-language-specification",
    "url": "/concepts/d-data-language-specification.html"
  },
  {
    "label": "D",
    "id": "d",
    "url": "/concepts/d.html"
  },
  {
    "label": "D2",
    "id": "d2",
    "url": "/concepts/d2.html"
  },
  {
    "label": "D3.js",
    "id": "d3",
    "url": "/concepts/d3.html"
  },
  {
    "label": "D4",
    "id": "d4-programming-language",
    "url": "/concepts/d4-programming-language.html"
  },
  {
    "label": "D4",
    "id": "d4",
    "url": "/concepts/d4.html"
  },
  {
    "label": "DAD",
    "id": "dad",
    "url": "/concepts/dad.html"
  },
  {
    "label": "Dafny",
    "id": "dafny",
    "url": "/concepts/dafny.html"
  },
  {
    "label": "DAG",
    "id": "dag",
    "url": "/concepts/dag.html"
  },
  {
    "label": "Daisy Systems",
    "id": "daisy-systems",
    "url": "/concepts/daisy-systems.html"
  },
  {
    "label": "Dak",
    "id": "dak",
    "url": "/concepts/dak.html"
  },
  {
    "label": "Dale",
    "id": "dale",
    "url": "/concepts/dale.html"
  },
  {
    "label": "dalvik-bytecode",
    "id": "dalvik-bytecode",
    "url": "/concepts/dalvik-bytecode.html"
  },
  {
    "label": "DAML+OIL",
    "id": "daml-oil",
    "url": "/concepts/daml-oil.html"
  },
  {
    "label": "DARPA Agent Markup Language",
    "id": "daml",
    "url": "/concepts/daml.html"
  },
  {
    "label": "DAMN",
    "id": "damn",
    "url": "/concepts/damn.html"
  },
  {
    "label": "daonode",
    "id": "daonode",
    "url": "/concepts/daonode.html"
  },
  {
    "label": "DAP-Algol",
    "id": "dap-algol",
    "url": "/concepts/dap-algol.html"
  },
  {
    "label": "DAP FORTRAN",
    "id": "dap-fortran",
    "url": "/concepts/dap-fortran.html"
  },
  {
    "label": "Daplex",
    "id": "daplex",
    "url": "/concepts/daplex.html"
  },
  {
    "label": "Darcs Advanced Revision Control System",
    "id": "darcs-patch",
    "url": "/concepts/darcs-patch.html"
  },
  {
    "label": "DarkBASIC",
    "id": "darkbasic",
    "url": "/concepts/darkbasic.html"
  },
  {
    "label": "darklang",
    "id": "darklang",
    "url": "/concepts/darklang.html"
  },
  {
    "label": "dart-pm",
    "id": "dart-pm",
    "url": "/concepts/dart-pm.html"
  },
  {
    "label": "Dart",
    "id": "dart",
    "url": "/concepts/dart.html"
  },
  {
    "label": "DartCVL",
    "id": "dartcvl",
    "url": "/concepts/dartcvl.html"
  },
  {
    "label": "Dartmouth BASIC",
    "id": "dartmouth-basic",
    "url": "/concepts/dartmouth-basic.html"
  },
  {
    "label": "DAS",
    "id": "das",
    "url": "/concepts/das.html"
  },
  {
    "label": "Dashrep",
    "id": "dashrep",
    "url": "/concepts/dashrep.html"
  },
  {
    "label": "Distributed Application Specification Language",
    "id": "dasl",
    "url": "/concepts/dasl.html"
  },
  {
    "label": "Dasm",
    "id": "dasm",
    "url": "/concepts/dasm.html"
  },
  {
    "label": "dat-protocol",
    "id": "dat-protocol",
    "url": "/concepts/dat-protocol.html"
  },
  {
    "label": "Data Access Language",
    "id": "data-access-language",
    "url": "/concepts/data-access-language.html"
  },
  {
    "label": "Data General Business Basic",
    "id": "data-general-business-basic",
    "url": "/concepts/data-general-business-basic.html"
  },
  {
    "label": "DATA-TEXT",
    "id": "data-text",
    "url": "/concepts/data-text.html"
  },
  {
    "label": "DATABUS",
    "id": "databus",
    "url": "/concepts/databus.html"
  },
  {
    "label": "Dataflex",
    "id": "dataflex",
    "url": "/concepts/dataflex.html"
  },
  {
    "label": "datafun",
    "id": "datafun",
    "url": "/concepts/datafun.html"
  },
  {
    "label": "Datalisp",
    "id": "datalisp",
    "url": "/concepts/datalisp.html"
  },
  {
    "label": "Datalog",
    "id": "datalog",
    "url": "/concepts/datalog.html"
  },
  {
    "label": "DATAN",
    "id": "datan",
    "url": "/concepts/datan.html"
  },
  {
    "label": "Data Package",
    "id": "datapackage",
    "url": "/concepts/datapackage.html"
  },
  {
    "label": "Datapoint's Advanced Systems Language",
    "id": "datapoint-dasl",
    "url": "/concepts/datapoint-dasl.html"
  },
  {
    "label": "datascript",
    "id": "datascript",
    "url": "/concepts/datascript.html"
  },
  {
    "label": "DATATRIEVE",
    "id": "datatrieve",
    "url": "/concepts/datatrieve.html"
  },
  {
    "label": "DataWeave",
    "id": "dataweave",
    "url": "/concepts/dataweave.html"
  },
  {
    "label": "datev",
    "id": "datev",
    "url": "/concepts/datev.html"
  },
  {
    "label": "Datomic",
    "id": "datomic",
    "url": "/concepts/datomic.html"
  },
  {
    "label": "DAX",
    "id": "dax",
    "url": "/concepts/dax.html"
  },
  {
    "label": "DBase",
    "id": "dbase",
    "url": "/concepts/dbase.html"
  },
  {
    "label": "dbml",
    "id": "dbml",
    "url": "/concepts/dbml.html"
  },
  {
    "label": "Dc",
    "id": "dc",
    "url": "/concepts/dc.html"
  },
  {
    "label": "Data Communications ALGOL",
    "id": "dcalgol",
    "url": "/concepts/dcalgol.html"
  },
  {
    "label": "Data Catalog Vocabulary",
    "id": "dcat",
    "url": "/concepts/dcat.html"
  },
  {
    "label": "DDA",
    "id": "dda",
    "url": "/concepts/dda.html"
  },
  {
    "label": "DDF",
    "id": "ddfcsv",
    "url": "/concepts/ddfcsv.html"
  },
  {
    "label": "ddfql",
    "id": "ddfql",
    "url": "/concepts/ddfql.html"
  },
  {
    "label": "DDML",
    "id": "ddml",
    "url": "/concepts/ddml.html"
  },
  {
    "label": "De Bruijn index",
    "id": "de-bruijn-index-notation",
    "url": "/concepts/de-bruijn-index-notation.html"
  },
  {
    "label": "DEACON",
    "id": "deacon",
    "url": "/concepts/deacon.html"
  },
  {
    "label": "Deb file format",
    "id": "deb",
    "url": "/concepts/deb.html"
  },
  {
    "label": "DEBL",
    "id": "debl",
    "url": "/concepts/debl.html"
  },
  {
    "label": "DeBuMa",
    "id": "debuma",
    "url": "/concepts/debuma.html"
  },
  {
    "label": "dec64",
    "id": "dec64",
    "url": "/concepts/dec64.html"
  },
  {
    "label": "Decision Model & Notation",
    "id": "decision-model-notation",
    "url": "/concepts/decision-model-notation.html"
  },
  {
    "label": "DECLARE",
    "id": "declare",
    "url": "/concepts/declare.html"
  },
  {
    "label": "dedukti",
    "id": "dedukti",
    "url": "/concepts/dedukti.html"
  },
  {
    "label": "Deesel",
    "id": "deesel",
    "url": "/concepts/deesel.html"
  },
  {
    "label": "Definite clause grammar",
    "id": "definite-clause-grammar-notation",
    "url": "/concepts/definite-clause-grammar-notation.html"
  },
  {
    "label": "DEL",
    "id": "del",
    "url": "/concepts/del.html"
  },
  {
    "label": "Delirium",
    "id": "delirium",
    "url": "/concepts/delirium.html"
  },
  {
    "label": "Delphi",
    "id": "delphi",
    "url": "/concepts/delphi.html"
  },
  {
    "label": "Delta Prolog",
    "id": "delta-prolog",
    "url": "/concepts/delta-prolog.html"
  },
  {
    "label": "DEM",
    "id": "dem",
    "url": "/concepts/dem.html"
  },
  {
    "label": "DEMETER",
    "id": "demeter",
    "url": "/concepts/demeter.html"
  },
  {
    "label": "DEMOS",
    "id": "demos",
    "url": "/concepts/demos.html"
  },
  {
    "label": "Dendral",
    "id": "dendral",
    "url": "/concepts/dendral.html"
  },
  {
    "label": "Deno",
    "id": "deno",
    "url": "/concepts/deno.html"
  },
  {
    "label": "DML",
    "id": "dependent-ml",
    "url": "/concepts/dependent-ml.html"
  },
  {
    "label": "Dern",
    "id": "dern",
    "url": "/concepts/dern.html"
  },
  {
    "label": "Descartes",
    "id": "descartes",
    "url": "/concepts/descartes.html"
  },
  {
    "label": "Descript",
    "id": "descript",
    "url": "/concepts/descript.html"
  },
  {
    "label": "DESCRIPTRAN",
    "id": "descriptran",
    "url": "/concepts/descriptran.html"
  },
  {
    "label": "desktop",
    "id": "desktop",
    "url": "/concepts/desktop.html"
  },
  {
    "label": "Desmos",
    "id": "desmos",
    "url": "/concepts/desmos.html"
  },
  {
    "label": "DETAB/65",
    "id": "detab-65",
    "url": "/concepts/detab-65.html"
  },
  {
    "label": "DETAB-X",
    "id": "detab-x",
    "url": "/concepts/detab-x.html"
  },
  {
    "label": "DETAP",
    "id": "detap",
    "url": "/concepts/detap.html"
  },
  {
    "label": "Deva",
    "id": "deva",
    "url": "/concepts/deva.html"
  },
  {
    "label": "Device independent file format",
    "id": "device-independent-file-format",
    "url": "/concepts/device-independent-file-format.html"
  },
  {
    "label": "Devicetree",
    "id": "devicetree",
    "url": "/concepts/devicetree.html"
  },
  {
    "label": "DEVIL",
    "id": "devil",
    "url": "/concepts/devil.html"
  },
  {
    "label": "dex",
    "id": "dex",
    "url": "/concepts/dex.html"
  },
  {
    "label": "Dexterity",
    "id": "dexterity",
    "url": "/concepts/dexterity.html"
  },
  {
    "label": "dexvis",
    "id": "dexvis",
    "url": "/concepts/dexvis.html"
  },
  {
    "label": "DFL",
    "id": "dfl",
    "url": "/concepts/dfl.html"
  },
  {
    "label": "dfns",
    "id": "dfns",
    "url": "/concepts/dfns.html"
  },
  {
    "label": "dgraph",
    "id": "dgraph",
    "url": "/concepts/dgraph.html"
  },
  {
    "label": "Dhall",
    "id": "dhall",
    "url": "/concepts/dhall.html"
  },
  {
    "label": "DIAGRAM",
    "id": "diagram",
    "url": "/concepts/diagram.html"
  },
  {
    "label": "DIALOG",
    "id": "dialog",
    "url": "/concepts/dialog.html"
  },
  {
    "label": "DIAMAG",
    "id": "diamag",
    "url": "/concepts/diamag.html"
  },
  {
    "label": "DIANA",
    "id": "diana",
    "url": "/concepts/diana.html"
  },
  {
    "label": "Digital Interactive Business Oriented Language",
    "id": "dibol",
    "url": "/concepts/dibol.html"
  },
  {
    "label": "DICE",
    "id": "dice",
    "url": "/concepts/dice.html"
  },
  {
    "label": "DIET",
    "id": "diet",
    "url": "/concepts/diet.html"
  },
  {
    "label": "Diff",
    "id": "diff",
    "url": "/concepts/diff.html"
  },
  {
    "label": "Differential Datalog",
    "id": "differential-datalog",
    "url": "/concepts/differential-datalog.html"
  },
  {
    "label": "DIGITAL Command Language",
    "id": "digital-command-language",
    "url": "/concepts/digital-command-language.html"
  },
  {
    "label": "DIGRAF",
    "id": "digraf",
    "url": "/concepts/digraf.html"
  },
  {
    "label": "Dink Smallwood",
    "id": "dinkc",
    "url": "/concepts/dinkc.html"
  },
  {
    "label": "DinnerBell",
    "id": "dinnerbell",
    "url": "/concepts/dinnerbell.html"
  },
  {
    "label": "DINO",
    "id": "dino",
    "url": "/concepts/dino.html"
  },
  {
    "label": "dio",
    "id": "dio",
    "url": "/concepts/dio.html"
  },
  {
    "label": "Dipe-R",
    "id": "dipe-r",
    "url": "/concepts/dipe-r.html"
  },
  {
    "label": "Diplans",
    "id": "diplans",
    "url": "/concepts/diplans.html"
  },
  {
    "label": "DISC",
    "id": "disc",
    "url": "/concepts/disc.html"
  },
  {
    "label": "DISPEL",
    "id": "dispel",
    "url": "/concepts/dispel.html"
  },
  {
    "label": "DisplayPort",
    "id": "displayport-standard",
    "url": "/concepts/displayport-standard.html"
  },
  {
    "label": "Distributed Processes",
    "id": "distributed-processes",
    "url": "/concepts/distributed-processes.html"
  },
  {
    "label": "Distributed Smalltalk",
    "id": "distributed-smalltalk",
    "url": "/concepts/distributed-smalltalk.html"
  },
  {
    "label": "DITRAN",
    "id": "ditran",
    "url": "/concepts/ditran.html"
  },
  {
    "label": "DITROFF/FFORTID",
    "id": "ditroff-ffortid",
    "url": "/concepts/ditroff-ffortid.html"
  },
  {
    "label": "DITROFF",
    "id": "ditroff",
    "url": "/concepts/ditroff.html"
  },
  {
    "label": "Dixy",
    "id": "dixy",
    "url": "/concepts/dixy.html"
  },
  {
    "label": "Django",
    "id": "django",
    "url": "/concepts/django.html"
  },
  {
    "label": "djangoql",
    "id": "djangoql",
    "url": "/concepts/djangoql.html"
  },
  {
    "label": "Djot",
    "id": "djot",
    "url": "/concepts/djot.html"
  },
  {
    "label": "DomainKeys Identified Mail",
    "id": "dkim-standard",
    "url": "/concepts/dkim-standard.html"
  },
  {
    "label": "dllup",
    "id": "dllup",
    "url": "/concepts/dllup.html"
  },
  {
    "label": "DLP",
    "id": "dlp",
    "url": "/concepts/dlp.html"
  },
  {
    "label": "dlvm",
    "id": "dlvm",
    "url": "/concepts/dlvm.html"
  },
  {
    "label": "DM-1",
    "id": "dm-1",
    "url": "/concepts/dm-1.html"
  },
  {
    "label": "DM",
    "id": "dm",
    "url": "/concepts/dm.html"
  },
  {
    "label": "DMAP",
    "id": "dmap",
    "url": "/concepts/dmap.html"
  },
  {
    "label": "DML",
    "id": "dml",
    "url": "/concepts/dml.html"
  },
  {
    "label": "DNA",
    "id": "dna",
    "url": "/concepts/dna.html"
  },
  {
    "label": "DNS",
    "id": "dns",
    "url": "/concepts/dns.html"
  },
  {
    "label": "Docker",
    "id": "docker",
    "url": "/concepts/docker.html"
  },
  {
    "label": "Dockerfile",
    "id": "dockerfile",
    "url": "/concepts/dockerfile.html"
  },
  {
    "label": "docopt",
    "id": "docopt",
    "url": "/concepts/docopt.html"
  },
  {
    "label": "DOE Macsyma",
    "id": "doe-macsyma",
    "url": "/concepts/doe-macsyma.html"
  },
  {
    "label": "The Dog Programming Language",
    "id": "dog",
    "url": "/concepts/dog.html"
  },
  {
    "label": "Dogescript",
    "id": "dogescript",
    "url": "/concepts/dogescript.html"
  },
  {
    "label": "DNS over HTTPS",
    "id": "doh",
    "url": "/concepts/doh.html"
  },
  {
    "label": "DOI",
    "id": "doi",
    "url": "/concepts/doi.html"
  },
  {
    "label": "Dojo",
    "id": "dojo",
    "url": "/concepts/dojo.html"
  },
  {
    "label": "DokuWiki",
    "id": "dokuwiki",
    "url": "/concepts/dokuwiki.html"
  },
  {
    "label": "Dolittle",
    "id": "dolittle",
    "url": "/concepts/dolittle.html"
  },
  {
    "label": "$",
    "id": "dollar-sign",
    "url": "/concepts/dollar-sign.html"
  },
  {
    "label": "DOLPHIN",
    "id": "dolphin",
    "url": "/concepts/dolphin.html"
  },
  {
    "label": "domino",
    "id": "domino",
    "url": "/concepts/domino.html"
  },
  {
    "label": "DOML",
    "id": "doml",
    "url": "/concepts/doml.html"
  },
  {
    "label": "DOODLE",
    "id": "doodle",
    "url": "/concepts/doodle.html"
  },
  {
    "label": "DOPL",
    "id": "dopl",
    "url": "/concepts/dopl.html"
  },
  {
    "label": "Dot Product Equation",
    "id": "dot-product-equation",
    "url": "/concepts/dot-product-equation.html"
  },
  {
    "label": ".QL",
    "id": "dot-ql",
    "url": "/concepts/dot-ql.html"
  },
  {
    "label": "DOT",
    "id": "dot",
    "url": "/concepts/dot.html"
  },
  {
    "label": "DOWL",
    "id": "dowl",
    "url": "/concepts/dowl.html"
  },
  {
    "label": "D++",
    "id": "dpp",
    "url": "/concepts/dpp.html"
  },
  {
    "label": "DPRL",
    "id": "dprl",
    "url": "/concepts/dprl.html"
  },
  {
    "label": "Draco",
    "id": "draco-programming-language",
    "url": "/concepts/draco-programming-language.html"
  },
  {
    "label": "draconian",
    "id": "draconian",
    "url": "/concepts/draconian.html"
  },
  {
    "label": "DragonBASIC",
    "id": "dragonbasic",
    "url": "/concepts/dragonbasic.html"
  },
  {
    "label": "DRAGOON",
    "id": "dragoon",
    "url": "/concepts/dragoon.html"
  },
  {
    "label": "DRAKON",
    "id": "drakon",
    "url": "/concepts/drakon.html"
  },
  {
    "label": "dreamlisp",
    "id": "dreamlisp",
    "url": "/concepts/dreamlisp.html"
  },
  {
    "label": "Dribble",
    "id": "dribble",
    "url": "/concepts/dribble.html"
  },
  {
    "label": "DRL",
    "id": "drl",
    "url": "/concepts/drl.html"
  },
  {
    "label": "DROL",
    "id": "drol",
    "url": "/concepts/drol.html"
  },
  {
    "label": "Drupal",
    "id": "drupal",
    "url": "/concepts/drupal.html"
  },
  {
    "label": "Dimensional Script",
    "id": "dscript",
    "url": "/concepts/dscript.html"
  },
  {
    "label": "Document Structure Description",
    "id": "dsd",
    "url": "/concepts/dsd.html"
  },
  {
    "label": "DSL/90",
    "id": "dsl-90",
    "url": "/concepts/dsl-90.html"
  },
  {
    "label": "dslx",
    "id": "dslx",
    "url": "/concepts/dslx.html"
  },
  {
    "label": "dss",
    "id": "dss",
    "url": "/concepts/dss.html"
  },
  {
    "label": "dsym",
    "id": "dsym",
    "url": "/concepts/dsym.html"
  },
  {
    "label": "DTD",
    "id": "dtd",
    "url": "/concepts/dtd.html"
  },
  {
    "label": "DTrace",
    "id": "dtrace",
    "url": "/concepts/dtrace.html"
  },
  {
    "label": "TypeScript Type Declarations",
    "id": "dts",
    "url": "/concepts/dts.html"
  },
  {
    "label": "DUAL",
    "id": "dual",
    "url": "/concepts/dual.html"
  },
  {
    "label": "dub-pm",
    "id": "dub-pm",
    "url": "/concepts/dub-pm.html"
  },
  {
    "label": "DUEL",
    "id": "duel",
    "url": "/concepts/duel.html"
  },
  {
    "label": "duro",
    "id": "duro",
    "url": "/concepts/duro.html"
  },
  {
    "label": "Durra",
    "id": "durra",
    "url": "/concepts/durra.html"
  },
  {
    "label": "Digital Visual Interface",
    "id": "dvi-standard",
    "url": "/concepts/dvi-standard.html"
  },
  {
    "label": ".dwg",
    "id": "dwg",
    "url": "/concepts/dwg.html"
  },
  {
    "label": "AutoCAD DXF",
    "id": "dxf",
    "url": "/concepts/dxf.html"
  },
  {
    "label": "Dylan",
    "id": "dylan",
    "url": "/concepts/dylan.html"
  },
  {
    "label": "dynamo-pm",
    "id": "dynamo-pm",
    "url": "/concepts/dynamo-pm.html"
  },
  {
    "label": "Dynamo",
    "id": "dynamo-visual-language",
    "url": "/concepts/dynamo-visual-language.html"
  },
  {
    "label": "DYNAMO",
    "id": "dynamo",
    "url": "/concepts/dynamo.html"
  },
  {
    "label": "DYSTAL",
    "id": "dystal",
    "url": "/concepts/dystal.html"
  },
  {
    "label": "dyvil",
    "id": "dyvil",
    "url": "/concepts/dyvil.html"
  },
  {
    "label": "E",
    "id": "e",
    "url": "/concepts/e.html"
  },
  {
    "label": "Eagle",
    "id": "eagle",
    "url": "/concepts/eagle.html"
  },
  {
    "label": "Earl Grey",
    "id": "earl-grey",
    "url": "/concepts/earl-grey.html"
  },
  {
    "label": "EAS-E",
    "id": "eas-e",
    "url": "/concepts/eas-e.html"
  },
  {
    "label": "Ease",
    "id": "ease",
    "url": "/concepts/ease.html"
  },
  {
    "label": "EASL",
    "id": "easl",
    "url": "/concepts/easl.html"
  },
  {
    "label": "EASY ENGLISH",
    "id": "easy-english",
    "url": "/concepts/easy-english.html"
  },
  {
    "label": "Easy Programming Language",
    "id": "easy",
    "url": "/concepts/easy.html"
  },
  {
    "label": "Easybuild",
    "id": "easybuild",
    "url": "/concepts/easybuild.html"
  },
  {
    "label": "EasyLanguage",
    "id": "easylanguage",
    "url": "/concepts/easylanguage.html"
  },
  {
    "label": "Easytrieve",
    "id": "easytrieve",
    "url": "/concepts/easytrieve.html"
  },
  {
    "label": "ebg",
    "id": "ebg",
    "url": "/concepts/ebg.html"
  },
  {
    "label": "EBNF",
    "id": "ebnf",
    "url": "/concepts/ebnf.html"
  },
  {
    "label": "eC",
    "id": "ec",
    "url": "/concepts/ec.html"
  },
  {
    "label": "ECL",
    "id": "ecl",
    "url": "/concepts/ecl.html"
  },
  {
    "label": "Eclectic CSP",
    "id": "eclectic-csp",
    "url": "/concepts/eclectic-csp.html"
  },
  {
    "label": "Eclipse Command Language",
    "id": "eclipse-command-language",
    "url": "/concepts/eclipse-command-language.html"
  },
  {
    "label": "Eclipse",
    "id": "eclipse-editor",
    "url": "/concepts/eclipse-editor.html"
  },
  {
    "label": "ECMAScript",
    "id": "ecmascript",
    "url": "/concepts/ecmascript.html"
  },
  {
    "label": "eco-editor",
    "id": "eco-editor",
    "url": "/concepts/eco-editor.html"
  },
  {
    "label": "Ecological Metadata Language",
    "id": "ecological-metadata-language",
    "url": "/concepts/ecological-metadata-language.html"
  },
  {
    "label": "Embedded Crystal",
    "id": "ecr",
    "url": "/concepts/ecr.html"
  },
  {
    "label": "ecsharp",
    "id": "ecsharp",
    "url": "/concepts/ecsharp.html"
  },
  {
    "label": "ECT",
    "id": "ect",
    "url": "/concepts/ect.html"
  },
  {
    "label": "ed",
    "id": "ed-editor",
    "url": "/concepts/ed-editor.html"
  },
  {
    "label": "Eden",
    "id": "eden",
    "url": "/concepts/eden.html"
  },
  {
    "label": "Edge Side Includes",
    "id": "edge-side-includes",
    "url": "/concepts/edge-side-includes.html"
  },
  {
    "label": "edgedb",
    "id": "edgedb",
    "url": "/concepts/edgedb.html"
  },
  {
    "label": "edgelisp",
    "id": "edgelisp",
    "url": "/concepts/edgelisp.html"
  },
  {
    "label": "edgeql",
    "id": "edgeql",
    "url": "/concepts/edgeql.html"
  },
  {
    "label": "Đ",
    "id": "edh",
    "url": "/concepts/edh.html"
  },
  {
    "label": "Edina",
    "id": "edina",
    "url": "/concepts/edina.html"
  },
  {
    "label": "Edinburgh IMP",
    "id": "edinburgh-imp",
    "url": "/concepts/edinburgh-imp.html"
  },
  {
    "label": "Edinburgh LCF",
    "id": "edinburgh-lcf",
    "url": "/concepts/edinburgh-lcf.html"
  },
  {
    "label": "Edison",
    "id": "edison",
    "url": "/concepts/edison.html"
  },
  {
    "label": "Edje Data Collection",
    "id": "edje-data-collection",
    "url": "/concepts/edje-data-collection.html"
  },
  {
    "label": "EDN",
    "id": "edn",
    "url": "/concepts/edn.html"
  },
  {
    "label": "EDSAC Initial Orders",
    "id": "edsac-initial-orders",
    "url": "/concepts/edsac-initial-orders.html"
  },
  {
    "label": "ed script",
    "id": "edscript",
    "url": "/concepts/edscript.html"
  },
  {
    "label": "EDSIM",
    "id": "edsim",
    "url": "/concepts/edsim.html"
  },
  {
    "label": "EDUCE*",
    "id": "educe-star",
    "url": "/concepts/educe-star.html"
  },
  {
    "label": "EDUCE",
    "id": "educe",
    "url": "/concepts/educe.html"
  },
  {
    "label": "EEX",
    "id": "eex",
    "url": "/concepts/eex.html"
  },
  {
    "label": "eff",
    "id": "eff",
    "url": "/concepts/eff.html"
  },
  {
    "label": "EFL",
    "id": "efl",
    "url": "/concepts/efl.html"
  },
  {
    "label": "egel",
    "id": "egel",
    "url": "/concepts/egel.html"
  },
  {
    "label": "Egison",
    "id": "egison",
    "url": "/concepts/egison.html"
  },
  {
    "label": "EGL",
    "id": "egl",
    "url": "/concepts/egl.html"
  },
  {
    "label": "EGS4",
    "id": "egs4",
    "url": "/concepts/egs4.html"
  },
  {
    "label": "Eiffel",
    "id": "eiffel",
    "url": "/concepts/eiffel.html"
  },
  {
    "label": "EJS",
    "id": "ejs",
    "url": "/concepts/ejs.html"
  },
  {
    "label": "EL1",
    "id": "el1",
    "url": "/concepts/el1.html"
  },
  {
    "label": "ELAN",
    "id": "elan",
    "url": "/concepts/elan.html"
  },
  {
    "label": "Elasticsearch Query DSL",
    "id": "elastic-query-dsl",
    "url": "/concepts/elastic-query-dsl.html"
  },
  {
    "label": "Election Markup Language",
    "id": "election-markup-language",
    "url": "/concepts/election-markup-language.html"
  },
  {
    "label": "Electre",
    "id": "electre",
    "url": "/concepts/electre.html"
  },
  {
    "label": "elegance",
    "id": "elegance",
    "url": "/concepts/elegance.html"
  },
  {
    "label": "Elegant",
    "id": "elegant",
    "url": "/concepts/elegant.html"
  },
  {
    "label": "elena",
    "id": "elena",
    "url": "/concepts/elena.html"
  },
  {
    "label": "Extensible Linking Format",
    "id": "elf",
    "url": "/concepts/elf.html"
  },
  {
    "label": "ELFE",
    "id": "elfe",
    "url": "/concepts/elfe.html"
  },
  {
    "label": "Elixir",
    "id": "elixir",
    "url": "/concepts/elixir.html"
  },
  {
    "label": "ELLA",
    "id": "ella-programming-language",
    "url": "/concepts/ella-programming-language.html"
  },
  {
    "label": "Ellie",
    "id": "ellie",
    "url": "/concepts/ellie.html"
  },
  {
    "label": "Elliott ALGOL",
    "id": "elliott-algol",
    "url": "/concepts/elliott-algol.html"
  },
  {
    "label": "ELLPACK",
    "id": "ellpack",
    "url": "/concepts/ellpack.html"
  },
  {
    "label": "Elm Packages",
    "id": "elm-packages-pm",
    "url": "/concepts/elm-packages-pm.html"
  },
  {
    "label": "Elm",
    "id": "elm",
    "url": "/concepts/elm.html"
  },
  {
    "label": "ELMOL",
    "id": "elmol",
    "url": "/concepts/elmol.html"
  },
  {
    "label": "Emacs Lisp Package Archive",
    "id": "elpa-pm",
    "url": "/concepts/elpa-pm.html"
  },
  {
    "label": "Elpi",
    "id": "elpi",
    "url": "/concepts/elpi.html"
  },
  {
    "label": "Elvish",
    "id": "elvish",
    "url": "/concepts/elvish.html"
  },
  {
    "label": "elymas",
    "id": "elymas",
    "url": "/concepts/elymas.html"
  },
  {
    "label": "Em",
    "id": "em",
    "url": "/concepts/em.html"
  },
  {
    "label": "Emacs",
    "id": "emacs-editor",
    "url": "/concepts/emacs-editor.html"
  },
  {
    "label": "Emacs Lisp",
    "id": "emacs-lisp",
    "url": "/concepts/emacs-lisp.html"
  },
  {
    "label": "emberjs-framework",
    "id": "emberjs-framework",
    "url": "/concepts/emberjs-framework.html"
  },
  {
    "label": "EmberScript",
    "id": "emberscript",
    "url": "/concepts/emberscript.html"
  },
  {
    "label": "emerald-lang",
    "id": "emerald-lang",
    "url": "/concepts/emerald-lang.html"
  },
  {
    "label": "Emerald",
    "id": "emerald",
    "url": "/concepts/emerald.html"
  },
  {
    "label": "emesh",
    "id": "emesh",
    "url": "/concepts/emesh.html"
  },
  {
    "label": "emfatic",
    "id": "emfatic",
    "url": "/concepts/emfatic.html"
  },
  {
    "label": "Emily",
    "id": "emily",
    "url": "/concepts/emily.html"
  },
  {
    "label": "EMMA",
    "id": "emma",
    "url": "/concepts/emma.html"
  },
  {
    "label": "Emojicode",
    "id": "emojicode",
    "url": "/concepts/emojicode.html"
  },
  {
    "label": "emoticon",
    "id": "emoticon",
    "url": "/concepts/emoticon.html"
  },
  {
    "label": "empirical",
    "id": "empirical",
    "url": "/concepts/empirical.html"
  },
  {
    "label": "emu",
    "id": "emu",
    "url": "/concepts/emu.html"
  },
  {
    "label": "Encore",
    "id": "encore",
    "url": "/concepts/encore.html"
  },
  {
    "label": "Energy Systems Language",
    "id": "energese-notation",
    "url": "/concepts/energese-notation.html"
  },
  {
    "label": "Energy Momentum Equation",
    "id": "energy-momentum-equation",
    "url": "/concepts/energy-momentum-equation.html"
  },
  {
    "label": "english-programming-language",
    "id": "english-programming-language",
    "url": "/concepts/english-programming-language.html"
  },
  {
    "label": "eno",
    "id": "eno",
    "url": "/concepts/eno.html"
  },
  {
    "label": "enso",
    "id": "enso-lang",
    "url": "/concepts/enso-lang.html"
  },
  {
    "label": "Enso",
    "id": "enso",
    "url": "/concepts/enso.html"
  },
  {
    "label": "Enterprise Mashup Markup Language",
    "id": "enterprise-mashup-markup-language",
    "url": "/concepts/enterprise-mashup-markup-language.html"
  },
  {
    "label": "Entropy",
    "id": "entropy",
    "url": "/concepts/entropy.html"
  },
  {
    "label": "envoy-app",
    "id": "envoy-app",
    "url": "/concepts/envoy-app.html"
  },
  {
    "label": "Epigram",
    "id": "epigram",
    "url": "/concepts/epigram.html"
  },
  {
    "label": "EPILOG",
    "id": "epilog",
    "url": "/concepts/epilog.html"
  },
  {
    "label": "epsilon",
    "id": "epsilon",
    "url": "/concepts/epsilon.html"
  },
  {
    "label": "EqL",
    "id": "eql",
    "url": "/concepts/eql.html"
  },
  {
    "label": "EQLog",
    "id": "eqlog",
    "url": "/concepts/eqlog.html"
  },
  {
    "label": "eqn",
    "id": "eqn",
    "url": "/concepts/eqn.html"
  },
  {
    "label": "EQS",
    "id": "eqs",
    "url": "/concepts/eqs.html"
  },
  {
    "label": "EQUATE",
    "id": "equate",
    "url": "/concepts/equate.html"
  },
  {
    "label": "ERB",
    "id": "erb",
    "url": "/concepts/erb.html"
  },
  {
    "label": "erg",
    "id": "erg",
    "url": "/concepts/erg.html"
  },
  {
    "label": "Erlang",
    "id": "erlang",
    "url": "/concepts/erlang.html"
  },
  {
    "label": "ERROL",
    "id": "errol",
    "url": "/concepts/errol.html"
  },
  {
    "label": "ESC/P",
    "id": "esc-p",
    "url": "/concepts/esc-p.html"
  },
  {
    "label": "Escapade",
    "id": "escapade-programming-language",
    "url": "/concepts/escapade-programming-language.html"
  },
  {
    "label": "eskew",
    "id": "eskew",
    "url": "/concepts/eskew.html"
  },
  {
    "label": "Esoteric Reaction",
    "id": "esoteric-reaction",
    "url": "/concepts/esoteric-reaction.html"
  },
  {
    "label": "ESP",
    "id": "esp",
    "url": "/concepts/esp.html"
  },
  {
    "label": "Executive Systems Problem Oriented Language",
    "id": "espol",
    "url": "/concepts/espol.html"
  },
  {
    "label": "Esterel",
    "id": "esterel",
    "url": "/concepts/esterel.html"
  },
  {
    "label": "eta",
    "id": "eta",
    "url": "/concepts/eta.html"
  },
  {
    "label": "ETC",
    "id": "etc",
    "url": "/concepts/etc.html"
  },
  {
    "label": "Ethereum Virtual Machine",
    "id": "ethereum-vm",
    "url": "/concepts/ethereum-vm.html"
  },
  {
    "label": "Ethernet",
    "id": "ethernet",
    "url": "/concepts/ethernet.html"
  },
  {
    "label": "Etoys",
    "id": "etoys",
    "url": "/concepts/etoys.html"
  },
  {
    "label": "Etruscan numerals",
    "id": "etruscan-numerals",
    "url": "/concepts/etruscan-numerals.html"
  },
  {
    "label": "Etude",
    "id": "etude",
    "url": "/concepts/etude.html"
  },
  {
    "label": "euboea",
    "id": "euboea",
    "url": "/concepts/euboea.html"
  },
  {
    "label": "Euclid",
    "id": "euclid",
    "url": "/concepts/euclid.html"
  },
  {
    "label": "Euclidean geometry",
    "id": "euclidean-geometry",
    "url": "/concepts/euclidean-geometry.html"
  },
  {
    "label": "Euler",
    "id": "euler",
    "url": "/concepts/euler.html"
  },
  {
    "label": "Euler's Equation",
    "id": "eulers-equation",
    "url": "/concepts/eulers-equation.html"
  },
  {
    "label": "EuLisp",
    "id": "eulisp",
    "url": "/concepts/eulisp.html"
  },
  {
    "label": "EUMEL",
    "id": "eumel",
    "url": "/concepts/eumel.html"
  },
  {
    "label": "Euphoria",
    "id": "euphoria",
    "url": "/concepts/euphoria.html"
  },
  {
    "label": "Eurisko",
    "id": "eurisko",
    "url": "/concepts/eurisko.html"
  },
  {
    "label": "Eva",
    "id": "eva",
    "url": "/concepts/eva.html"
  },
  {
    "label": "Eve",
    "id": "eve",
    "url": "/concepts/eve.html"
  },
  {
    "label": "EverParse3D",
    "id": "everparse3d",
    "url": "/concepts/everparse3d.html"
  },
  {
    "label": "ex",
    "id": "ex-editor",
    "url": "/concepts/ex-editor.html"
  },
  {
    "label": "EXAPT",
    "id": "exapt",
    "url": "/concepts/exapt.html"
  },
  {
    "label": "Microsoft Excel",
    "id": "excel-app",
    "url": "/concepts/excel-app.html"
  },
  {
    "label": "EXEC 2",
    "id": "exec-2",
    "url": "/concepts/exec-2.html"
  },
  {
    "label": "Executable JSON",
    "id": "executable-json",
    "url": "/concepts/executable-json.html"
  },
  {
    "label": "EXEL",
    "id": "exel",
    "url": "/concepts/exel.html"
  },
  {
    "label": "ExFAT",
    "id": "exfat",
    "url": "/concepts/exfat.html"
  },
  {
    "label": "exkited",
    "id": "exkited",
    "url": "/concepts/exkited.html"
  },
  {
    "label": "Expect",
    "id": "expect",
    "url": "/concepts/expect.html"
  },
  {
    "label": "EXPLAN",
    "id": "explan",
    "url": "/concepts/explan.html"
  },
  {
    "label": "EXPLOR",
    "id": "explor",
    "url": "/concepts/explor.html"
  },
  {
    "label": "Explorer",
    "id": "explorer",
    "url": "/concepts/explorer.html"
  },
  {
    "label": "EXPRESS",
    "id": "express",
    "url": "/concepts/express.html"
  },
  {
    "label": "expresso",
    "id": "expresso",
    "url": "/concepts/expresso.html"
  },
  {
    "label": "Extended file system",
    "id": "ext",
    "url": "/concepts/ext.html"
  },
  {
    "label": "Ext2",
    "id": "ext2",
    "url": "/concepts/ext2.html"
  },
  {
    "label": "Ext3",
    "id": "ext3",
    "url": "/concepts/ext3.html"
  },
  {
    "label": "Ext4",
    "id": "ext4",
    "url": "/concepts/ext4.html"
  },
  {
    "label": "Extempore",
    "id": "extempore",
    "url": "/concepts/extempore.html"
  },
  {
    "label": "Extended ML",
    "id": "extended-ml",
    "url": "/concepts/extended-ml.html"
  },
  {
    "label": "Extended Pascal",
    "id": "extended-pascal",
    "url": "/concepts/extended-pascal.html"
  },
  {
    "label": "Extensible Embeddable Language",
    "id": "extensible-embeddable-language",
    "url": "/concepts/extensible-embeddable-language.html"
  },
  {
    "label": "EXTRAN",
    "id": "extran",
    "url": "/concepts/extran.html"
  },
  {
    "label": "EZ",
    "id": "ez",
    "url": "/concepts/ez.html"
  },
  {
    "label": "Ezhil",
    "id": "ezhil",
    "url": "/concepts/ezhil.html"
  },
  {
    "label": "F Prime",
    "id": "f-prime",
    "url": "/concepts/f-prime.html"
  },
  {
    "label": "F-Script",
    "id": "f-script",
    "url": "/concepts/f-script.html"
  },
  {
    "label": "F#",
    "id": "f-sharp",
    "url": "/concepts/f-sharp.html"
  },
  {
    "label": "F",
    "id": "f",
    "url": "/concepts/f.html"
  },
  {
    "label": "Fable",
    "id": "fable-lang",
    "url": "/concepts/fable-lang.html"
  },
  {
    "label": "Fable",
    "id": "fable",
    "url": "/concepts/fable.html"
  },
  {
    "label": "FAC",
    "id": "fac",
    "url": "/concepts/fac.html"
  },
  {
    "label": "Facelets",
    "id": "facelets",
    "url": "/concepts/facelets.html"
  },
  {
    "label": "FaCT",
    "id": "fact-lang",
    "url": "/concepts/fact-lang.html"
  },
  {
    "label": "Fully Automated Compiling Technique",
    "id": "fact",
    "url": "/concepts/fact.html"
  },
  {
    "label": "Factor",
    "id": "factor",
    "url": "/concepts/factor.html"
  },
  {
    "label": "FAD",
    "id": "fad",
    "url": "/concepts/fad.html"
  },
  {
    "label": "Falcon",
    "id": "falcon",
    "url": "/concepts/falcon.html"
  },
  {
    "label": "False",
    "id": "false",
    "url": "/concepts/false.html"
  },
  {
    "label": "Family BASIC",
    "id": "family-basic",
    "url": "/concepts/family-basic.html"
  },
  {
    "label": "Fancy",
    "id": "fancy",
    "url": "/concepts/fancy.html"
  },
  {
    "label": "Fantom",
    "id": "fantom",
    "url": "/concepts/fantom.html"
  },
  {
    "label": "FORTRAN assembly program",
    "id": "fap",
    "url": "/concepts/fap.html"
  },
  {
    "label": "FAR",
    "id": "far",
    "url": "/concepts/far.html"
  },
  {
    "label": "Faraday's Induction Equation",
    "id": "faradays-induction-equation",
    "url": "/concepts/faradays-induction-equation.html"
  },
  {
    "label": "Farcaster",
    "id": "farcaster",
    "url": "/concepts/farcaster.html"
  },
  {
    "label": "Fardlang",
    "id": "fardlang",
    "url": "/concepts/fardlang.html"
  },
  {
    "label": "Fast Fourier Transform Equation",
    "id": "fast-fourier-transform-equation",
    "url": "/concepts/fast-fourier-transform-equation.html"
  },
  {
    "label": "FASTA",
    "id": "fasta-format",
    "url": "/concepts/fasta-format.html"
  },
  {
    "label": "FASTQ",
    "id": "fastq-format",
    "url": "/concepts/fastq-format.html"
  },
  {
    "label": "FastTrack Scripting Host",
    "id": "fasttrack-scripting-host",
    "url": "/concepts/fasttrack-scripting-host.html"
  },
  {
    "label": "FAT",
    "id": "fat",
    "url": "/concepts/fat.html"
  },
  {
    "label": "FAUST",
    "id": "faust",
    "url": "/concepts/faust.html"
  },
  {
    "label": "Fawlty",
    "id": "fawlty",
    "url": "/concepts/fawlty.html"
  },
  {
    "label": "fay",
    "id": "fay",
    "url": "/concepts/fay.html"
  },
  {
    "label": "FCL",
    "id": "fcl",
    "url": "/concepts/fcl.html"
  },
  {
    "label": "FCPU",
    "id": "fcpu",
    "url": "/concepts/fcpu.html"
  },
  {
    "label": "fe",
    "id": "fe",
    "url": "/concepts/fe.html"
  },
  {
    "label": "Friendly Enough Expression Language",
    "id": "feel",
    "url": "/concepts/feel.html"
  },
  {
    "label": "Felix",
    "id": "felix",
    "url": "/concepts/felix.html"
  },
  {
    "label": "femtolisp",
    "id": "femtolisp",
    "url": "/concepts/femtolisp.html"
  },
  {
    "label": "Forsyth-Edwards Notation",
    "id": "fen-notation",
    "url": "/concepts/fen-notation.html"
  },
  {
    "label": "Fenix Project",
    "id": "fenix-project",
    "url": "/concepts/fenix-project.html"
  },
  {
    "label": "Fennel",
    "id": "fennel",
    "url": "/concepts/fennel.html"
  },
  {
    "label": "Ferite",
    "id": "ferite",
    "url": "/concepts/ferite.html"
  },
  {
    "label": "Fern",
    "id": "fern",
    "url": "/concepts/fern.html"
  },
  {
    "label": "ferret",
    "id": "ferret",
    "url": "/concepts/ferret.html"
  },
  {
    "label": "fetlang",
    "id": "fetlang",
    "url": "/concepts/fetlang.html"
  },
  {
    "label": "Feynman diagram",
    "id": "feynman-diagram",
    "url": "/concepts/feynman-diagram.html"
  },
  {
    "label": "FFmpeg",
    "id": "ffmpeg",
    "url": "/concepts/ffmpeg.html"
  },
  {
    "label": "Fast Healthcare Interoperability Resources",
    "id": "fhir",
    "url": "/concepts/fhir.html"
  },
  {
    "label": "Liber Abaci",
    "id": "fibonacci-notation",
    "url": "/concepts/fibonacci-notation.html"
  },
  {
    "label": "Fibonacci",
    "id": "fibonacci",
    "url": "/concepts/fibonacci.html"
  },
  {
    "label": "Fickle",
    "id": "fickle",
    "url": "/concepts/fickle.html"
  },
  {
    "label": "FIGlet Font",
    "id": "figlet-font",
    "url": "/concepts/figlet-font.html"
  },
  {
    "label": "Filebench WML",
    "id": "filebench-wml",
    "url": "/concepts/filebench-wml.html"
  },
  {
    "label": "filetab-d",
    "id": "filetab-d",
    "url": "/concepts/filetab-d.html"
  },
  {
    "label": "FILETAB",
    "id": "filetab",
    "url": "/concepts/filetab.html"
  },
  {
    "label": "Filterscript",
    "id": "filterscript",
    "url": "/concepts/filterscript.html"
  },
  {
    "label": "Firebase Realtime Database",
    "id": "firebase",
    "url": "/concepts/firebase.html"
  },
  {
    "label": "Firefox",
    "id": "firefox",
    "url": "/concepts/firefox.html"
  },
  {
    "label": "firrtl",
    "id": "firrtl",
    "url": "/concepts/firrtl.html"
  },
  {
    "label": "fish",
    "id": "fish",
    "url": "/concepts/fish.html"
  },
  {
    "label": "><>",
    "id": "fishlang",
    "url": "/concepts/fishlang.html"
  },
  {
    "label": "fizz",
    "id": "fizz",
    "url": "/concepts/fizz.html"
  },
  {
    "label": "Fjölnir",
    "id": "fjolnir",
    "url": "/concepts/fjolnir.html"
  },
  {
    "label": "fjs",
    "id": "fjs",
    "url": "/concepts/fjs.html"
  },
  {
    "label": "FL",
    "id": "fl",
    "url": "/concepts/fl.html"
  },
  {
    "label": "FLACC",
    "id": "flacc",
    "url": "/concepts/flacc.html"
  },
  {
    "label": "flagship",
    "id": "flagship",
    "url": "/concepts/flagship.html"
  },
  {
    "label": "flame-ir",
    "id": "flame-ir",
    "url": "/concepts/flame-ir.html"
  },
  {
    "label": "FLANG",
    "id": "flang",
    "url": "/concepts/flang.html"
  },
  {
    "label": "Flapjax",
    "id": "flapjax",
    "url": "/concepts/flapjax.html"
  },
  {
    "label": "Flare",
    "id": "flare",
    "url": "/concepts/flare.html"
  },
  {
    "label": "FlatBuffers",
    "id": "flatbuffers",
    "url": "/concepts/flatbuffers.html"
  },
  {
    "label": "Flatline",
    "id": "flatline",
    "url": "/concepts/flatline.html"
  },
  {
    "label": "Flavors",
    "id": "flavors",
    "url": "/concepts/flavors.html"
  },
  {
    "label": "fleck",
    "id": "fleck",
    "url": "/concepts/fleck.html"
  },
  {
    "label": "FLENG++",
    "id": "flengpp",
    "url": "/concepts/flengpp.html"
  },
  {
    "label": "Flex language",
    "id": "flex-lang",
    "url": "/concepts/flex-lang.html"
  },
  {
    "label": "FLEX",
    "id": "flex",
    "url": "/concepts/flex.html"
  },
  {
    "label": "flexbuffers",
    "id": "flexbuffers",
    "url": "/concepts/flexbuffers.html"
  },
  {
    "label": "FleXML",
    "id": "flexml",
    "url": "/concepts/flexml.html"
  },
  {
    "label": "FLIC",
    "id": "flic",
    "url": "/concepts/flic.html"
  },
  {
    "label": "Flix",
    "id": "flix",
    "url": "/concepts/flix.html"
  },
  {
    "label": "floorplan",
    "id": "floorplan",
    "url": "/concepts/floorplan.html"
  },
  {
    "label": "Flora",
    "id": "flora",
    "url": "/concepts/flora.html"
  },
  {
    "label": "Floral",
    "id": "floral",
    "url": "/concepts/floral.html"
  },
  {
    "label": "FloScript",
    "id": "floscript",
    "url": "/concepts/floscript.html"
  },
  {
    "label": "FLOW-MATIC",
    "id": "flow-matic",
    "url": "/concepts/flow-matic.html"
  },
  {
    "label": "Flow",
    "id": "flow",
    "url": "/concepts/flow.html"
  },
  {
    "label": "Flow9",
    "id": "flow9",
    "url": "/concepts/flow9.html"
  },
  {
    "label": "flowchart.fun",
    "id": "flowchart-fun",
    "url": "/concepts/flowchart-fun.html"
  },
  {
    "label": "Flowcode",
    "id": "flowcode",
    "url": "/concepts/flowcode.html"
  },
  {
    "label": "Flowgorithm",
    "id": "flowgorithm",
    "url": "/concepts/flowgorithm.html"
  },
  {
    "label": "flowlog",
    "id": "flowlog",
    "url": "/concepts/flowlog.html"
  },
  {
    "label": "FlowNet",
    "id": "flownet",
    "url": "/concepts/flownet.html"
  },
  {
    "label": "flownote",
    "id": "flownote",
    "url": "/concepts/flownote.html"
  },
  {
    "label": "flua",
    "id": "flua",
    "url": "/concepts/flua.html"
  },
  {
    "label": "Flutter",
    "id": "flutter-framework",
    "url": "/concepts/flutter-framework.html"
  },
  {
    "label": "flux-lang",
    "id": "flux-lang",
    "url": "/concepts/flux-lang.html"
  },
  {
    "label": "FLUX",
    "id": "flux",
    "url": "/concepts/flux.html"
  },
  {
    "label": "FM broadcasting",
    "id": "fm-standard",
    "url": "/concepts/fm-standard.html"
  },
  {
    "label": "fmj",
    "id": "fmj",
    "url": "/concepts/fmj.html"
  },
  {
    "label": "FML",
    "id": "fml-lang",
    "url": "/concepts/fml-lang.html"
  },
  {
    "label": "Fuzzy Markup Language",
    "id": "fml",
    "url": "/concepts/fml.html"
  },
  {
    "label": "fo",
    "id": "fo",
    "url": "/concepts/fo.html"
  },
  {
    "label": "FOAF",
    "id": "foaf",
    "url": "/concepts/foaf.html"
  },
  {
    "label": "Formulating On-Line Calculations in Algebraic Language",
    "id": "focal",
    "url": "/concepts/focal.html"
  },
  {
    "label": "FOCUS",
    "id": "focus",
    "url": "/concepts/focus.html"
  },
  {
    "label": "File Oriented Interpretive Language",
    "id": "foil",
    "url": "/concepts/foil.html"
  },
  {
    "label": "foogol",
    "id": "foogol",
    "url": "/concepts/foogol.html"
  },
  {
    "label": "FORAL LP",
    "id": "foral-lp",
    "url": "/concepts/foral-lp.html"
  },
  {
    "label": "FORAL",
    "id": "foral",
    "url": "/concepts/foral.html"
  },
  {
    "label": "FORALL",
    "id": "forall",
    "url": "/concepts/forall.html"
  },
  {
    "label": "forest-database",
    "id": "forest-database",
    "url": "/concepts/forest-database.html"
  },
  {
    "label": "forest-lang",
    "id": "forest-lang",
    "url": "/concepts/forest-lang.html"
  },
  {
    "label": "ForgeBox",
    "id": "forgebox-pm",
    "url": "/concepts/forgebox-pm.html"
  },
  {
    "label": "fork-lang",
    "id": "fork-lang",
    "url": "/concepts/fork-lang.html"
  },
  {
    "label": "FORK",
    "id": "fork",
    "url": "/concepts/fork.html"
  },
  {
    "label": "Fork95",
    "id": "fork95",
    "url": "/concepts/fork95.html"
  },
  {
    "label": "FORMAC",
    "id": "formac",
    "url": "/concepts/formac.html"
  },
  {
    "label": "formality",
    "id": "formality",
    "url": "/concepts/formality.html"
  },
  {
    "label": "Formatted Table",
    "id": "formatted-table",
    "url": "/concepts/formatted-table.html"
  },
  {
    "label": "Forml",
    "id": "forml",
    "url": "/concepts/forml.html"
  },
  {
    "label": "FORMS/3",
    "id": "forms-3",
    "url": "/concepts/forms-3.html"
  },
  {
    "label": "Formula language",
    "id": "formula",
    "url": "/concepts/formula.html"
  },
  {
    "label": "Forte 4GL",
    "id": "forte-4gl",
    "url": "/concepts/forte-4gl.html"
  },
  {
    "label": "Forth",
    "id": "forth",
    "url": "/concepts/forth.html"
  },
  {
    "label": "forthnet-pm",
    "id": "forthnet-pm",
    "url": "/concepts/forthnet-pm.html"
  },
  {
    "label": "ForthScript",
    "id": "forthscript",
    "url": "/concepts/forthscript.html"
  },
  {
    "label": "FORTRAN 77",
    "id": "fortran-77",
    "url": "/concepts/fortran-77.html"
  },
  {
    "label": "Fortran 8x",
    "id": "fortran-8x",
    "url": "/concepts/fortran-8x.html"
  },
  {
    "label": "Fortran 90",
    "id": "fortran-90",
    "url": "/concepts/fortran-90.html"
  },
  {
    "label": "FORTRAN CEP",
    "id": "fortran-cep",
    "url": "/concepts/fortran-cep.html"
  },
  {
    "label": "Fortran D",
    "id": "fortran-d",
    "url": "/concepts/fortran-d.html"
  },
  {
    "label": "FORTRAN II",
    "id": "fortran-ii",
    "url": "/concepts/fortran-ii.html"
  },
  {
    "label": "FORTRAN III",
    "id": "fortran-iii",
    "url": "/concepts/fortran-iii.html"
  },
  {
    "label": "FORTRAN IV",
    "id": "fortran-iv",
    "url": "/concepts/fortran-iv.html"
  },
  {
    "label": "Fortran M",
    "id": "fortran-m",
    "url": "/concepts/fortran-m.html"
  },
  {
    "label": "Fortran",
    "id": "fortran",
    "url": "/concepts/fortran.html"
  },
  {
    "label": "FORTRANSIT",
    "id": "fortransit",
    "url": "/concepts/fortransit.html"
  },
  {
    "label": "Fortress",
    "id": "fortress",
    "url": "/concepts/fortress.html"
  },
  {
    "label": "Fossil",
    "id": "fossil-scm",
    "url": "/concepts/fossil-scm.html"
  },
  {
    "label": "foundry",
    "id": "foundry",
    "url": "/concepts/foundry.html"
  },
  {
    "label": "fox",
    "id": "fox",
    "url": "/concepts/fox.html"
  },
  {
    "label": "FoxPRO",
    "id": "foxpro",
    "url": "/concepts/foxpro.html"
  },
  {
    "label": "FP",
    "id": "fp",
    "url": "/concepts/fp.html"
  },
  {
    "label": "FP2",
    "id": "fp2",
    "url": "/concepts/fp2.html"
  },
  {
    "label": "fp",
    "id": "fp3",
    "url": "/concepts/fp3.html"
  },
  {
    "label": "FpgaC",
    "id": "fpgac",
    "url": "/concepts/fpgac.html"
  },
  {
    "label": "Functional PHP Preprocessor",
    "id": "fpp",
    "url": "/concepts/fpp.html"
  },
  {
    "label": "FRACTRAN",
    "id": "fractran",
    "url": "/concepts/fractran.html"
  },
  {
    "label": "frame",
    "id": "frame",
    "url": "/concepts/frame.html"
  },
  {
    "label": "Framework office suite",
    "id": "framework-office-suite",
    "url": "/concepts/framework-office-suite.html"
  },
  {
    "label": "FRAN",
    "id": "fran",
    "url": "/concepts/fran.html"
  },
  {
    "label": "Frank",
    "id": "frank-lang",
    "url": "/concepts/frank-lang.html"
  },
  {
    "label": "FRANK",
    "id": "frank",
    "url": "/concepts/frank.html"
  },
  {
    "label": "Free Pascal",
    "id": "free-pascal",
    "url": "/concepts/free-pascal.html"
  },
  {
    "label": "FreeBASIC",
    "id": "freebasic",
    "url": "/concepts/freebasic.html"
  },
  {
    "label": "FreeBSD",
    "id": "freebsd",
    "url": "/concepts/freebsd.html"
  },
  {
    "label": "Freefem",
    "id": "freefem",
    "url": "/concepts/freefem.html"
  },
  {
    "label": "FreeMarker",
    "id": "freemarker",
    "url": "/concepts/freemarker.html"
  },
  {
    "label": "Frege",
    "id": "frege",
    "url": "/concepts/frege.html"
  },
  {
    "label": "Frenetic",
    "id": "frenetic",
    "url": "/concepts/frenetic.html"
  },
  {
    "label": "Fresco",
    "id": "fresco",
    "url": "/concepts/fresco.html"
  },
  {
    "label": "Frink",
    "id": "frink",
    "url": "/concepts/frink.html"
  },
  {
    "label": "Frost",
    "id": "frost",
    "url": "/concepts/frost.html"
  },
  {
    "label": "frtime",
    "id": "frtime",
    "url": "/concepts/frtime.html"
  },
  {
    "label": "fructure-editor",
    "id": "fructure-editor",
    "url": "/concepts/fructure-editor.html"
  },
  {
    "label": "Finite State Language",
    "id": "fsl",
    "url": "/concepts/fsl.html"
  },
  {
    "label": "F*",
    "id": "fstar",
    "url": "/concepts/fstar.html"
  },
  {
    "label": "FTP",
    "id": "ftp",
    "url": "/concepts/ftp.html"
  },
  {
    "label": "Fun",
    "id": "fun",
    "url": "/concepts/fun.html"
  },
  {
    "label": "Function block diagram",
    "id": "function-block-diagram",
    "url": "/concepts/function-block-diagram.html"
  },
  {
    "label": "funl",
    "id": "funl",
    "url": "/concepts/funl.html"
  },
  {
    "label": "Futhark",
    "id": "futhark",
    "url": "/concepts/futhark.html"
  },
  {
    "label": "FutureBASIC",
    "id": "futurebasic",
    "url": "/concepts/futurebasic.html"
  },
  {
    "label": "FutureScript",
    "id": "futurescript",
    "url": "/concepts/futurescript.html"
  },
  {
    "label": "Fuzuli",
    "id": "fuzuli",
    "url": "/concepts/fuzuli.html"
  },
  {
    "label": "FuzzyCLIPS",
    "id": "fuzzyclips",
    "url": "/concepts/fuzzyclips.html"
  },
  {
    "label": "FX-87",
    "id": "fx-87",
    "url": "/concepts/fx-87.html"
  },
  {
    "label": "FXML",
    "id": "fxml",
    "url": "/concepts/fxml.html"
  },
  {
    "label": "FXScript",
    "id": "fxscript",
    "url": "/concepts/fxscript.html"
  },
  {
    "label": "g-2",
    "id": "g-2",
    "url": "/concepts/g-2.html"
  },
  {
    "label": "G-code",
    "id": "g-code",
    "url": "/concepts/g-code.html"
  },
  {
    "label": "g-expressions",
    "id": "g-expressions",
    "url": "/concepts/g-expressions.html"
  },
  {
    "label": "g-fu",
    "id": "g-fu",
    "url": "/concepts/g-fu.html"
  },
  {
    "label": "G-Portugol",
    "id": "g-portugol",
    "url": "/concepts/g-portugol.html"
  },
  {
    "label": "GAEA",
    "id": "gaea",
    "url": "/concepts/gaea.html"
  },
  {
    "label": "Gaiman",
    "id": "gaiman",
    "url": "/concepts/gaiman.html"
  },
  {
    "label": "Galaksija BASIC",
    "id": "galaksija-basic",
    "url": "/concepts/galaksija-basic.html"
  },
  {
    "label": "Galileo",
    "id": "galileo",
    "url": "/concepts/galileo.html"
  },
  {
    "label": "Gambas",
    "id": "gambas",
    "url": "/concepts/gambas.html"
  },
  {
    "label": "Game Maker Language",
    "id": "game-maker-language",
    "url": "/concepts/game-maker-language.html"
  },
  {
    "label": "Game Oriented Assembly Lisp",
    "id": "game-oriented-assembly-lisp",
    "url": "/concepts/game-oriented-assembly-lisp.html"
  },
  {
    "label": "GAME",
    "id": "game",
    "url": "/concepts/game.html"
  },
  {
    "label": "GameMonkey Script",
    "id": "gamemonkey-script",
    "url": "/concepts/gamemonkey-script.html"
  },
  {
    "label": "GamerLanguage",
    "id": "gamerlanguage",
    "url": "/concepts/gamerlanguage.html"
  },
  {
    "label": "GAML",
    "id": "gaml",
    "url": "/concepts/gaml.html"
  },
  {
    "label": "GAMS",
    "id": "gams",
    "url": "/concepts/gams.html"
  },
  {
    "label": "GAP",
    "id": "gap",
    "url": "/concepts/gap.html"
  },
  {
    "label": "Gargoyle",
    "id": "gargoyle",
    "url": "/concepts/gargoyle.html"
  },
  {
    "label": "GARP",
    "id": "garp",
    "url": "/concepts/garp.html"
  },
  {
    "label": "GNU Assembler",
    "id": "gas",
    "url": "/concepts/gas.html"
  },
  {
    "label": "GASP II",
    "id": "gasp-ii",
    "url": "/concepts/gasp-ii.html"
  },
  {
    "label": "General Activity Simulation Program",
    "id": "gasp",
    "url": "/concepts/gasp.html"
  },
  {
    "label": "GAT",
    "id": "gat",
    "url": "/concepts/gat.html"
  },
  {
    "label": "Gauche Scheme implementation",
    "id": "gauche",
    "url": "/concepts/gauche.html"
  },
  {
    "label": "Gauss Flux Formula",
    "id": "gauss-flux-equation",
    "url": "/concepts/gauss-flux-equation.html"
  },
  {
    "label": "Gauss Magnetism Formula",
    "id": "gauss-magnetism-equation",
    "url": "/concepts/gauss-magnetism-equation.html"
  },
  {
    "label": "GaussFit",
    "id": "gaussfit",
    "url": "/concepts/gaussfit.html"
  },
  {
    "label": "GCC Machine Description",
    "id": "gcc-machine-description",
    "url": "/concepts/gcc-machine-description.html"
  },
  {
    "label": "GCC",
    "id": "gcc",
    "url": "/concepts/gcc.html"
  },
  {
    "label": "GCLA II",
    "id": "gcla-ii",
    "url": "/concepts/gcla-ii.html"
  },
  {
    "label": "GCP",
    "id": "gcp",
    "url": "/concepts/gcp.html"
  },
  {
    "label": "Google Data Protcol",
    "id": "gdata",
    "url": "/concepts/gdata.html"
  },
  {
    "label": "GDB",
    "id": "gdb",
    "url": "/concepts/gdb.html"
  },
  {
    "label": "GNU Data Language",
    "id": "gdl",
    "url": "/concepts/gdl.html"
  },
  {
    "label": "GDPL",
    "id": "gdpl",
    "url": "/concepts/gdpl.html"
  },
  {
    "label": "GDScript",
    "id": "gdscript",
    "url": "/concepts/gdscript.html"
  },
  {
    "label": "Geany",
    "id": "geany-editor",
    "url": "/concepts/geany-editor.html"
  },
  {
    "label": "Gecko",
    "id": "gecko",
    "url": "/concepts/gecko.html"
  },
  {
    "label": "Gedanken",
    "id": "gedanken",
    "url": "/concepts/gedanken.html"
  },
  {
    "label": "gedit-editor",
    "id": "gedit-editor",
    "url": "/concepts/gedit-editor.html"
  },
  {
    "label": "Generic Expression Language",
    "id": "gel",
    "url": "/concepts/gel.html"
  },
  {
    "label": "Gellish",
    "id": "gellish",
    "url": "/concepts/gellish.html"
  },
  {
    "label": "Gello Expression Language",
    "id": "gello",
    "url": "/concepts/gello.html"
  },
  {
    "label": "GEM",
    "id": "gem",
    "url": "/concepts/gem.html"
  },
  {
    "label": "General-purpose macro processor",
    "id": "gema",
    "url": "/concepts/gema.html"
  },
  {
    "label": "gemini-protocol",
    "id": "gemini-protocol",
    "url": "/concepts/gemini-protocol.html"
  },
  {
    "label": "GAMS",
    "id": "general-algebraic-modeling-system",
    "url": "/concepts/general-algebraic-modeling-system.html"
  },
  {
    "label": "GN",
    "id": "generate-ninja",
    "url": "/concepts/generate-ninja.html"
  },
  {
    "label": "Generic Haskell",
    "id": "generic-haskell",
    "url": "/concepts/generic-haskell.html"
  },
  {
    "label": "GCC GENERIC",
    "id": "generic",
    "url": "/concepts/generic.html"
  },
  {
    "label": "Genero Business Development Language",
    "id": "genero",
    "url": "/concepts/genero.html"
  },
  {
    "label": "GeneXus",
    "id": "genexus",
    "url": "/concepts/genexus.html"
  },
  {
    "label": "Genie",
    "id": "genie",
    "url": "/concepts/genie.html"
  },
  {
    "label": "GEL Genius",
    "id": "genius-extension-language",
    "url": "/concepts/genius-extension-language.html"
  },
  {
    "label": "Genshi Text",
    "id": "genshi-text",
    "url": "/concepts/genshi-text.html"
  },
  {
    "label": "Genshi",
    "id": "genshi",
    "url": "/concepts/genshi.html"
  },
  {
    "label": "GENSTAT",
    "id": "genstat",
    "url": "/concepts/genstat.html"
  },
  {
    "label": "gentee",
    "id": "gentee",
    "url": "/concepts/gentee.html"
  },
  {
    "label": "Gentoo Ebuild",
    "id": "gentoo-ebuild",
    "url": "/concepts/gentoo-ebuild.html"
  },
  {
    "label": "GENTRAN 90",
    "id": "gentran-90",
    "url": "/concepts/gentran-90.html"
  },
  {
    "label": "GENTRAN",
    "id": "gentran",
    "url": "/concepts/gentran.html"
  },
  {
    "label": "Geography Markup Language",
    "id": "geo-ml",
    "url": "/concepts/geo-ml.html"
  },
  {
    "label": "GeoGebra",
    "id": "geogebra",
    "url": "/concepts/geogebra.html"
  },
  {
    "label": "GeoJSON",
    "id": "geojson",
    "url": "/concepts/geojson.html"
  },
  {
    "label": "GEORGE",
    "id": "george",
    "url": "/concepts/george.html"
  },
  {
    "label": "Gerald",
    "id": "gerald",
    "url": "/concepts/gerald.html"
  },
  {
    "label": "Gerber Image",
    "id": "gerber-image",
    "url": "/concepts/gerber-image.html"
  },
  {
    "label": "Gerbil Scheme",
    "id": "gerbil",
    "url": "/concepts/gerbil.html"
  },
  {
    "label": "GERMINAL",
    "id": "germinal",
    "url": "/concepts/germinal.html"
  },
  {
    "label": "Gettext Catalog",
    "id": "gettext",
    "url": "/concepts/gettext.html"
  },
  {
    "label": "GFA BASIC",
    "id": "gfa-basic",
    "url": "/concepts/gfa-basic.html"
  },
  {
    "label": "General feature format",
    "id": "gff-format",
    "url": "/concepts/gff-format.html"
  },
  {
    "label": "gfoo",
    "id": "gfoo",
    "url": "/concepts/gfoo.html"
  },
  {
    "label": "Gforth",
    "id": "gforth",
    "url": "/concepts/gforth.html"
  },
  {
    "label": "Google File System",
    "id": "gfs",
    "url": "/concepts/gfs.html"
  },
  {
    "label": "GHC",
    "id": "ghc",
    "url": "/concepts/ghc.html"
  },
  {
    "label": "Gherkin",
    "id": "gherkin",
    "url": "/concepts/gherkin.html"
  },
  {
    "label": "Ghidra",
    "id": "ghidra-decompiler",
    "url": "/concepts/ghidra-decompiler.html"
  },
  {
    "label": "Ghostscript",
    "id": "ghostscript",
    "url": "/concepts/ghostscript.html"
  },
  {
    "label": "GIF",
    "id": "gif-format",
    "url": "/concepts/gif-format.html"
  },
  {
    "label": "GCC GIMPLE",
    "id": "gimple",
    "url": "/concepts/gimple.html"
  },
  {
    "label": "gintonic",
    "id": "gintonic",
    "url": "/concepts/gintonic.html"
  },
  {
    "label": "Giotto",
    "id": "giotto",
    "url": "/concepts/giotto.html"
  },
  {
    "label": "Gist",
    "id": "gist",
    "url": "/concepts/gist.html"
  },
  {
    "label": "git-config",
    "id": "git-config",
    "url": "/concepts/git-config.html"
  },
  {
    "label": "Git",
    "id": "git",
    "url": "/concepts/git.html"
  },
  {
    "label": "gitignore",
    "id": "gitignore",
    "url": "/concepts/gitignore.html"
  },
  {
    "label": "GKS",
    "id": "gks",
    "url": "/concepts/gks.html"
  },
  {
    "label": "GLBasic",
    "id": "glbasic",
    "url": "/concepts/glbasic.html"
  },
  {
    "label": "gleam",
    "id": "gleam",
    "url": "/concepts/gleam.html"
  },
  {
    "label": "Glicol",
    "id": "glicol",
    "url": "/concepts/glicol.html"
  },
  {
    "label": "GLIDE",
    "id": "glide",
    "url": "/concepts/glide.html"
  },
  {
    "label": "Glish",
    "id": "glish",
    "url": "/concepts/glish.html"
  },
  {
    "label": "glitch-editor",
    "id": "glitch-editor",
    "url": "/concepts/glitch-editor.html"
  },
  {
    "label": "GLMS",
    "id": "glms",
    "url": "/concepts/glms.html"
  },
  {
    "label": "GLOSS",
    "id": "gloss",
    "url": "/concepts/gloss.html"
  },
  {
    "label": "GNU Linear Programming Kit",
    "id": "glpk-lib",
    "url": "/concepts/glpk-lib.html"
  },
  {
    "label": "GLSL",
    "id": "glsl",
    "url": "/concepts/glsl.html"
  },
  {
    "label": "GLU",
    "id": "glu",
    "url": "/concepts/glu.html"
  },
  {
    "label": "Glue-Nail",
    "id": "glue-nail",
    "url": "/concepts/glue-nail.html"
  },
  {
    "label": "gluon",
    "id": "gluon",
    "url": "/concepts/gluon.html"
  },
  {
    "label": "glush",
    "id": "glush",
    "url": "/concepts/glush.html"
  },
  {
    "label": "Glyph Bitmap Distribution Format",
    "id": "glyph-bitmap-distribution-format",
    "url": "/concepts/glyph-bitmap-distribution-format.html"
  },
  {
    "label": "Glyph",
    "id": "glyph",
    "url": "/concepts/glyph.html"
  },
  {
    "label": "Gnome Basic",
    "id": "gnome-basic",
    "url": "/concepts/gnome-basic.html"
  },
  {
    "label": "GNS",
    "id": "gns",
    "url": "/concepts/gns.html"
  },
  {
    "label": "GNU E",
    "id": "gnu-e",
    "url": "/concepts/gnu-e.html"
  },
  {
    "label": "gnu-rtl",
    "id": "gnu-rtl",
    "url": "/concepts/gnu-rtl.html"
  },
  {
    "label": "Gnuplot",
    "id": "gnuplot",
    "url": "/concepts/gnuplot.html"
  },
  {
    "label": "Go!",
    "id": "go-bang",
    "url": "/concepts/go-bang.html"
  },
  {
    "label": "Go",
    "id": "go",
    "url": "/concepts/go.html"
  },
  {
    "label": "Goal",
    "id": "goal",
    "url": "/concepts/goal.html"
  },
  {
    "label": "goby",
    "id": "goby",
    "url": "/concepts/goby.html"
  },
  {
    "label": "Gödel (Goedel)",
    "id": "godel",
    "url": "/concepts/godel.html"
  },
  {
    "label": "Godot",
    "id": "godot-game-engine",
    "url": "/concepts/godot-game-engine.html"
  },
  {
    "label": "Gofer",
    "id": "gofer",
    "url": "/concepts/gofer.html"
  },
  {
    "label": "gogs-editor",
    "id": "gogs-editor",
    "url": "/concepts/gogs-editor.html"
  },
  {
    "label": "GOLD",
    "id": "gold",
    "url": "/concepts/gold.html"
  },
  {
    "label": "GolfScript",
    "id": "golfscript",
    "url": "/concepts/golfscript.html"
  },
  {
    "label": "Golo",
    "id": "golo",
    "url": "/concepts/golo.html"
  },
  {
    "label": "Golog",
    "id": "golog",
    "url": "/concepts/golog.html"
  },
  {
    "label": "Google Apps Script",
    "id": "google-apps-script",
    "url": "/concepts/google-apps-script.html"
  },
  {
    "label": "Google Cloud SQL",
    "id": "google-cloud-mysql",
    "url": "/concepts/google-cloud-mysql.html"
  },
  {
    "label": "Google Cloud Platform",
    "id": "google-cloud",
    "url": "/concepts/google-cloud.html"
  },
  {
    "label": "google-data-studio-app",
    "id": "google-data-studio-app",
    "url": "/concepts/google-data-studio-app.html"
  },
  {
    "label": "Google Sheets",
    "id": "google-sheets-app",
    "url": "/concepts/google-sheets-app.html"
  },
  {
    "label": "goose",
    "id": "goose",
    "url": "/concepts/goose.html"
  },
  {
    "label": "Gopher",
    "id": "gopher-protocol",
    "url": "/concepts/gopher-protocol.html"
  },
  {
    "label": "GOQL",
    "id": "goql",
    "url": "/concepts/goql.html"
  },
  {
    "label": "GorillaScript",
    "id": "gorillascript",
    "url": "/concepts/gorillascript.html"
  },
  {
    "label": "GOSPEL",
    "id": "gospel",
    "url": "/concepts/gospel.html"
  },
  {
    "label": "Gosu",
    "id": "gosu",
    "url": "/concepts/gosu.html"
  },
  {
    "label": "General purpose",
    "id": "gp",
    "url": "/concepts/gp.html"
  },
  {
    "label": "GPDS",
    "id": "gpds",
    "url": "/concepts/gpds.html"
  },
  {
    "label": "GPGS",
    "id": "gpgs",
    "url": "/concepts/gpgs.html"
  },
  {
    "label": "GPS",
    "id": "gps",
    "url": "/concepts/gps.html"
  },
  {
    "label": "GPSS/360",
    "id": "gpss-360",
    "url": "/concepts/gpss-360.html"
  },
  {
    "label": "GPSS/85",
    "id": "gpss-85",
    "url": "/concepts/gpss-85.html"
  },
  {
    "label": "GPSS FORTRAN",
    "id": "gpss-fortran",
    "url": "/concepts/gpss-fortran.html"
  },
  {
    "label": "General Purpose Simulation System",
    "id": "gpss",
    "url": "/concepts/gpss.html"
  },
  {
    "label": "GQL",
    "id": "gql",
    "url": "/concepts/gql.html"
  },
  {
    "label": "GRAAL",
    "id": "graal",
    "url": "/concepts/graal.html"
  },
  {
    "label": "Grace",
    "id": "grace",
    "url": "/concepts/grace.html"
  },
  {
    "label": "GRAD Assistant",
    "id": "grad-assistant",
    "url": "/concepts/grad-assistant.html"
  },
  {
    "label": "Gradle",
    "id": "gradle",
    "url": "/concepts/gradle.html"
  },
  {
    "label": "grain",
    "id": "grain",
    "url": "/concepts/grain.html"
  },
  {
    "label": "Grammar",
    "id": "grammar",
    "url": "/concepts/grammar.html"
  },
  {
    "label": "Grammatical Framework",
    "id": "grammatical-framework",
    "url": "/concepts/grammatical-framework.html"
  },
  {
    "label": "GraphIt",
    "id": "graph-it",
    "url": "/concepts/graph-it.html"
  },
  {
    "label": "Graph Modeling Language",
    "id": "graph-modeling-language",
    "url": "/concepts/graph-modeling-language.html"
  },
  {
    "label": "Grapheasy",
    "id": "grapheasy",
    "url": "/concepts/grapheasy.html"
  },
  {
    "label": "Graphics BASIC",
    "id": "graphics-basic",
    "url": "/concepts/graphics-basic.html"
  },
  {
    "label": "GraphLog",
    "id": "graphlog",
    "url": "/concepts/graphlog.html"
  },
  {
    "label": "GraphML",
    "id": "graphml",
    "url": "/concepts/graphml.html"
  },
  {
    "label": "GRAPHOS",
    "id": "graphos",
    "url": "/concepts/graphos.html"
  },
  {
    "label": "GraphQL+-",
    "id": "graphql-plus-minus",
    "url": "/concepts/graphql-plus-minus.html"
  },
  {
    "label": "GraphQL Schema Definition Language",
    "id": "graphql-sdl",
    "url": "/concepts/graphql-sdl.html"
  },
  {
    "label": "GraphQL",
    "id": "graphql",
    "url": "/concepts/graphql.html"
  },
  {
    "label": "Graqula",
    "id": "graqula",
    "url": "/concepts/graqula.html"
  },
  {
    "label": "GRASS",
    "id": "grass",
    "url": "/concepts/grass.html"
  },
  {
    "label": "Gravity Equation",
    "id": "gravity-equation",
    "url": "/concepts/gravity-equation.html"
  },
  {
    "label": "gravity",
    "id": "gravity",
    "url": "/concepts/gravity.html"
  },
  {
    "label": "Greek numerals",
    "id": "greek-numerals",
    "url": "/concepts/greek-numerals.html"
  },
  {
    "label": "Green",
    "id": "green",
    "url": "/concepts/green.html"
  },
  {
    "label": "Greenplum",
    "id": "greenplum",
    "url": "/concepts/greenplum.html"
  },
  {
    "label": "Gremlin",
    "id": "gremlin",
    "url": "/concepts/gremlin.html"
  },
  {
    "label": "Gren",
    "id": "gren",
    "url": "/concepts/gren.html"
  },
  {
    "label": "grep",
    "id": "grep",
    "url": "/concepts/grep.html"
  },
  {
    "label": "grid-notation",
    "id": "grid-notation",
    "url": "/concepts/grid-notation.html"
  },
  {
    "label": "gridstudio-editor",
    "id": "gridstudio-editor",
    "url": "/concepts/gridstudio-editor.html"
  },
  {
    "label": "GRIN",
    "id": "grin",
    "url": "/concepts/grin.html"
  },
  {
    "label": "GRML",
    "id": "grml",
    "url": "/concepts/grml.html"
  },
  {
    "label": "groff",
    "id": "groff",
    "url": "/concepts/groff.html"
  },
  {
    "label": "GROOVE",
    "id": "groove",
    "url": "/concepts/groove.html"
  },
  {
    "label": "Groovy Server Pages",
    "id": "groovy-server-pages",
    "url": "/concepts/groovy-server-pages.html"
  },
  {
    "label": "Groovy",
    "id": "groovy",
    "url": "/concepts/groovy.html"
  },
  {
    "label": "GROUPLOG",
    "id": "grouplog",
    "url": "/concepts/grouplog.html"
  },
  {
    "label": "grunt",
    "id": "grunt",
    "url": "/concepts/grunt.html"
  },
  {
    "label": "GSBL",
    "id": "gsbl",
    "url": "/concepts/gsbl.html"
  },
  {
    "label": "GSQL",
    "id": "gsql",
    "url": "/concepts/gsql.html"
  },
  {
    "label": "Gene transfer format",
    "id": "gtf-format",
    "url": "/concepts/gtf-format.html"
  },
  {
    "label": "GUIDE",
    "id": "guide",
    "url": "/concepts/guide.html"
  },
  {
    "label": "GUIDO music notation",
    "id": "guido-music-notation",
    "url": "/concepts/guido-music-notation.html"
  },
  {
    "label": "Guile",
    "id": "guile",
    "url": "/concepts/guile.html"
  },
  {
    "label": "GNU Guix",
    "id": "guix",
    "url": "/concepts/guix.html"
  },
  {
    "label": "gura",
    "id": "gura",
    "url": "/concepts/gura.html"
  },
  {
    "label": "guru",
    "id": "guru",
    "url": "/concepts/guru.html"
  },
  {
    "label": "GVL",
    "id": "gvl",
    "url": "/concepts/gvl.html"
  },
  {
    "label": "GW-BASIC",
    "id": "gw-basic",
    "url": "/concepts/gw-basic.html"
  },
  {
    "label": "Gwion",
    "id": "gwion",
    "url": "/concepts/gwion.html"
  },
  {
    "label": "Guix Workflow Language",
    "id": "gwl",
    "url": "/concepts/gwl.html"
  },
  {
    "label": "GXL",
    "id": "gxl",
    "url": "/concepts/gxl.html"
  },
  {
    "label": "Gypsy",
    "id": "gypsy",
    "url": "/concepts/gypsy.html"
  },
  {
    "label": "Gzip",
    "id": "gzip",
    "url": "/concepts/gzip.html"
  },
  {
    "label": "h",
    "id": "h-lang",
    "url": "/concepts/h-lang.html"
  },
  {
    "label": "habit",
    "id": "habit",
    "url": "/concepts/habit.html"
  },
  {
    "label": "hac",
    "id": "hac",
    "url": "/concepts/hac.html"
  },
  {
    "label": "Hack",
    "id": "hack",
    "url": "/concepts/hack.html"
  },
  {
    "label": "hackage-pm",
    "id": "hackage-pm",
    "url": "/concepts/hackage-pm.html"
  },
  {
    "label": "Hackett",
    "id": "hackett",
    "url": "/concepts/hackett.html"
  },
  {
    "label": "hackppl",
    "id": "hackppl",
    "url": "/concepts/hackppl.html"
  },
  {
    "label": "hacspec",
    "id": "hacspec",
    "url": "/concepts/hacspec.html"
  },
  {
    "label": "HAGGIS",
    "id": "haggis",
    "url": "/concepts/haggis.html"
  },
  {
    "label": "hakaru",
    "id": "hakaru",
    "url": "/concepts/hakaru.html"
  },
  {
    "label": "HAL Format",
    "id": "hal-format",
    "url": "/concepts/hal-format.html"
  },
  {
    "label": "HAL/S",
    "id": "hal-s",
    "url": "/concepts/hal-s.html"
  },
  {
    "label": "Halide",
    "id": "halide",
    "url": "/concepts/halide.html"
  },
  {
    "label": "Ham",
    "id": "ham",
    "url": "/concepts/ham.html"
  },
  {
    "label": "hamdown",
    "id": "hamdown",
    "url": "/concepts/hamdown.html"
  },
  {
    "label": "HAML",
    "id": "haml",
    "url": "/concepts/haml.html"
  },
  {
    "label": "hamler",
    "id": "hamler",
    "url": "/concepts/hamler.html"
  },
  {
    "label": "Hancock",
    "id": "hancock",
    "url": "/concepts/hancock.html"
  },
  {
    "label": "Handel-C",
    "id": "handel-c",
    "url": "/concepts/handel-c.html"
  },
  {
    "label": "Handlebars",
    "id": "handlebars",
    "url": "/concepts/handlebars.html"
  },
  {
    "label": "Hank",
    "id": "hank",
    "url": "/concepts/hank.html"
  },
  {
    "label": "Harbour",
    "id": "harbour",
    "url": "/concepts/harbour.html"
  },
  {
    "label": "Hare",
    "id": "hare",
    "url": "/concepts/hare.html"
  },
  {
    "label": "harlan",
    "id": "harlan",
    "url": "/concepts/harlan.html"
  },
  {
    "label": "HARVEY",
    "id": "harvey",
    "url": "/concepts/harvey.html"
  },
  {
    "label": "Harwell-Boeing file format",
    "id": "harwell-boeing-format",
    "url": "/concepts/harwell-boeing-format.html"
  },
  {
    "label": "IBM HAScript",
    "id": "hascript",
    "url": "/concepts/hascript.html"
  },
  {
    "label": "hashlink",
    "id": "hashlink",
    "url": "/concepts/hashlink.html"
  },
  {
    "label": "Haskell#",
    "id": "haskell-sharp",
    "url": "/concepts/haskell-sharp.html"
  },
  {
    "label": "Haskell",
    "id": "haskell",
    "url": "/concepts/haskell.html"
  },
  {
    "label": "hasklig",
    "id": "hasklig",
    "url": "/concepts/hasklig.html"
  },
  {
    "label": "HASL",
    "id": "hasl",
    "url": "/concepts/hasl.html"
  },
  {
    "label": "haste",
    "id": "haste",
    "url": "/concepts/haste.html"
  },
  {
    "label": "Haxe",
    "id": "haxe",
    "url": "/concepts/haxe.html"
  },
  {
    "label": "Haxe Library Manager",
    "id": "haxelibs-pm",
    "url": "/concepts/haxelibs-pm.html"
  },
  {
    "label": "HAYSTAQ",
    "id": "haystaq",
    "url": "/concepts/haystaq.html"
  },
  {
    "label": "hazel",
    "id": "hazel",
    "url": "/concepts/hazel.html"
  },
  {
    "label": "Hbasic",
    "id": "hbasic",
    "url": "/concepts/hbasic.html"
  },
  {
    "label": "HCard",
    "id": "hcard",
    "url": "/concepts/hcard.html"
  },
  {
    "label": "HCCB",
    "id": "hccb",
    "url": "/concepts/hccb.html"
  },
  {
    "label": "HCL",
    "id": "hcl",
    "url": "/concepts/hcl.html"
  },
  {
    "label": "Hierarchical Data Format",
    "id": "hdf",
    "url": "/concepts/hdf.html"
  },
  {
    "label": "Hadoop Distributed File System",
    "id": "hdfs",
    "url": "/concepts/hdfs.html"
  },
  {
    "label": "HDMI",
    "id": "hdmi-standard",
    "url": "/concepts/hdmi-standard.html"
  },
  {
    "label": "Header Dictionary Triples",
    "id": "hdt",
    "url": "/concepts/hdt.html"
  },
  {
    "label": "heap.coffee",
    "id": "heap.coffee",
    "url": "/concepts/heap.coffee.html"
  },
  {
    "label": "hecl",
    "id": "hecl",
    "url": "/concepts/hecl.html"
  },
  {
    "label": "Hedy",
    "id": "hedy",
    "url": "/concepts/hedy.html"
  },
  {
    "label": "HEIC",
    "id": "heic",
    "url": "/concepts/heic.html"
  },
  {
    "label": "HeLang",
    "id": "helang",
    "url": "/concepts/helang.html"
  },
  {
    "label": "helena",
    "id": "helena",
    "url": "/concepts/helena.html"
  },
  {
    "label": "helium",
    "id": "helium",
    "url": "/concepts/helium.html"
  },
  {
    "label": "hello",
    "id": "hello",
    "url": "/concepts/hello.html"
  },
  {
    "label": "HELPER",
    "id": "helper",
    "url": "/concepts/helper.html"
  },
  {
    "label": "henk",
    "id": "henk",
    "url": "/concepts/henk.html"
  },
  {
    "label": "HERAKLIT",
    "id": "heraklit",
    "url": "/concepts/heraklit.html"
  },
  {
    "label": "Herbrand",
    "id": "herbrand",
    "url": "/concepts/herbrand.html"
  },
  {
    "label": "Hermes",
    "id": "hermes",
    "url": "/concepts/hermes.html"
  },
  {
    "label": "Heron",
    "id": "heron-lang",
    "url": "/concepts/heron-lang.html"
  },
  {
    "label": "Heron",
    "id": "heron",
    "url": "/concepts/heron.html"
  },
  {
    "label": "Hex",
    "id": "hex-pm",
    "url": "/concepts/hex-pm.html"
  },
  {
    "label": "Hex-Rays",
    "id": "hex-rays",
    "url": "/concepts/hex-rays.html"
  },
  {
    "label": "Qualcomm Hexagon",
    "id": "hexagon",
    "url": "/concepts/hexagon.html"
  },
  {
    "label": "hexagony",
    "id": "hexagony",
    "url": "/concepts/hexagony.html"
  },
  {
    "label": "HFS Plus",
    "id": "hfs-plus",
    "url": "/concepts/hfs-plus.html"
  },
  {
    "label": "Hierarchical File System",
    "id": "hfs",
    "url": "/concepts/hfs.html"
  },
  {
    "label": "HHVM",
    "id": "hhvm",
    "url": "/concepts/hhvm.html"
  },
  {
    "label": "Hi-Visual",
    "id": "hi-visual",
    "url": "/concepts/hi-visual.html"
  },
  {
    "label": "High Tech BASIC",
    "id": "high-tech-basic",
    "url": "/concepts/high-tech-basic.html"
  },
  {
    "label": "highlight.js",
    "id": "highlightjs",
    "url": "/concepts/highlightjs.html"
  },
  {
    "label": "hilbert",
    "id": "hilbert",
    "url": "/concepts/hilbert.html"
  },
  {
    "label": "Hilltop",
    "id": "hilltop-lang",
    "url": "/concepts/hilltop-lang.html"
  },
  {
    "label": "hilvl",
    "id": "hilvl",
    "url": "/concepts/hilvl.html"
  },
  {
    "label": "Hina",
    "id": "hina",
    "url": "/concepts/hina.html"
  },
  {
    "label": "HiQ",
    "id": "hiq",
    "url": "/concepts/hiq.html"
  },
  {
    "label": "hivemind",
    "id": "hivemind",
    "url": "/concepts/hivemind.html"
  },
  {
    "label": "HiveQL",
    "id": "hiveql",
    "url": "/concepts/hiveql.html"
  },
  {
    "label": "Hjson",
    "id": "hjson",
    "url": "/concepts/hjson.html"
  },
  {
    "label": "HL7",
    "id": "hl7",
    "url": "/concepts/hl7.html"
  },
  {
    "label": "High Level Assembly",
    "id": "hla",
    "url": "/concepts/hla.html"
  },
  {
    "label": "HLASM",
    "id": "hlasm",
    "url": "/concepts/hlasm.html"
  },
  {
    "label": "HLSL",
    "id": "hlsl",
    "url": "/concepts/hlsl.html"
  },
  {
    "label": "High-Level Virtual Machine",
    "id": "hlvm",
    "url": "/concepts/hlvm.html"
  },
  {
    "label": "HMMM",
    "id": "hmmm",
    "url": "/concepts/hmmm.html"
  },
  {
    "label": "HMSL",
    "id": "hmsl",
    "url": "/concepts/hmsl.html"
  },
  {
    "label": "hobbes",
    "id": "hobbes",
    "url": "/concepts/hobbes.html"
  },
  {
    "label": "Hocon",
    "id": "hocon",
    "url": "/concepts/hocon.html"
  },
  {
    "label": "Hodor",
    "id": "hodor",
    "url": "/concepts/hodor.html"
  },
  {
    "label": "HOL",
    "id": "hol",
    "url": "/concepts/hol.html"
  },
  {
    "label": "HOLCF",
    "id": "holcf",
    "url": "/concepts/holcf.html"
  },
  {
    "label": "Holo",
    "id": "holo",
    "url": "/concepts/holo.html"
  },
  {
    "label": "holonforth",
    "id": "holonforth",
    "url": "/concepts/holonforth.html"
  },
  {
    "label": "holyc",
    "id": "holyc",
    "url": "/concepts/holyc.html"
  },
  {
    "label": "Homa",
    "id": "homa",
    "url": "/concepts/homa.html"
  },
  {
    "label": "Homebrew",
    "id": "homebrew-pm",
    "url": "/concepts/homebrew-pm.html"
  },
  {
    "label": "Homespring",
    "id": "homespring",
    "url": "/concepts/homespring.html"
  },
  {
    "label": "honu",
    "id": "honu",
    "url": "/concepts/honu.html"
  },
  {
    "label": "Hook",
    "id": "hook",
    "url": "/concepts/hook.html"
  },
  {
    "label": "hoon",
    "id": "hoon",
    "url": "/concepts/hoon.html"
  },
  {
    "label": "hoot-smalltalk",
    "id": "hoot-smalltalk",
    "url": "/concepts/hoot-smalltalk.html"
  },
  {
    "label": "hop",
    "id": "hop",
    "url": "/concepts/hop.html"
  },
  {
    "label": "HOPE",
    "id": "hope",
    "url": "/concepts/hope.html"
  },
  {
    "label": "Hopscotch",
    "id": "hopscotch",
    "url": "/concepts/hopscotch.html"
  },
  {
    "label": "Horse64",
    "id": "horse64",
    "url": "/concepts/horse64.html"
  },
  {
    "label": "Hot Cocoa Lisp",
    "id": "hotcocoalisp",
    "url": "/concepts/hotcocoalisp.html"
  },
  {
    "label": "Hotdog",
    "id": "hotdog",
    "url": "/concepts/hotdog.html"
  },
  {
    "label": "HP BASIC for OpenVMS",
    "id": "hp-basic-for-openvms",
    "url": "/concepts/hp-basic-for-openvms.html"
  },
  {
    "label": "HP-GL",
    "id": "hp-gl",
    "url": "/concepts/hp-gl.html"
  },
  {
    "label": "HP-PASCAL",
    "id": "hp-pascal",
    "url": "/concepts/hp-pascal.html"
  },
  {
    "label": "HP Time-Shared BASIC",
    "id": "hp-time-shared-basic",
    "url": "/concepts/hp-time-shared-basic.html"
  },
  {
    "label": "H++",
    "id": "hpp",
    "url": "/concepts/hpp.html"
  },
  {
    "label": "HPRL",
    "id": "hprl",
    "url": "/concepts/hprl.html"
  },
  {
    "label": "hr-code",
    "id": "hr-code",
    "url": "/concepts/hr-code.html"
  },
  {
    "label": "hrqr",
    "id": "hrqr",
    "url": "/concepts/hrqr.html"
  },
  {
    "label": "hsaml-format",
    "id": "hsaml-format",
    "url": "/concepts/hsaml-format.html"
  },
  {
    "label": "HScript",
    "id": "hscript",
    "url": "/concepts/hscript.html"
  },
  {
    "label": "HSL",
    "id": "hsl",
    "url": "/concepts/hsl.html"
  },
  {
    "label": "HSML",
    "id": "hsml",
    "url": "/concepts/hsml.html"
  },
  {
    "label": "Hspec",
    "id": "hspec",
    "url": "/concepts/hspec.html"
  },
  {
    "label": "HTEL",
    "id": "htel",
    "url": "/concepts/htel.html"
  },
  {
    "label": "HTML",
    "id": "html",
    "url": "/concepts/html.html"
  },
  {
    "label": "htmx",
    "id": "htmx",
    "url": "/concepts/htmx.html"
  },
  {
    "label": "HTTP/2",
    "id": "http-2",
    "url": "/concepts/http-2.html"
  },
  {
    "label": "HTTP/3",
    "id": "http-3",
    "url": "/concepts/http-3.html"
  },
  {
    "label": "HTTP",
    "id": "http",
    "url": "/concepts/http.html"
  },
  {
    "label": "httplang",
    "id": "httplang",
    "url": "/concepts/httplang.html"
  },
  {
    "label": "huginn",
    "id": "huginn",
    "url": "/concepts/huginn.html"
  },
  {
    "label": "HUGO",
    "id": "hugo",
    "url": "/concepts/hugo.html"
  },
  {
    "label": "HuJSON",
    "id": "hujson",
    "url": "/concepts/hujson.html"
  },
  {
    "label": "humanhash-hash-function",
    "id": "humanhash-hash-function",
    "url": "/concepts/humanhash-hash-function.html"
  },
  {
    "label": "Hummingbird QuickScript",
    "id": "hummingbird-quickscript",
    "url": "/concepts/hummingbird-quickscript.html"
  },
  {
    "label": "hurl",
    "id": "hurl",
    "url": "/concepts/hurl.html"
  },
  {
    "label": "Hush",
    "id": "hush",
    "url": "/concepts/hush.html"
  },
  {
    "label": "HuwCode",
    "id": "huwcode",
    "url": "/concepts/huwcode.html"
  },
  {
    "label": "HXML",
    "id": "hxml",
    "url": "/concepts/hxml.html"
  },
  {
    "label": "Hy",
    "id": "hy",
    "url": "/concepts/hy.html"
  },
  {
    "label": "Hybrid",
    "id": "hybrid",
    "url": "/concepts/hybrid.html"
  },
  {
    "label": "HyCom",
    "id": "hycom",
    "url": "/concepts/hycom.html"
  },
  {
    "label": "HYPAC",
    "id": "hypac",
    "url": "/concepts/hypac.html"
  },
  {
    "label": "Hyper Basic",
    "id": "hyper-basic",
    "url": "/concepts/hyper-basic.html"
  },
  {
    "label": "HyperCard",
    "id": "hypercard",
    "url": "/concepts/hypercard.html"
  },
  {
    "label": "Hyperflow",
    "id": "hyperflow",
    "url": "/concepts/hyperflow.html"
  },
  {
    "label": "HyperFun",
    "id": "hyperfun",
    "url": "/concepts/hyperfun.html"
  },
  {
    "label": "Hyperlisp",
    "id": "hyperlisp",
    "url": "/concepts/hyperlisp.html"
  },
  {
    "label": "Hyperlog",
    "id": "hyperlog",
    "url": "/concepts/hyperlog.html"
  },
  {
    "label": "Hyperscript",
    "id": "hyperscript-lang",
    "url": "/concepts/hyperscript-lang.html"
  },
  {
    "label": "Hyperscript",
    "id": "hyperscript",
    "url": "/concepts/hyperscript.html"
  },
  {
    "label": "HyperTalk",
    "id": "hypertalk",
    "url": "/concepts/hypertalk.html"
  },
  {
    "label": "HyPhy",
    "id": "hyphy",
    "url": "/concepts/hyphy.html"
  },
  {
    "label": "HyTime",
    "id": "hytime",
    "url": "/concepts/hytime.html"
  },
  {
    "label": "HYTRAN",
    "id": "hytran",
    "url": "/concepts/hytran.html"
  },
  {
    "label": "I-expressions",
    "id": "i-expressions",
    "url": "/concepts/i-expressions.html"
  },
  {
    "label": "I",
    "id": "i",
    "url": "/concepts/i.html"
  },
  {
    "label": "IA-32",
    "id": "ia-32",
    "url": "/concepts/ia-32.html"
  },
  {
    "label": "IAL",
    "id": "ial",
    "url": "/concepts/ial.html"
  },
  {
    "label": "IAM",
    "id": "iam",
    "url": "/concepts/iam.html"
  },
  {
    "label": "IB-Templog",
    "id": "ib-templog",
    "url": "/concepts/ib-templog.html"
  },
  {
    "label": "IBEX",
    "id": "ibex",
    "url": "/concepts/ibex.html"
  },
  {
    "label": "IBM 1401 Symbolic Programming System",
    "id": "ibm-1401-symbolic-programming-system",
    "url": "/concepts/ibm-1401-symbolic-programming-system.html"
  },
  {
    "label": "IBM BASIC",
    "id": "ibm-basic",
    "url": "/concepts/ibm-basic.html"
  },
  {
    "label": "IBM BASICA",
    "id": "ibm-basica",
    "url": "/concepts/ibm-basica.html"
  },
  {
    "label": "IBM DB2",
    "id": "ibm-db2",
    "url": "/concepts/ibm-db2.html"
  },
  {
    "label": "GML",
    "id": "ibm-gml",
    "url": "/concepts/ibm-gml.html"
  },
  {
    "label": "IBM i Control Language",
    "id": "ibm-i-control-language",
    "url": "/concepts/ibm-i-control-language.html"
  },
  {
    "label": "IBM Logo",
    "id": "ibm-logo",
    "url": "/concepts/ibm-logo.html"
  },
  {
    "label": "IBM Rational SQABasic",
    "id": "ibm-rational-sqabasic",
    "url": "/concepts/ibm-rational-sqabasic.html"
  },
  {
    "label": "RPG",
    "id": "ibm-rpg",
    "url": "/concepts/ibm-rpg.html"
  },
  {
    "label": "ibm-system-38-language",
    "id": "ibm-system-38-language",
    "url": "/concepts/ibm-system-38-language.html"
  },
  {
    "label": "Ibuki CL",
    "id": "ibuki-cl",
    "url": "/concepts/ibuki-cl.html"
  },
  {
    "label": "iCalendar",
    "id": "icalendar-format",
    "url": "/concepts/icalendar-format.html"
  },
  {
    "label": "icarus",
    "id": "icarus",
    "url": "/concepts/icarus.html"
  },
  {
    "label": "ICD-10-CM diagnosis",
    "id": "icd",
    "url": "/concepts/icd.html"
  },
  {
    "label": "IcedCoffeeScript",
    "id": "icedcoffeescript",
    "url": "/concepts/icedcoffeescript.html"
  },
  {
    "label": "Integrated Civil Engineering System",
    "id": "ices-system",
    "url": "/concepts/ices-system.html"
  },
  {
    "label": "ICETRAN",
    "id": "icetran",
    "url": "/concepts/icetran.html"
  },
  {
    "label": "Interactive C Interpreter",
    "id": "ici",
    "url": "/concepts/ici.html"
  },
  {
    "label": "ICML",
    "id": "icml",
    "url": "/concepts/icml.html"
  },
  {
    "label": "Icon",
    "id": "icon",
    "url": "/concepts/icon.html"
  },
  {
    "label": "ICOT",
    "id": "icot",
    "url": "/concepts/icot.html"
  },
  {
    "label": "Irvine Dataflow",
    "id": "id",
    "url": "/concepts/id.html"
  },
  {
    "label": "Idio",
    "id": "idio",
    "url": "/concepts/idio.html"
  },
  {
    "label": "IDL specification language",
    "id": "idl-sl",
    "url": "/concepts/idl-sl.html"
  },
  {
    "label": "IDL",
    "id": "idl",
    "url": "/concepts/idl.html"
  },
  {
    "label": "Idris",
    "id": "idris",
    "url": "/concepts/idris.html"
  },
  {
    "label": "Integrated Data Store",
    "id": "ids",
    "url": "/concepts/ids.html"
  },
  {
    "label": "idyll",
    "id": "idyll",
    "url": "/concepts/idyll.html"
  },
  {
    "label": "IFO",
    "id": "ifo",
    "url": "/concepts/ifo.html"
  },
  {
    "label": "IFPS",
    "id": "ifps",
    "url": "/concepts/ifps.html"
  },
  {
    "label": "IGOR Pro",
    "id": "igor-pro",
    "url": "/concepts/igor-pro.html"
  },
  {
    "label": "Intuit Interchange Format",
    "id": "iif",
    "url": "/concepts/iif.html"
  },
  {
    "label": "iikuse",
    "id": "iikuse",
    "url": "/concepts/iikuse.html"
  },
  {
    "label": "IITRAN",
    "id": "iitran",
    "url": "/concepts/iitran.html"
  },
  {
    "label": "Ikarus Scheme implementation",
    "id": "ikarus",
    "url": "/concepts/ikarus.html"
  },
  {
    "label": "ILBM",
    "id": "ilbm",
    "url": "/concepts/ilbm.html"
  },
  {
    "label": "ILU",
    "id": "ilu",
    "url": "/concepts/ilu.html"
  },
  {
    "label": "ILX",
    "id": "ilx",
    "url": "/concepts/ilx.html"
  },
  {
    "label": "IMac",
    "id": "imac-machine",
    "url": "/concepts/imac-machine.html"
  },
  {
    "label": "IMAGE",
    "id": "image",
    "url": "/concepts/image.html"
  },
  {
    "label": "Imaginary Number Equation",
    "id": "imaginary-number-equation",
    "url": "/concepts/imaginary-number-equation.html"
  },
  {
    "label": "Imandra Protocol Language",
    "id": "imandra",
    "url": "/concepts/imandra.html"
  },
  {
    "label": "IMAP",
    "id": "imap-protocol",
    "url": "/concepts/imap-protocol.html"
  },
  {
    "label": "Imba",
    "id": "imba",
    "url": "/concepts/imba.html"
  },
  {
    "label": "imf",
    "id": "imf",
    "url": "/concepts/imf.html"
  },
  {
    "label": "imp-lang",
    "id": "imp-lang",
    "url": "/concepts/imp-lang.html"
  },
  {
    "label": "IMP",
    "id": "imp",
    "url": "/concepts/imp.html"
  },
  {
    "label": "IMP72",
    "id": "imp72",
    "url": "/concepts/imp72.html"
  },
  {
    "label": "Impala",
    "id": "impala",
    "url": "/concepts/impala.html"
  },
  {
    "label": "Industrial Modeling and Programming Language",
    "id": "impl",
    "url": "/concepts/impl.html"
  },
  {
    "label": "Ina Jo",
    "id": "ina-jo",
    "url": "/concepts/ina-jo.html"
  },
  {
    "label": "INC",
    "id": "inc",
    "url": "/concepts/inc.html"
  },
  {
    "label": "International Chemical Identifier",
    "id": "inchi",
    "url": "/concepts/inchi.html"
  },
  {
    "label": "Incipit",
    "id": "incipit",
    "url": "/concepts/incipit.html"
  },
  {
    "label": "Indental",
    "id": "indental",
    "url": "/concepts/indental.html"
  },
  {
    "label": "INFER",
    "id": "infer",
    "url": "/concepts/infer.html"
  },
  {
    "label": "InfiniBand",
    "id": "infiniband-standard",
    "url": "/concepts/infiniband-standard.html"
  },
  {
    "label": "InfluxDB",
    "id": "influxdb",
    "url": "/concepts/influxdb.html"
  },
  {
    "label": "INFOLOG",
    "id": "infolog",
    "url": "/concepts/infolog.html"
  },
  {
    "label": "Inform",
    "id": "inform",
    "url": "/concepts/inform.html"
  },
  {
    "label": "Information Algebra",
    "id": "information-algebra",
    "url": "/concepts/information-algebra.html"
  },
  {
    "label": "Information Processing Language",
    "id": "information-processing-language",
    "url": "/concepts/information-processing-language.html"
  },
  {
    "label": "Information Theory Equation",
    "id": "information-theory-equation",
    "url": "/concepts/information-theory-equation.html"
  },
  {
    "label": "IBM Informix-4GL",
    "id": "informix",
    "url": "/concepts/informix.html"
  },
  {
    "label": "infusion-framework",
    "id": "infusion-framework",
    "url": "/concepts/infusion-framework.html"
  },
  {
    "label": "Ingres database",
    "id": "ingres",
    "url": "/concepts/ingres.html"
  },
  {
    "label": "Ini",
    "id": "ini",
    "url": "/concepts/ini.html"
  },
  {
    "label": "ink-lang",
    "id": "ink-lang",
    "url": "/concepts/ink-lang.html"
  },
  {
    "label": "ink",
    "id": "ink",
    "url": "/concepts/ink.html"
  },
  {
    "label": "inko",
    "id": "inko",
    "url": "/concepts/inko.html"
  },
  {
    "label": "INMAGIC",
    "id": "inmagic",
    "url": "/concepts/inmagic.html"
  },
  {
    "label": "Inno Setup",
    "id": "inno-setup",
    "url": "/concepts/inno-setup.html"
  },
  {
    "label": "INQUIRE",
    "id": "inquire",
    "url": "/concepts/inquire.html"
  },
  {
    "label": "Inscan",
    "id": "inscan",
    "url": "/concepts/inscan.html"
  },
  {
    "label": "INSIGHT",
    "id": "insight",
    "url": "/concepts/insight.html"
  },
  {
    "label": "Insitux",
    "id": "insitux",
    "url": "/concepts/insitux.html"
  },
  {
    "label": "Instruction list",
    "id": "instruction-list",
    "url": "/concepts/instruction-list.html"
  },
  {
    "label": "Integer BASIC",
    "id": "integer-basic",
    "url": "/concepts/integer-basic.html"
  },
  {
    "label": "Integral Equation",
    "id": "integral-equation",
    "url": "/concepts/integral-equation.html"
  },
  {
    "label": "intellijidea-editor",
    "id": "intellijidea-editor",
    "url": "/concepts/intellijidea-editor.html"
  },
  {
    "label": "INTERACTIVE",
    "id": "interactive",
    "url": "/concepts/interactive.html"
  },
  {
    "label": "InterBase",
    "id": "interbase",
    "url": "/concepts/interbase.html"
  },
  {
    "label": "INTERCAL",
    "id": "intercal",
    "url": "/concepts/intercal.html"
  },
  {
    "label": "INTERCELLAS",
    "id": "intercellas",
    "url": "/concepts/intercellas.html"
  },
  {
    "label": "Interchange File Format",
    "id": "interchange-file-format",
    "url": "/concepts/interchange-file-format.html"
  },
  {
    "label": "InterCONS",
    "id": "intercons",
    "url": "/concepts/intercons.html"
  },
  {
    "label": "Interleaved Notation",
    "id": "interleaved-notation",
    "url": "/concepts/interleaved-notation.html"
  },
  {
    "label": "Interlisp-VAX",
    "id": "interlisp-vax",
    "url": "/concepts/interlisp-vax.html"
  },
  {
    "label": "Interlisp",
    "id": "interlisp",
    "url": "/concepts/interlisp.html"
  },
  {
    "label": "Interpress",
    "id": "interpress",
    "url": "/concepts/interpress.html"
  },
  {
    "label": "Interscript",
    "id": "interscript",
    "url": "/concepts/interscript.html"
  },
  {
    "label": "InterSystems Caché",
    "id": "intersystems-cache",
    "url": "/concepts/intersystems-cache.html"
  },
  {
    "label": "IPL",
    "id": "intuitionistic",
    "url": "/concepts/intuitionistic.html"
  },
  {
    "label": "invokator",
    "id": "invokator",
    "url": "/concepts/invokator.html"
  },
  {
    "label": "Io",
    "id": "io",
    "url": "/concepts/io.html"
  },
  {
    "label": "Iode",
    "id": "iode",
    "url": "/concepts/iode.html"
  },
  {
    "label": "Ioke",
    "id": "ioke",
    "url": "/concepts/ioke.html"
  },
  {
    "label": "Ion Schema Language",
    "id": "ion-schema",
    "url": "/concepts/ion-schema.html"
  },
  {
    "label": "Ion",
    "id": "ion",
    "url": "/concepts/ion.html"
  },
  {
    "label": "iOS",
    "id": "ios",
    "url": "/concepts/ios.html"
  },
  {
    "label": "Iota-and-jot",
    "id": "iota-and-jot",
    "url": "/concepts/iota-and-jot.html"
  },
  {
    "label": "iota",
    "id": "iota",
    "url": "/concepts/iota.html"
  },
  {
    "label": "IP Pascal",
    "id": "ip-pascal",
    "url": "/concepts/ip-pascal.html"
  },
  {
    "label": "IPad",
    "id": "ipad-machine",
    "url": "/concepts/ipad-machine.html"
  },
  {
    "label": "Information Presentation Facility",
    "id": "ipf",
    "url": "/concepts/ipf.html"
  },
  {
    "label": "InterPlanetary File System",
    "id": "ipfs",
    "url": "/concepts/ipfs.html"
  },
  {
    "label": "IPhone",
    "id": "iphone-machine",
    "url": "/concepts/iphone-machine.html"
  },
  {
    "label": "IPL-V",
    "id": "ipl-v",
    "url": "/concepts/ipl-v.html"
  },
  {
    "label": "IpTables Rope",
    "id": "iptables-rope",
    "url": "/concepts/iptables-rope.html"
  },
  {
    "label": "IPTSCRAE",
    "id": "iptscrae",
    "url": "/concepts/iptscrae.html"
  },
  {
    "label": "IPv4",
    "id": "ipv4",
    "url": "/concepts/ipv4.html"
  },
  {
    "label": "IQF",
    "id": "iqf",
    "url": "/concepts/iqf.html"
  },
  {
    "label": "iqr",
    "id": "iqr",
    "url": "/concepts/iqr.html"
  },
  {
    "label": "IRC chat logs",
    "id": "irc-log",
    "url": "/concepts/irc-log.html"
  },
  {
    "label": "ircis",
    "id": "ircis",
    "url": "/concepts/ircis.html"
  },
  {
    "label": "Isabelle-91",
    "id": "isabelle-91",
    "url": "/concepts/isabelle-91.html"
  },
  {
    "label": "Isabelle/HOL",
    "id": "isabelle-hol",
    "url": "/concepts/isabelle-hol.html"
  },
  {
    "label": "Isabelle",
    "id": "isabelle",
    "url": "/concepts/isabelle.html"
  },
  {
    "label": "ISAC",
    "id": "isac",
    "url": "/concepts/isac.html"
  },
  {
    "label": "ISBL",
    "id": "isbl",
    "url": "/concepts/isbl.html"
  },
  {
    "label": "ISBN",
    "id": "isbn",
    "url": "/concepts/isbn.html"
  },
  {
    "label": "iScript",
    "id": "iscript",
    "url": "/concepts/iscript.html"
  },
  {
    "label": "ISETL",
    "id": "isetl",
    "url": "/concepts/isetl.html"
  },
  {
    "label": "ISIS",
    "id": "isis",
    "url": "/concepts/isis.html"
  },
  {
    "label": "ISLISP",
    "id": "islisp",
    "url": "/concepts/islisp.html"
  },
  {
    "label": "ISO 8601",
    "id": "iso-8601",
    "url": "/concepts/iso-8601.html"
  },
  {
    "label": "ISPL",
    "id": "ispl",
    "url": "/concepts/ispl.html"
  },
  {
    "label": "International System of Quantities",
    "id": "isq",
    "url": "/concepts/isq.html"
  },
  {
    "label": "ISWIM",
    "id": "iswim",
    "url": "/concepts/iswim.html"
  },
  {
    "label": "IT",
    "id": "it",
    "url": "/concepts/it.html"
  },
  {
    "label": "Iterm2",
    "id": "iterm2",
    "url": "/concepts/iterm2.html"
  },
  {
    "label": "ITL",
    "id": "itl",
    "url": "/concepts/itl.html"
  },
  {
    "label": "IVTRAN",
    "id": "ivtran",
    "url": "/concepts/ivtran.html"
  },
  {
    "id": "ivy",
    "url": "/concepts/ivy.html"
  },
  {
    "label": "Invisible XML",
    "id": "ixml",
    "url": "/concepts/ixml.html"
  },
  {
    "label": "Izibasic",
    "id": "izibasic",
    "url": "/concepts/izibasic.html"
  },
  {
    "label": "J",
    "id": "j",
    "url": "/concepts/j.html"
  },
  {
    "label": "JACAL",
    "id": "jacal",
    "url": "/concepts/jacal.html"
  },
  {
    "label": "JACL",
    "id": "jacl",
    "url": "/concepts/jacl.html"
  },
  {
    "label": "JADE",
    "id": "jade",
    "url": "/concepts/jade.html"
  },
  {
    "label": "JAI",
    "id": "jai",
    "url": "/concepts/jai.html"
  },
  {
    "label": "Jakt",
    "id": "jakt",
    "url": "/concepts/jakt.html"
  },
  {
    "label": "JAL compiler",
    "id": "jal-compiler",
    "url": "/concepts/jal-compiler.html"
  },
  {
    "label": "Jammy",
    "id": "jammy",
    "url": "/concepts/jammy.html"
  },
  {
    "label": "janet",
    "id": "janet",
    "url": "/concepts/janet.html"
  },
  {
    "label": "Jank",
    "id": "jank",
    "url": "/concepts/jank.html"
  },
  {
    "label": "Janus",
    "id": "janus-lang",
    "url": "/concepts/janus-lang.html"
  },
  {
    "label": "Janus",
    "id": "janus-programming-language",
    "url": "/concepts/janus-programming-language.html"
  },
  {
    "label": "Jargon",
    "id": "jargon",
    "url": "/concepts/jargon.html"
  },
  {
    "label": "Jasmin",
    "id": "jasmin",
    "url": "/concepts/jasmin.html"
  },
  {
    "label": "jasmine",
    "id": "jasmine",
    "url": "/concepts/jasmine.html"
  },
  {
    "label": "jasper",
    "id": "jasper",
    "url": "/concepts/jasper.html"
  },
  {
    "label": "Just Another Scripting Syntax",
    "id": "jass",
    "url": "/concepts/jass.html"
  },
  {
    "label": "Java Bytecode",
    "id": "java-bytecode",
    "url": "/concepts/java-bytecode.html"
  },
  {
    "label": "Java EE version history",
    "id": "java-ee-version-history",
    "url": "/concepts/java-ee-version-history.html"
  },
  {
    "label": "Java Properties",
    "id": "java-properties",
    "url": "/concepts/java-properties.html"
  },
  {
    "label": "JSP",
    "id": "java-server-pages",
    "url": "/concepts/java-server-pages.html"
  },
  {
    "label": "Java",
    "id": "java",
    "url": "/concepts/java.html"
  },
  {
    "label": "JavaCC",
    "id": "javacc",
    "url": "/concepts/javacc.html"
  },
  {
    "label": "JavaFX Script",
    "id": "javafx-script",
    "url": "/concepts/javafx-script.html"
  },
  {
    "label": "JavaML",
    "id": "javaml",
    "url": "/concepts/javaml.html"
  },
  {
    "label": "JavaScript",
    "id": "javascript",
    "url": "/concepts/javascript.html"
  },
  {
    "label": "JavaScriptCore",
    "id": "javascriptcore",
    "url": "/concepts/javascriptcore.html"
  },
  {
    "label": "JAWS Scripting Language",
    "id": "jaws-scripting-language",
    "url": "/concepts/jaws-scripting-language.html"
  },
  {
    "label": "jayfor",
    "id": "jayfor",
    "url": "/concepts/jayfor.html"
  },
  {
    "label": "Jazz",
    "id": "jazz",
    "url": "/concepts/jazz.html"
  },
  {
    "label": "jBC",
    "id": "jbc",
    "url": "/concepts/jbc.html"
  },
  {
    "label": "jcard",
    "id": "jcard",
    "url": "/concepts/jcard.html"
  },
  {
    "label": "JCL",
    "id": "jcl",
    "url": "/concepts/jcl.html"
  },
  {
    "label": "JCOF",
    "id": "jcof",
    "url": "/concepts/jcof.html"
  },
  {
    "label": "JOSS Extended and Adapted for Nineteen-hundred",
    "id": "jean",
    "url": "/concepts/jean.html"
  },
  {
    "label": "jedit-editor",
    "id": "jedit-editor",
    "url": "/concepts/jedit-editor.html"
  },
  {
    "label": "jedlang",
    "id": "jedlang",
    "url": "/concepts/jedlang.html"
  },
  {
    "label": "jeebox",
    "id": "jeebox",
    "url": "/concepts/jeebox.html"
  },
  {
    "label": "Jeeves",
    "id": "jeeves",
    "url": "/concepts/jeeves.html"
  },
  {
    "label": "Jekyll",
    "id": "jekyll",
    "url": "/concepts/jekyll.html"
  },
  {
    "id": "jelly",
    "url": "/concepts/jelly.html"
  },
  {
    "label": "Jesth",
    "id": "jesth",
    "url": "/concepts/jesth.html"
  },
  {
    "label": "Jet Propulsion Laboratory Display Information System",
    "id": "jet-propulsion-laboratory-display-information-system",
    "url": "/concepts/jet-propulsion-laboratory-display-information-system.html"
  },
  {
    "label": "Jevko",
    "id": "jevko",
    "url": "/concepts/jevko.html"
  },
  {
    "label": "JFlex",
    "id": "jflex",
    "url": "/concepts/jflex.html"
  },
  {
    "label": "JFugue",
    "id": "jfugue",
    "url": "/concepts/jfugue.html"
  },
  {
    "label": "ji",
    "id": "ji",
    "url": "/concepts/ji.html"
  },
  {
    "label": "Jingo",
    "id": "jingo",
    "url": "/concepts/jingo.html"
  },
  {
    "label": "Jinja",
    "id": "jinja",
    "url": "/concepts/jinja.html"
  },
  {
    "label": "jinx",
    "id": "jinx",
    "url": "/concepts/jinx.html"
  },
  {
    "label": "JIS X 0201",
    "id": "jis-x-0201",
    "url": "/concepts/jis-x-0201.html"
  },
  {
    "label": "Jison Lex",
    "id": "jison-lex",
    "url": "/concepts/jison-lex.html"
  },
  {
    "label": "Jison",
    "id": "jison",
    "url": "/concepts/jison.html"
  },
  {
    "label": "Jisp",
    "id": "jisp",
    "url": "/concepts/jisp.html"
  },
  {
    "label": "jiyu",
    "id": "jiyu",
    "url": "/concepts/jiyu.html"
  },
  {
    "label": "JLang",
    "id": "jlang",
    "url": "/concepts/jlang.html"
  },
  {
    "label": "JMAP",
    "id": "jmap",
    "url": "/concepts/jmap.html"
  },
  {
    "label": "JMESPath",
    "id": "jmespath",
    "url": "/concepts/jmespath.html"
  },
  {
    "label": "JMP",
    "id": "jmp",
    "url": "/concepts/jmp.html"
  },
  {
    "label": "JMSL",
    "id": "jmsl",
    "url": "/concepts/jmsl.html"
  },
  {
    "label": "Joe-E",
    "id": "joe-e",
    "url": "/concepts/joe-e.html"
  },
  {
    "label": "Join Java",
    "id": "join-java",
    "url": "/concepts/join-java.html"
  },
  {
    "label": "joker",
    "id": "joker",
    "url": "/concepts/joker.html"
  },
  {
    "label": "Jolie",
    "id": "jolie",
    "url": "/concepts/jolie.html"
  },
  {
    "label": "jonprl",
    "id": "jonprl",
    "url": "/concepts/jonprl.html"
  },
  {
    "label": "JOSIE",
    "id": "josie",
    "url": "/concepts/josie.html"
  },
  {
    "label": "JOSS II",
    "id": "joss-ii",
    "url": "/concepts/joss-ii.html"
  },
  {
    "label": "JOSS",
    "id": "joss",
    "url": "/concepts/joss.html"
  },
  {
    "label": "Joule",
    "id": "joule",
    "url": "/concepts/joule.html"
  },
  {
    "label": "JOVIAL",
    "id": "jovial",
    "url": "/concepts/jovial.html"
  },
  {
    "label": "Joy",
    "id": "joy",
    "url": "/concepts/joy.html"
  },
  {
    "label": "Joyce",
    "id": "joyce",
    "url": "/concepts/joyce.html"
  },
  {
    "label": "JOYCE+",
    "id": "joycep",
    "url": "/concepts/joycep.html"
  },
  {
    "label": "JPEG",
    "id": "jpeg-format",
    "url": "/concepts/jpeg-format.html"
  },
  {
    "label": "JPL",
    "id": "jpl",
    "url": "/concepts/jpl.html"
  },
  {
    "label": "jplace",
    "id": "jplace",
    "url": "/concepts/jplace.html"
  },
  {
    "label": "Visual J++",
    "id": "jpp",
    "url": "/concepts/jpp.html"
  },
  {
    "label": "jq",
    "id": "jq",
    "url": "/concepts/jq.html"
  },
  {
    "label": "JSON Query Language",
    "id": "jql",
    "url": "/concepts/jql.html"
  },
  {
    "label": "JQuery",
    "id": "jquery",
    "url": "/concepts/jquery.html"
  },
  {
    "label": "JR",
    "id": "jr",
    "url": "/concepts/jr.html"
  },
  {
    "label": "JRuby",
    "id": "jruby",
    "url": "/concepts/jruby.html"
  },
  {
    "label": "JScript",
    "id": "jscript",
    "url": "/concepts/jscript.html"
  },
  {
    "label": "JSFuck",
    "id": "jsf",
    "url": "/concepts/jsf.html"
  },
  {
    "label": "JSGF",
    "id": "jsgf",
    "url": "/concepts/jsgf.html"
  },
  {
    "label": "J#",
    "id": "jsharp",
    "url": "/concepts/jsharp.html"
  },
  {
    "label": "jsil-compiler",
    "id": "jsil-compiler",
    "url": "/concepts/jsil-compiler.html"
  },
  {
    "label": "JSL",
    "id": "jsl",
    "url": "/concepts/jsl.html"
  },
  {
    "label": "JSLT",
    "id": "jslt",
    "url": "/concepts/jslt.html"
  },
  {
    "label": "JSML",
    "id": "jsml",
    "url": "/concepts/jsml.html"
  },
  {
    "label": "json-graph-format",
    "id": "json-graph-format",
    "url": "/concepts/json-graph-format.html"
  },
  {
    "label": "JSON Graph Spec",
    "id": "json-graph-spec",
    "url": "/concepts/json-graph-spec.html"
  },
  {
    "label": "JSON lambda",
    "id": "json-lambda",
    "url": "/concepts/json-lambda.html"
  },
  {
    "label": "JSON-LD",
    "id": "json-ld",
    "url": "/concepts/json-ld.html"
  },
  {
    "label": "JSON Schema",
    "id": "json-schema",
    "url": "/concepts/json-schema.html"
  },
  {
    "label": "JSONScript",
    "id": "json-script",
    "url": "/concepts/json-script.html"
  },
  {
    "label": "JSON-stat",
    "id": "json-stat",
    "url": "/concepts/json-stat.html"
  },
  {
    "label": "json->url",
    "id": "json-url",
    "url": "/concepts/json-url.html"
  },
  {
    "label": "JSON with Comments",
    "id": "json-with-comments",
    "url": "/concepts/json-with-comments.html"
  },
  {
    "label": "JSON",
    "id": "json",
    "url": "/concepts/json.html"
  },
  {
    "label": "JSON5",
    "id": "json5",
    "url": "/concepts/json5.html"
  },
  {
    "label": "JSONiq",
    "id": "jsoniq",
    "url": "/concepts/jsoniq.html"
  },
  {
    "label": "Jsonnet",
    "id": "jsonnet",
    "url": "/concepts/jsonnet.html"
  },
  {
    "label": "jsparagus",
    "id": "jsparagus",
    "url": "/concepts/jsparagus.html"
  },
  {
    "label": "JS++",
    "id": "jspp",
    "url": "/concepts/jspp.html"
  },
  {
    "label": "JSX",
    "id": "jsx",
    "url": "/concepts/jsx.html"
  },
  {
    "label": "JSyn",
    "id": "jsyn",
    "url": "/concepts/jsyn.html"
  },
  {
    "label": "Judoscript",
    "id": "judoscript",
    "url": "/concepts/judoscript.html"
  },
  {
    "label": "juicy",
    "id": "juicy",
    "url": "/concepts/juicy.html"
  },
  {
    "label": "Jule",
    "id": "jule",
    "url": "/concepts/jule.html"
  },
  {
    "label": "Joyfully Universal Language for (Inline) Assembly",
    "id": "julia-lang",
    "url": "/concepts/julia-lang.html"
  },
  {
    "label": "Julia",
    "id": "julia",
    "url": "/concepts/julia.html"
  },
  {
    "label": "JuliaHub Packages",
    "id": "juliahub-pm",
    "url": "/concepts/juliahub-pm.html"
  },
  {
    "label": "juniper",
    "id": "juniper",
    "url": "/concepts/juniper.html"
  },
  {
    "label": "Juno",
    "id": "juno",
    "url": "/concepts/juno.html"
  },
  {
    "label": "Project Jupyter",
    "id": "jupyter-editor",
    "url": "/concepts/jupyter-editor.html"
  },
  {
    "label": "Jupyter Notebook",
    "id": "jupyter-notebook",
    "url": "/concepts/jupyter-notebook.html"
  },
  {
    "label": "Just",
    "id": "just",
    "url": "/concepts/just.html"
  },
  {
    "label": "juttle",
    "id": "juttle",
    "url": "/concepts/juttle.html"
  },
  {
    "label": "juvix",
    "id": "juvix",
    "url": "/concepts/juvix.html"
  },
  {
    "label": "JVM",
    "id": "jvm",
    "url": "/concepts/jvm.html"
  },
  {
    "label": "Jython",
    "id": "jython",
    "url": "/concepts/jython.html"
  },
  {
    "label": "k-framework",
    "id": "k-framework",
    "url": "/concepts/k-framework.html"
  },
  {
    "label": "K",
    "id": "k",
    "url": "/concepts/k.html"
  },
  {
    "label": "Kaffeine",
    "id": "kaffeine",
    "url": "/concepts/kaffeine.html"
  },
  {
    "label": "Kaggle",
    "id": "kaggle-app",
    "url": "/concepts/kaggle-app.html"
  },
  {
    "label": "kai",
    "id": "kai",
    "url": "/concepts/kai.html"
  },
  {
    "label": "KAIL",
    "id": "kail",
    "url": "/concepts/kail.html"
  },
  {
    "label": "kaitai",
    "id": "kaitai",
    "url": "/concepts/kaitai.html"
  },
  {
    "label": "Kakoune",
    "id": "kakoune-editor",
    "url": "/concepts/kakoune-editor.html"
  },
  {
    "label": "Kal",
    "id": "kal",
    "url": "/concepts/kal.html"
  },
  {
    "label": "Kaleidoquery",
    "id": "kaleidoquery",
    "url": "/concepts/kaleidoquery.html"
  },
  {
    "label": "Kaleidoscope",
    "id": "kaleidoscope",
    "url": "/concepts/kaleidoscope.html"
  },
  {
    "label": "Kaleidoscope'90",
    "id": "kaleidoscope90",
    "url": "/concepts/kaleidoscope90.html"
  },
  {
    "label": "Kaleidoscope'91",
    "id": "kaleidoscope91",
    "url": "/concepts/kaleidoscope91.html"
  },
  {
    "label": "Kalyn",
    "id": "kalyn",
    "url": "/concepts/kalyn.html"
  },
  {
    "label": "Kamby",
    "id": "kamby",
    "url": "/concepts/kamby.html"
  },
  {
    "label": "Kami",
    "id": "kami",
    "url": "/concepts/kami.html"
  },
  {
    "label": "KamilaLisp",
    "id": "kamilalisp",
    "url": "/concepts/kamilalisp.html"
  },
  {
    "label": "KAML",
    "id": "kaml",
    "url": "/concepts/kaml.html"
  },
  {
    "label": "Karel",
    "id": "karel",
    "url": "/concepts/karel.html"
  },
  {
    "label": "Knowledge Acquisition and Representation Language",
    "id": "karl",
    "url": "/concepts/karl.html"
  },
  {
    "label": "kasaya",
    "id": "kasaya",
    "url": "/concepts/kasaya.html"
  },
  {
    "label": "kate-editor",
    "id": "kate-editor",
    "url": "/concepts/kate-editor.html"
  },
  {
    "label": "KATE",
    "id": "kate",
    "url": "/concepts/kate.html"
  },
  {
    "label": "KaTeX",
    "id": "katex",
    "url": "/concepts/katex.html"
  },
  {
    "label": "kaukatcr",
    "id": "kaukatcr",
    "url": "/concepts/kaukatcr.html"
  },
  {
    "label": "KavaScript",
    "id": "kavascript",
    "url": "/concepts/kavascript.html"
  },
  {
    "label": "Kawa",
    "id": "kawa-scheme-implementation",
    "url": "/concepts/kawa-scheme-implementation.html"
  },
  {
    "label": "kayia",
    "id": "kayia",
    "url": "/concepts/kayia.html"
  },
  {
    "label": "KB",
    "id": "kb",
    "url": "/concepts/kb.html"
  },
  {
    "label": "KEE",
    "id": "kee",
    "url": "/concepts/kee.html"
  },
  {
    "label": "Kefir",
    "id": "kefir",
    "url": "/concepts/kefir.html"
  },
  {
    "label": "kei",
    "id": "kei",
    "url": "/concepts/kei.html"
  },
  {
    "label": "KEK-NODAL",
    "id": "kek-nodal",
    "url": "/concepts/kek-nodal.html"
  },
  {
    "label": "keli",
    "id": "keli",
    "url": "/concepts/keli.html"
  },
  {
    "label": "Keras",
    "id": "keras",
    "url": "/concepts/keras.html"
  },
  {
    "label": "kerf",
    "id": "kerf",
    "url": "/concepts/kerf.html"
  },
  {
    "label": "Kermeta",
    "id": "kermeta",
    "url": "/concepts/kermeta.html"
  },
  {
    "label": "kernel-e",
    "id": "kernel-e",
    "url": "/concepts/kernel-e.html"
  },
  {
    "label": "kernel",
    "id": "kernel",
    "url": "/concepts/kernel.html"
  },
  {
    "label": "kew",
    "id": "kew",
    "url": "/concepts/kew.html"
  },
  {
    "label": "KeyKit",
    "id": "keykit",
    "url": "/concepts/keykit.html"
  },
  {
    "label": "Agilent VEE",
    "id": "keysight-vee",
    "url": "/concepts/keysight-vee.html"
  },
  {
    "label": "Khepri",
    "id": "khepri",
    "url": "/concepts/khepri.html"
  },
  {
    "label": "ki",
    "id": "ki",
    "url": "/concepts/ki.html"
  },
  {
    "label": "KiCad Legacy Layout",
    "id": "kicad",
    "url": "/concepts/kicad.html"
  },
  {
    "label": "Kid templating language",
    "id": "kid",
    "url": "/concepts/kid.html"
  },
  {
    "label": "Kiev",
    "id": "kiev",
    "url": "/concepts/kiev.html"
  },
  {
    "label": "kilo-lisp",
    "id": "kilo-lisp",
    "url": "/concepts/kilo-lisp.html"
  },
  {
    "label": "kima",
    "id": "kima",
    "url": "/concepts/kima.html"
  },
  {
    "label": "King Kong",
    "id": "king-kong",
    "url": "/concepts/king-kong.html"
  },
  {
    "label": "Keep It Short and Simple",
    "id": "kiss",
    "url": "/concepts/kiss.html"
  },
  {
    "label": "Kit",
    "id": "kit",
    "url": "/concepts/kit.html"
  },
  {
    "label": "kitlang",
    "id": "kitlang",
    "url": "/concepts/kitlang.html"
  },
  {
    "label": "kitten",
    "id": "kitten",
    "url": "/concepts/kitten.html"
  },
  {
    "label": "kivy-lang",
    "id": "kivy-lang",
    "url": "/concepts/kivy-lang.html"
  },
  {
    "label": "KiXtart",
    "id": "kixtart",
    "url": "/concepts/kixtart.html"
  },
  {
    "label": "KL-ONE",
    "id": "kl-one",
    "url": "/concepts/kl-one.html"
  },
  {
    "label": "KL0",
    "id": "kl0",
    "url": "/concepts/kl0.html"
  },
  {
    "label": "KL1",
    "id": "kl1",
    "url": "/concepts/kl1.html"
  },
  {
    "label": "Klaim",
    "id": "klaim",
    "url": "/concepts/klaim.html"
  },
  {
    "label": "Klerer-May System",
    "id": "klerer-may-system",
    "url": "/concepts/klerer-may-system.html"
  },
  {
    "label": "KLIPA",
    "id": "klipa",
    "url": "/concepts/klipa.html"
  },
  {
    "label": "klisp",
    "id": "klisp",
    "url": "/concepts/klisp.html"
  },
  {
    "label": "klong",
    "id": "klong",
    "url": "/concepts/klong.html"
  },
  {
    "label": "KML",
    "id": "kml",
    "url": "/concepts/kml.html"
  },
  {
    "label": "Knight",
    "id": "knight",
    "url": "/concepts/knight.html"
  },
  {
    "label": "Knitr",
    "id": "knitr",
    "url": "/concepts/knitr.html"
  },
  {
    "label": "Knowledge Interchange Format",
    "id": "knowledge-interchange-format",
    "url": "/concepts/knowledge-interchange-format.html"
  },
  {
    "label": "ko",
    "id": "ko",
    "url": "/concepts/ko.html"
  },
  {
    "label": "koara",
    "id": "koara",
    "url": "/concepts/koara.html"
  },
  {
    "label": "Kodu Game Lab",
    "id": "kodu-game-lab",
    "url": "/concepts/kodu-game-lab.html"
  },
  {
    "label": "kogut",
    "id": "kogut",
    "url": "/concepts/kogut.html"
  },
  {
    "label": "koi",
    "id": "koi",
    "url": "/concepts/koi.html"
  },
  {
    "label": "Koka",
    "id": "koka",
    "url": "/concepts/koka.html"
  },
  {
    "label": "komodo-editor",
    "id": "komodo-editor",
    "url": "/concepts/komodo-editor.html"
  },
  {
    "label": "kona",
    "id": "kona",
    "url": "/concepts/kona.html"
  },
  {
    "label": "Konna",
    "id": "konna",
    "url": "/concepts/konna.html"
  },
  {
    "label": "KonsolScript",
    "id": "konsolscript",
    "url": "/concepts/konsolscript.html"
  },
  {
    "label": "Korn shell",
    "id": "korn-shell",
    "url": "/concepts/korn-shell.html"
  },
  {
    "label": "Kotlin",
    "id": "kotlin",
    "url": "/concepts/kotlin.html"
  },
  {
    "label": "Knowledge Query and Manipulation Language",
    "id": "kqml",
    "url": "/concepts/kqml.html"
  },
  {
    "label": "KRC",
    "id": "krc",
    "url": "/concepts/krc.html"
  },
  {
    "label": "KRIS",
    "id": "kris",
    "url": "/concepts/kris.html"
  },
  {
    "label": "KRL-0",
    "id": "krl-0",
    "url": "/concepts/krl-0.html"
  },
  {
    "label": "KRL",
    "id": "krl",
    "url": "/concepts/krl.html"
  },
  {
    "label": "KRS",
    "id": "krs",
    "url": "/concepts/krs.html"
  },
  {
    "label": "KRYPTON",
    "id": "krypton",
    "url": "/concepts/krypton.html"
  },
  {
    "label": "ktexteditor-editor",
    "id": "ktexteditor-editor",
    "url": "/concepts/ktexteditor-editor.html"
  },
  {
    "label": "Kubernetes",
    "id": "kubernetes",
    "url": "/concepts/kubernetes.html"
  },
  {
    "label": "Kuin",
    "id": "kuin",
    "url": "/concepts/kuin.html"
  },
  {
    "label": "KUKA Robot Language",
    "id": "kuka",
    "url": "/concepts/kuka.html"
  },
  {
    "label": "kumir",
    "id": "kumir",
    "url": "/concepts/kumir.html"
  },
  {
    "label": "Kuroko",
    "id": "kuroko",
    "url": "/concepts/kuroko.html"
  },
  {
    "label": "Kvikkalkul",
    "id": "kvikkalkul",
    "url": "/concepts/kvikkalkul.html"
  },
  {
    "label": "kvsapi",
    "id": "kvsapi",
    "url": "/concepts/kvsapi.html"
  },
  {
    "label": "Kylix",
    "id": "kylix",
    "url": "/concepts/kylix.html"
  },
  {
    "label": "Kyma",
    "id": "kyma",
    "url": "/concepts/kyma.html"
  },
  {
    "label": "l",
    "id": "l",
    "url": "/concepts/l.html"
  },
  {
    "label": "l2",
    "id": "l2",
    "url": "/concepts/l2.html"
  },
  {
    "label": "L6",
    "id": "l6",
    "url": "/concepts/l6.html"
  },
  {
    "label": "LABTRAN",
    "id": "labtran",
    "url": "/concepts/labtran.html"
  },
  {
    "label": "LabVIEW G",
    "id": "labview",
    "url": "/concepts/labview.html"
  },
  {
    "label": "Ladder Logic",
    "id": "ladder-logic",
    "url": "/concepts/ladder-logic.html"
  },
  {
    "label": "Lagoona",
    "id": "lagoona",
    "url": "/concepts/lagoona.html"
  },
  {
    "label": "lain",
    "id": "lain",
    "url": "/concepts/lain.html"
  },
  {
    "label": "lambcalc",
    "id": "lambcalc",
    "url": "/concepts/lambcalc.html"
  },
  {
    "label": "lambda-obliv",
    "id": "lambda-obliv",
    "url": "/concepts/lambda-obliv.html"
  },
  {
    "label": "ΛProlog",
    "id": "lambda-prolog",
    "url": "/concepts/lambda-prolog.html"
  },
  {
    "label": "lambda-zero",
    "id": "lambda-zero",
    "url": "/concepts/lambda-zero.html"
  },
  {
    "label": "lambda",
    "id": "lambda",
    "url": "/concepts/lambda.html"
  },
  {
    "label": "lamderp",
    "id": "lamderp",
    "url": "/concepts/lamderp.html"
  },
  {
    "label": "lamdu-editor",
    "id": "lamdu-editor",
    "url": "/concepts/lamdu-editor.html"
  },
  {
    "label": "Lamdu",
    "id": "lamdu",
    "url": "/concepts/lamdu.html"
  },
  {
    "label": "LAMINA",
    "id": "lamina",
    "url": "/concepts/lamina.html"
  },
  {
    "label": "Large-scale Atomic/Molecular Massively Parallel Simulator Format",
    "id": "lammps-format",
    "url": "/concepts/lammps-format.html"
  },
  {
    "label": "Lanai",
    "id": "lanai",
    "url": "/concepts/lanai.html"
  },
  {
    "label": "Language for Class Description",
    "id": "language-for-class-description",
    "url": "/concepts/language-for-class-description.html"
  },
  {
    "label": "Language H",
    "id": "language-h",
    "url": "/concepts/language-h.html"
  },
  {
    "label": "LSP",
    "id": "language-server-protocol",
    "url": "/concepts/language-server-protocol.html"
  },
  {
    "label": "Laning and Zierler system",
    "id": "laning-and-zierler-system",
    "url": "/concepts/laning-and-zierler-system.html"
  },
  {
    "label": "LAP",
    "id": "lap",
    "url": "/concepts/lap.html"
  },
  {
    "label": "Laravel",
    "id": "laravel-framework",
    "url": "/concepts/laravel-framework.html"
  },
  {
    "label": "Larceny Scheme implementation",
    "id": "larceny",
    "url": "/concepts/larceny.html"
  },
  {
    "label": "Larch",
    "id": "larch",
    "url": "/concepts/larch.html"
  },
  {
    "label": "LARIS",
    "id": "laris",
    "url": "/concepts/laris.html"
  },
  {
    "label": "LARP",
    "id": "larp",
    "url": "/concepts/larp.html"
  },
  {
    "label": "lasp",
    "id": "lasp",
    "url": "/concepts/lasp.html"
  },
  {
    "label": "LASS",
    "id": "lass",
    "url": "/concepts/lass.html"
  },
  {
    "label": "Lasso",
    "id": "lasso",
    "url": "/concepts/lasso.html"
  },
  {
    "label": "LaTeX",
    "id": "latex",
    "url": "/concepts/latex.html"
  },
  {
    "label": "latino",
    "id": "latino",
    "url": "/concepts/latino.html"
  },
  {
    "label": "latte-js",
    "id": "latte-js",
    "url": "/concepts/latte-js.html"
  },
  {
    "label": "Latte",
    "id": "latte",
    "url": "/concepts/latte.html"
  },
  {
    "label": "LAURE",
    "id": "laure",
    "url": "/concepts/laure.html"
  },
  {
    "label": "lav-format",
    "id": "lav-format",
    "url": "/concepts/lav-format.html"
  },
  {
    "label": "Lava",
    "id": "lava",
    "url": "/concepts/lava.html"
  },
  {
    "label": "Lawvere",
    "id": "lawvere",
    "url": "/concepts/lawvere.html"
  },
  {
    "label": "lazarus-editor",
    "id": "lazarus-editor",
    "url": "/concepts/lazarus-editor.html"
  },
  {
    "label": "Lazy K",
    "id": "lazy-k",
    "url": "/concepts/lazy-k.html"
  },
  {
    "label": "Lazy ML",
    "id": "lazyml",
    "url": "/concepts/lazyml.html"
  },
  {
    "label": "LC-3",
    "id": "lc-3",
    "url": "/concepts/lc-3.html"
  },
  {
    "label": "LCF",
    "id": "lcf",
    "url": "/concepts/lcf.html"
  },
  {
    "label": "LCL",
    "id": "lcl",
    "url": "/concepts/lcl.html"
  },
  {
    "label": "JSON Lines",
    "id": "ld-json",
    "url": "/concepts/ld-json.html"
  },
  {
    "label": "Lightweight Directory Access Protocol",
    "id": "ldap",
    "url": "/concepts/ldap.html"
  },
  {
    "label": "LDL",
    "id": "ldl",
    "url": "/concepts/ldl.html"
  },
  {
    "label": "LDL1",
    "id": "ldl1",
    "url": "/concepts/ldl1.html"
  },
  {
    "label": "ldpl",
    "id": "ldpl",
    "url": "/concepts/ldpl.html"
  },
  {
    "label": "Le-Lisp",
    "id": "le-lisp",
    "url": "/concepts/le-lisp.html"
  },
  {
    "label": "leaf",
    "id": "leaf",
    "url": "/concepts/leaf.html"
  },
  {
    "label": "Lean",
    "id": "lean",
    "url": "/concepts/lean.html"
  },
  {
    "label": "LEAP",
    "id": "leap",
    "url": "/concepts/leap.html"
  },
  {
    "label": "Leazy",
    "id": "leazy",
    "url": "/concepts/leazy.html"
  },
  {
    "label": "Leda",
    "id": "leda",
    "url": "/concepts/leda.html"
  },
  {
    "label": "LEGOL",
    "id": "legol",
    "url": "/concepts/legol.html"
  },
  {
    "label": "lem-editor",
    "id": "lem-editor",
    "url": "/concepts/lem-editor.html"
  },
  {
    "label": "Lemick",
    "id": "lemick",
    "url": "/concepts/lemick.html"
  },
  {
    "label": "lemon",
    "id": "lemon",
    "url": "/concepts/lemon.html"
  },
  {
    "label": "leo-editor",
    "id": "leo-editor",
    "url": "/concepts/leo-editor.html"
  },
  {
    "label": "Leogo",
    "id": "leogo",
    "url": "/concepts/leogo.html"
  },
  {
    "label": "Leopard",
    "id": "leopard",
    "url": "/concepts/leopard.html"
  },
  {
    "label": "LES",
    "id": "les",
    "url": "/concepts/les.html"
  },
  {
    "label": "LESK",
    "id": "lesk",
    "url": "/concepts/lesk.html"
  },
  {
    "label": "Lesma",
    "id": "lesma",
    "url": "/concepts/lesma.html"
  },
  {
    "label": "Less",
    "id": "less",
    "url": "/concepts/less.html"
  },
  {
    "label": "lever",
    "id": "lever",
    "url": "/concepts/lever.html"
  },
  {
    "label": "levy",
    "id": "levy",
    "url": "/concepts/levy.html"
  },
  {
    "label": "Lex",
    "id": "lex",
    "url": "/concepts/lex.html"
  },
  {
    "label": "Lexon",
    "id": "lexon",
    "url": "/concepts/lexon.html"
  },
  {
    "label": "LEXX",
    "id": "lexx-editor",
    "url": "/concepts/lexx-editor.html"
  },
  {
    "label": "lezer",
    "id": "lezer",
    "url": "/concepts/lezer.html"
  },
  {
    "label": "LFE",
    "id": "lfe",
    "url": "/concepts/lfe.html"
  },
  {
    "label": "LG",
    "id": "lg",
    "url": "/concepts/lg.html"
  },
  {
    "label": "LGDF",
    "id": "lgdf",
    "url": "/concepts/lgdf.html"
  },
  {
    "label": "Li-Chen Wang",
    "id": "li-chen-wang",
    "url": "/concepts/li-chen-wang.html"
  },
  {
    "label": "Liberty BASIC",
    "id": "liberty-basic",
    "url": "/concepts/liberty-basic.html"
  },
  {
    "label": "Libra",
    "id": "libra",
    "url": "/concepts/libra.html"
  },
  {
    "label": "libsvm-format",
    "id": "libsvm-format",
    "url": "/concepts/libsvm-format.html"
  },
  {
    "label": "LIFE",
    "id": "life",
    "url": "/concepts/life.html"
  },
  {
    "label": "lift",
    "id": "lift",
    "url": "/concepts/lift.html"
  },
  {
    "label": "Lighttpd configuration file",
    "id": "lighttpd-configuration-file",
    "url": "/concepts/lighttpd-configuration-file.html"
  },
  {
    "label": "Ligo",
    "id": "ligo",
    "url": "/concepts/ligo.html"
  },
  {
    "label": "Lil",
    "id": "lil-pl",
    "url": "/concepts/lil-pl.html"
  },
  {
    "label": "Little Implementation Language",
    "id": "lil",
    "url": "/concepts/lil.html"
  },
  {
    "label": "lila-lang",
    "id": "lila-lang",
    "url": "/concepts/lila-lang.html"
  },
  {
    "label": "Lila",
    "id": "lila",
    "url": "/concepts/lila.html"
  },
  {
    "label": "Lily",
    "id": "lily",
    "url": "/concepts/lily.html"
  },
  {
    "label": "LilyPond",
    "id": "lilypond",
    "url": "/concepts/lilypond.html"
  },
  {
    "label": "Limbo",
    "id": "limbo",
    "url": "/concepts/limbo.html"
  },
  {
    "label": "LIMDEP",
    "id": "limdep",
    "url": "/concepts/limdep.html"
  },
  {
    "label": "LINC 4GL",
    "id": "linc-4gl",
    "url": "/concepts/linc-4gl.html"
  },
  {
    "label": "Lincoln Reckoner",
    "id": "lincoln-reckoner",
    "url": "/concepts/lincoln-reckoner.html"
  },
  {
    "label": "Lincos",
    "id": "lincos",
    "url": "/concepts/lincos.html"
  },
  {
    "label": "Linda",
    "id": "linda",
    "url": "/concepts/linda.html"
  },
  {
    "label": "Linden Scripting Language",
    "id": "linden-scripting-language",
    "url": "/concepts/linden-scripting-language.html"
  },
  {
    "label": "LinearML",
    "id": "linearml",
    "url": "/concepts/linearml.html"
  },
  {
    "label": "Lingo",
    "id": "lingo",
    "url": "/concepts/lingo.html"
  },
  {
    "label": "Lingua Graphica",
    "id": "lingua-graphica",
    "url": "/concepts/lingua-graphica.html"
  },
  {
    "label": "Link",
    "id": "link",
    "url": "/concepts/link.html"
  },
  {
    "label": "Linked Markdown",
    "id": "linked-markdown",
    "url": "/concepts/linked-markdown.html"
  },
  {
    "label": "Linker Script",
    "id": "linker-script",
    "url": "/concepts/linker-script.html"
  },
  {
    "label": "Links",
    "id": "links-programming-language",
    "url": "/concepts/links-programming-language.html"
  },
  {
    "label": "links",
    "id": "links",
    "url": "/concepts/links.html"
  },
  {
    "label": "LinkText",
    "id": "linktext",
    "url": "/concepts/linktext.html"
  },
  {
    "label": "Linoleum (L.in.oleum)",
    "id": "linoleum",
    "url": "/concepts/linoleum.html"
  },
  {
    "label": "Linotte",
    "id": "linotte",
    "url": "/concepts/linotte.html"
  },
  {
    "label": "LINQ",
    "id": "linq",
    "url": "/concepts/linq.html"
  },
  {
    "label": "Linux Kernel Module",
    "id": "linux-kernel-module",
    "url": "/concepts/linux-kernel-module.html"
  },
  {
    "label": "Linux",
    "id": "linux",
    "url": "/concepts/linux.html"
  },
  {
    "label": "Liquid",
    "id": "liquid",
    "url": "/concepts/liquid.html"
  },
  {
    "label": "liquidity",
    "id": "liquidity",
    "url": "/concepts/liquidity.html"
  },
  {
    "label": "Langage Implementation Systeme",
    "id": "lis",
    "url": "/concepts/lis.html"
  },
  {
    "label": "Lisaac",
    "id": "lisaac",
    "url": "/concepts/lisaac.html"
  },
  {
    "label": "LiSEB",
    "id": "liseb",
    "url": "/concepts/liseb.html"
  },
  {
    "label": "Liso",
    "id": "liso",
    "url": "/concepts/liso.html"
  },
  {
    "label": "LISP 1.5",
    "id": "lisp-1-5",
    "url": "/concepts/lisp-1-5.html"
  },
  {
    "label": "LISP 2",
    "id": "lisp-2",
    "url": "/concepts/lisp-2.html"
  },
  {
    "label": "LISP A",
    "id": "lisp-a",
    "url": "/concepts/lisp-a.html"
  },
  {
    "label": "Lisp Machine Lisp",
    "id": "lisp-machine-lisp",
    "url": "/concepts/lisp-machine-lisp.html"
  },
  {
    "label": "Lisp",
    "id": "lisp",
    "url": "/concepts/lisp.html"
  },
  {
    "label": "LispMe",
    "id": "lispme",
    "url": "/concepts/lispme.html"
  },
  {
    "label": "Lisptalk",
    "id": "lisptalk",
    "url": "/concepts/lisptalk.html"
  },
  {
    "label": "LispWorks",
    "id": "lispworks",
    "url": "/concepts/lispworks.html"
  },
  {
    "label": "lispyscript",
    "id": "lispyscript",
    "url": "/concepts/lispyscript.html"
  },
  {
    "label": "listdown",
    "id": "listdown",
    "url": "/concepts/listdown.html"
  },
  {
    "label": "Lite-C",
    "id": "lite-c",
    "url": "/concepts/lite-c.html"
  },
  {
    "label": "Literate Agda",
    "id": "literate-agda",
    "url": "/concepts/literate-agda.html"
  },
  {
    "label": "Literate CoffeeScript",
    "id": "literate-coffeescript",
    "url": "/concepts/literate-coffeescript.html"
  },
  {
    "label": "Literate Haskell",
    "id": "literate-haskell",
    "url": "/concepts/literate-haskell.html"
  },
  {
    "label": "LiteScript",
    "id": "litescript",
    "url": "/concepts/litescript.html"
  },
  {
    "label": "Lithe",
    "id": "lithe",
    "url": "/concepts/lithe.html"
  },
  {
    "label": "Little b",
    "id": "little-b",
    "url": "/concepts/little-b.html"
  },
  {
    "label": "Little Smalltalk",
    "id": "little-smalltalk",
    "url": "/concepts/little-smalltalk.html"
  },
  {
    "label": "little",
    "id": "little",
    "url": "/concepts/little.html"
  },
  {
    "label": "LiveCode",
    "id": "livecode",
    "url": "/concepts/livecode.html"
  },
  {
    "label": "LiveScript",
    "id": "livescript",
    "url": "/concepts/livescript.html"
  },
  {
    "label": "Livr",
    "id": "livr",
    "url": "/concepts/livr.html"
  },
  {
    "label": "Legal Knowledge Interchange Format",
    "id": "lkif",
    "url": "/concepts/lkif.html"
  },
  {
    "label": "llhd",
    "id": "llhd",
    "url": "/concepts/llhd.html"
  },
  {
    "label": "Low Level Lisp",
    "id": "lll",
    "url": "/concepts/lll.html"
  },
  {
    "label": "lllpg",
    "id": "lllpg",
    "url": "/concepts/lllpg.html"
  },
  {
    "label": "LLVM IR",
    "id": "llvmir",
    "url": "/concepts/llvmir.html"
  },
  {
    "label": "lmdb",
    "id": "lmdb",
    "url": "/concepts/lmdb.html"
  },
  {
    "label": "LNF",
    "id": "lnf",
    "url": "/concepts/lnf.html"
  },
  {
    "label": "LO",
    "id": "lo",
    "url": "/concepts/lo.html"
  },
  {
    "label": "lobster",
    "id": "lobster",
    "url": "/concepts/lobster.html"
  },
  {
    "label": "local",
    "id": "local",
    "url": "/concepts/local.html"
  },
  {
    "label": "loci",
    "id": "loci",
    "url": "/concepts/loci.html"
  },
  {
    "label": "Locomotive BASIC",
    "id": "locomotive-basic",
    "url": "/concepts/locomotive-basic.html"
  },
  {
    "label": "LOCS",
    "id": "locs",
    "url": "/concepts/locs.html"
  },
  {
    "label": "LOGAL",
    "id": "logal",
    "url": "/concepts/logal.html"
  },
  {
    "label": "Logica",
    "id": "logica",
    "url": "/concepts/logica.html"
  },
  {
    "label": "Logicon",
    "id": "logicon",
    "url": "/concepts/logicon.html"
  },
  {
    "label": "LOGIN",
    "id": "login",
    "url": "/concepts/login.html"
  },
  {
    "label": "LOGIST",
    "id": "logist",
    "url": "/concepts/logist.html"
  },
  {
    "label": "LOGLAN",
    "id": "loglan",
    "url": "/concepts/loglan.html"
  },
  {
    "label": "LOGLISP",
    "id": "loglisp",
    "url": "/concepts/loglisp.html"
  },
  {
    "label": "loglo",
    "id": "loglo",
    "url": "/concepts/loglo.html"
  },
  {
    "label": "Logo",
    "id": "logo",
    "url": "/concepts/logo.html"
  },
  {
    "label": "LOGOL",
    "id": "logol",
    "url": "/concepts/logol.html"
  },
  {
    "label": "Logos",
    "id": "logos",
    "url": "/concepts/logos.html"
  },
  {
    "label": "LogoWriter",
    "id": "logowriter",
    "url": "/concepts/logowriter.html"
  },
  {
    "label": "Logres",
    "id": "logres",
    "url": "/concepts/logres.html"
  },
  {
    "label": "LogScheme",
    "id": "logscheme",
    "url": "/concepts/logscheme.html"
  },
  {
    "label": "Logtalk",
    "id": "logtalk",
    "url": "/concepts/logtalk.html"
  },
  {
    "label": "LOL",
    "id": "lol",
    "url": "/concepts/lol.html"
  },
  {
    "label": "Lola-2",
    "id": "lola-2",
    "url": "/concepts/lola-2.html"
  },
  {
    "label": "LOLA",
    "id": "lola",
    "url": "/concepts/lola.html"
  },
  {
    "label": "LOLCODE",
    "id": "lolcode",
    "url": "/concepts/lolcode.html"
  },
  {
    "label": "LookML",
    "id": "lookml",
    "url": "/concepts/lookml.html"
  },
  {
    "label": "Loom",
    "id": "loom",
    "url": "/concepts/loom.html"
  },
  {
    "label": "LoomScript",
    "id": "loomscript",
    "url": "/concepts/loomscript.html"
  },
  {
    "label": "LOOPN++",
    "id": "loopnpp",
    "url": "/concepts/loopnpp.html"
  },
  {
    "label": "Lisp Object-Oriented Programming System",
    "id": "loops",
    "url": "/concepts/loops.html"
  },
  {
    "label": "LORE",
    "id": "lore",
    "url": "/concepts/lore.html"
  },
  {
    "label": "Lorel",
    "id": "lorel-1",
    "url": "/concepts/lorel-1.html"
  },
  {
    "label": "Lorel",
    "id": "lorel",
    "url": "/concepts/lorel.html"
  },
  {
    "label": "LOTIS",
    "id": "lotis",
    "url": "/concepts/lotis.html"
  },
  {
    "label": "LOTOS",
    "id": "lotos",
    "url": "/concepts/lotos.html"
  },
  {
    "label": "LotusScript",
    "id": "lotusscript",
    "url": "/concepts/lotusscript.html"
  },
  {
    "label": "Low*",
    "id": "lowstar",
    "url": "/concepts/lowstar.html"
  },
  {
    "label": "LPC",
    "id": "lpc",
    "url": "/concepts/lpc.html"
  },
  {
    "label": "LPL",
    "id": "lpl",
    "url": "/concepts/lpl.html"
  },
  {
    "label": "LRLTRAN",
    "id": "lrltran",
    "url": "/concepts/lrltran.html"
  },
  {
    "label": "lsd",
    "id": "lsd",
    "url": "/concepts/lsd.html"
  },
  {
    "label": "Langage Sans Espoir",
    "id": "lse",
    "url": "/concepts/lse.html"
  },
  {
    "label": "Language Server Index Format",
    "id": "lsif-format",
    "url": "/concepts/lsif-format.html"
  },
  {
    "label": "Linden Scripting Language",
    "id": "lsl",
    "url": "/concepts/lsl.html"
  },
  {
    "label": "Lua",
    "id": "lua",
    "url": "/concepts/lua.html"
  },
  {
    "label": "LuaJIT",
    "id": "luajit",
    "url": "/concepts/luajit.html"
  },
  {
    "label": "luarocks-pm",
    "id": "luarocks-pm",
    "url": "/concepts/luarocks-pm.html"
  },
  {
    "label": "luau",
    "id": "luau",
    "url": "/concepts/luau.html"
  },
  {
    "label": "Apache Lucene",
    "id": "lucene-query-syntax",
    "url": "/concepts/lucene-query-syntax.html"
  },
  {
    "label": "Lucidchart",
    "id": "lucid-chart-app",
    "url": "/concepts/lucid-chart-app.html"
  },
  {
    "label": "Lucid",
    "id": "lucid-lang",
    "url": "/concepts/lucid-lang.html"
  },
  {
    "label": "Lucid representations",
    "id": "lucid-representations",
    "url": "/concepts/lucid-representations.html"
  },
  {
    "label": "LUCID",
    "id": "lucid",
    "url": "/concepts/lucid.html"
  },
  {
    "label": "Lucinda",
    "id": "lucinda",
    "url": "/concepts/lucinda.html"
  },
  {
    "label": "Luna",
    "id": "luna-1",
    "url": "/concepts/luna-1.html"
  },
  {
    "label": "Luna",
    "id": "luna",
    "url": "/concepts/luna.html"
  },
  {
    "label": "lunar",
    "id": "lunar",
    "url": "/concepts/lunar.html"
  },
  {
    "label": "Lush",
    "id": "lush",
    "url": "/concepts/lush.html"
  },
  {
    "label": "Lustre",
    "id": "lustre",
    "url": "/concepts/lustre.html"
  },
  {
    "label": "Lux",
    "id": "lux",
    "url": "/concepts/lux.html"
  },
  {
    "label": "LYaPAS",
    "id": "lyapas",
    "url": "/concepts/lyapas.html"
  },
  {
    "label": "Lygon",
    "id": "lygon",
    "url": "/concepts/lygon.html"
  },
  {
    "label": "Lynx",
    "id": "lynx",
    "url": "/concepts/lynx.html"
  },
  {
    "label": "Language for Your Remote Instruction by Computer",
    "id": "lyric",
    "url": "/concepts/lyric.html"
  },
  {
    "label": "LyX",
    "id": "lyx-editor",
    "url": "/concepts/lyx-editor.html"
  },
  {
    "label": "Meta Expressions",
    "id": "m-expressions",
    "url": "/concepts/m-expressions.html"
  },
  {
    "label": "M-LISP",
    "id": "m-lisp",
    "url": "/concepts/m-lisp.html"
  },
  {
    "label": "M",
    "id": "m-programming-language",
    "url": "/concepts/m-programming-language.html"
  },
  {
    "label": "M2001",
    "id": "m2001",
    "url": "/concepts/m2001.html"
  },
  {
    "label": "m3db",
    "id": "m3db",
    "url": "/concepts/m3db.html"
  },
  {
    "label": "M4",
    "id": "m4",
    "url": "/concepts/m4.html"
  },
  {
    "label": "M4Sugar",
    "id": "m4sugar",
    "url": "/concepts/m4sugar.html"
  },
  {
    "label": "MIT Algebraic Compiler",
    "id": "mac",
    "url": "/concepts/mac.html"
  },
  {
    "label": "MacAims",
    "id": "macaims",
    "url": "/concepts/macaims.html"
  },
  {
    "label": "MacBASIC",
    "id": "macbasic",
    "url": "/concepts/macbasic.html"
  },
  {
    "label": "MacBook Air",
    "id": "macbook-air-machine",
    "url": "/concepts/macbook-air-machine.html"
  },
  {
    "label": "Macchiato",
    "id": "macchiato",
    "url": "/concepts/macchiato.html"
  },
  {
    "label": "MACE",
    "id": "mace",
    "url": "/concepts/mace.html"
  },
  {
    "label": "Machiavelli",
    "id": "machiavelli",
    "url": "/concepts/machiavelli.html"
  },
  {
    "label": "Macintosh Common Lisp",
    "id": "macintosh-common-lisp",
    "url": "/concepts/macintosh-common-lisp.html"
  },
  {
    "label": "Macintosh",
    "id": "macintosh-machine",
    "url": "/concepts/macintosh-machine.html"
  },
  {
    "label": "MACRO-10",
    "id": "macro-10",
    "url": "/concepts/macro-10.html"
  },
  {
    "label": "MACRO-11",
    "id": "macro-11",
    "url": "/concepts/macro-11.html"
  },
  {
    "label": "Macro SPITBOL",
    "id": "macro-spitbol",
    "url": "/concepts/macro-spitbol.html"
  },
  {
    "label": "MACRO",
    "id": "macro",
    "url": "/concepts/macro.html"
  },
  {
    "label": "MacroML",
    "id": "macroml",
    "url": "/concepts/macroml.html"
  },
  {
    "label": "Project MAC’s SYmbolic MAnipulator",
    "id": "macsyma",
    "url": "/concepts/macsyma.html"
  },
  {
    "label": "Michigan Algorithm Decoder",
    "id": "mad",
    "url": "/concepts/mad.html"
  },
  {
    "label": "MADCAP VI",
    "id": "madcap-vi",
    "url": "/concepts/madcap-vi.html"
  },
  {
    "label": "MADCAP",
    "id": "madcap",
    "url": "/concepts/madcap.html"
  },
  {
    "label": "MADS",
    "id": "mads",
    "url": "/concepts/mads.html"
  },
  {
    "label": "mages",
    "id": "mages",
    "url": "/concepts/mages.html"
  },
  {
    "label": "Magic Paper",
    "id": "magic-paper",
    "url": "/concepts/magic-paper.html"
  },
  {
    "label": "Magik",
    "id": "magik",
    "url": "/concepts/magik.html"
  },
  {
    "label": "Magit",
    "id": "magit",
    "url": "/concepts/magit.html"
  },
  {
    "label": "MAGMA",
    "id": "magma",
    "url": "/concepts/magma.html"
  },
  {
    "label": "Magma2",
    "id": "magma2",
    "url": "/concepts/magma2.html"
  },
  {
    "label": "magritte",
    "id": "magritte",
    "url": "/concepts/magritte.html"
  },
  {
    "label": "MAI Basic Four",
    "id": "mai-basic-four",
    "url": "/concepts/mai-basic-four.html"
  },
  {
    "label": "mai",
    "id": "mai",
    "url": "/concepts/mai.html"
  },
  {
    "label": "Make",
    "id": "make",
    "url": "/concepts/make.html"
  },
  {
    "label": "MakeDoc",
    "id": "makedoc",
    "url": "/concepts/makedoc.html"
  },
  {
    "label": "Makefile",
    "id": "makefile",
    "url": "/concepts/makefile.html"
  },
  {
    "label": "Mako",
    "id": "mako",
    "url": "/concepts/mako.html"
  },
  {
    "label": "mal",
    "id": "mal",
    "url": "/concepts/mal.html"
  },
  {
    "label": "Malbolge",
    "id": "malbolge",
    "url": "/concepts/malbolge.html"
  },
  {
    "label": "Mallard BASIC",
    "id": "mallard-basic",
    "url": "/concepts/mallard-basic.html"
  },
  {
    "label": "MALUS",
    "id": "malus",
    "url": "/concepts/malus.html"
  },
  {
    "label": "Mama",
    "id": "mama-software",
    "url": "/concepts/mama-software.html"
  },
  {
    "label": "MML",
    "id": "man-machine-language",
    "url": "/concepts/man-machine-language.html"
  },
  {
    "label": "Manchester syntax",
    "id": "manchester-syntax",
    "url": "/concepts/manchester-syntax.html"
  },
  {
    "label": "Mangle",
    "id": "mangle",
    "url": "/concepts/mangle.html"
  },
  {
    "label": "manhood",
    "id": "manhood",
    "url": "/concepts/manhood.html"
  },
  {
    "label": "Manim",
    "id": "manim",
    "url": "/concepts/manim.html"
  },
  {
    "label": "manool",
    "id": "manool",
    "url": "/concepts/manool.html"
  },
  {
    "label": "manticore",
    "id": "manticore",
    "url": "/concepts/manticore.html"
  },
  {
    "label": "ManuScript",
    "id": "manuscript",
    "url": "/concepts/manuscript.html"
  },
  {
    "label": "MAP",
    "id": "map",
    "url": "/concepts/map.html"
  },
  {
    "label": "MapBasic",
    "id": "mapbasic",
    "url": "/concepts/mapbasic.html"
  },
  {
    "label": "Maple",
    "id": "maple",
    "url": "/concepts/maple.html"
  },
  {
    "label": "Maplesoft Application Center",
    "id": "maplesoft-app-center-pm",
    "url": "/concepts/maplesoft-app-center-pm.html"
  },
  {
    "label": "MAPPER",
    "id": "mapper",
    "url": "/concepts/mapper.html"
  },
  {
    "label": "MAPQUERY",
    "id": "mapquery",
    "url": "/concepts/mapquery.html"
  },
  {
    "label": "MAPS",
    "id": "maps",
    "url": "/concepts/maps.html"
  },
  {
    "label": "maraca-lang",
    "id": "maraca-lang",
    "url": "/concepts/maraca-lang.html"
  },
  {
    "label": "Margin",
    "id": "margin",
    "url": "/concepts/margin.html"
  },
  {
    "label": "MariaDB ColumnStore",
    "id": "maria-db-column-store",
    "url": "/concepts/maria-db-column-store.html"
  },
  {
    "label": "MARIA XML",
    "id": "maria-xml",
    "url": "/concepts/maria-xml.html"
  },
  {
    "label": "MariaDB",
    "id": "mariadb",
    "url": "/concepts/mariadb.html"
  },
  {
    "label": "MARK IV",
    "id": "mark-iv",
    "url": "/concepts/mark-iv.html"
  },
  {
    "label": "Markdeep",
    "id": "markdeep",
    "url": "/concepts/markdeep.html"
  },
  {
    "label": "Markdown",
    "id": "markdown",
    "url": "/concepts/markdown.html"
  },
  {
    "label": "MarkLogic",
    "id": "marklogic",
    "url": "/concepts/marklogic.html"
  },
  {
    "label": "Marko",
    "id": "marko",
    "url": "/concepts/marko.html"
  },
  {
    "label": "MarkovJunior",
    "id": "markovjunior",
    "url": "/concepts/markovjunior.html"
  },
  {
    "label": "Markus",
    "id": "markus",
    "url": "/concepts/markus.html"
  },
  {
    "label": "Markwhen",
    "id": "markwhen",
    "url": "/concepts/markwhen.html"
  },
  {
    "label": "Marlais",
    "id": "marlais",
    "url": "/concepts/marlais.html"
  },
  {
    "label": "Marmot",
    "id": "marmot",
    "url": "/concepts/marmot.html"
  },
  {
    "label": "Marp",
    "id": "marp",
    "url": "/concepts/marp.html"
  },
  {
    "label": "MARSYAS",
    "id": "marsyas",
    "url": "/concepts/marsyas.html"
  },
  {
    "label": "marten",
    "id": "marten",
    "url": "/concepts/marten.html"
  },
  {
    "label": "Mary/2",
    "id": "mary-2",
    "url": "/concepts/mary-2.html"
  },
  {
    "label": "Mary",
    "id": "mary",
    "url": "/concepts/mary.html"
  },
  {
    "label": "Mascara",
    "id": "mascara",
    "url": "/concepts/mascara.html"
  },
  {
    "label": "MASIM",
    "id": "masim",
    "url": "/concepts/masim.html"
  },
  {
    "label": "Mask",
    "id": "maskjs",
    "url": "/concepts/maskjs.html"
  },
  {
    "label": "MASM",
    "id": "masm",
    "url": "/concepts/masm.html"
  },
  {
    "label": "Mass Energy Equation",
    "id": "mass-energy-equation",
    "url": "/concepts/mass-energy-equation.html"
  },
  {
    "label": "MXF",
    "id": "material-exchange-format",
    "url": "/concepts/material-exchange-format.html"
  },
  {
    "label": "MATH-MATIC",
    "id": "math-matic",
    "url": "/concepts/math-matic.html"
  },
  {
    "label": "Mathcad",
    "id": "mathcad",
    "url": "/concepts/mathcad.html"
  },
  {
    "label": "Wolfram Mathematica",
    "id": "mathematica-editor",
    "url": "/concepts/mathematica-editor.html"
  },
  {
    "label": "mathematica-packagedata-pm",
    "id": "mathematica-packagedata-pm",
    "url": "/concepts/mathematica-packagedata-pm.html"
  },
  {
    "label": "Mathematica",
    "id": "mathematica",
    "url": "/concepts/mathematica.html"
  },
  {
    "label": "mathics",
    "id": "mathics",
    "url": "/concepts/mathics.html"
  },
  {
    "label": "MathJax",
    "id": "mathjax",
    "url": "/concepts/mathjax.html"
  },
  {
    "label": "MATHLAB",
    "id": "mathlab",
    "url": "/concepts/mathlab.html"
  },
  {
    "label": "MathLingua",
    "id": "mathlingua",
    "url": "/concepts/mathlingua.html"
  },
  {
    "label": "MathML",
    "id": "mathml",
    "url": "/concepts/mathml.html"
  },
  {
    "label": "Mathpix Markdown",
    "id": "mathpix-markdown",
    "url": "/concepts/mathpix-markdown.html"
  },
  {
    "label": "Mathsy",
    "id": "mathsy",
    "url": "/concepts/mathsy.html"
  },
  {
    "label": "MathType",
    "id": "mathtype",
    "url": "/concepts/mathtype.html"
  },
  {
    "label": "MathWorks File Exchange",
    "id": "mathworks-file-exchange-pm",
    "url": "/concepts/mathworks-file-exchange-pm.html"
  },
  {
    "label": "Matita",
    "id": "matita",
    "url": "/concepts/matita.html"
  },
  {
    "label": "MATLAB",
    "id": "matlab",
    "url": "/concepts/matlab.html"
  },
  {
    "label": "Matplotlib",
    "id": "matplotlib",
    "url": "/concepts/matplotlib.html"
  },
  {
    "label": "MATRIX PASCAL",
    "id": "matrix-pascal",
    "url": "/concepts/matrix-pascal.html"
  },
  {
    "label": "Matrix protocol",
    "id": "matrix-protocol",
    "url": "/concepts/matrix-protocol.html"
  },
  {
    "label": "Maude",
    "id": "maude",
    "url": "/concepts/maude.html"
  },
  {
    "label": "Maven Central Repository",
    "id": "maven-pm",
    "url": "/concepts/maven-pm.html"
  },
  {
    "label": "Apache Maven",
    "id": "maven-pom",
    "url": "/concepts/maven-pom.html"
  },
  {
    "label": "MAVIS",
    "id": "mavis",
    "url": "/concepts/mavis.html"
  },
  {
    "label": "mavo",
    "id": "mavo",
    "url": "/concepts/mavo.html"
  },
  {
    "label": "mawk",
    "id": "mawk",
    "url": "/concepts/mawk.html"
  },
  {
    "label": "Max",
    "id": "max",
    "url": "/concepts/max.html"
  },
  {
    "label": "Maxima",
    "id": "maxima",
    "url": "/concepts/maxima.html"
  },
  {
    "label": "MAXScript",
    "id": "maxscript",
    "url": "/concepts/maxscript.html"
  },
  {
    "label": "Maya Embedded Language",
    "id": "maya",
    "url": "/concepts/maya.html"
  },
  {
    "label": "MBASIC",
    "id": "mbasic",
    "url": "/concepts/mbasic.html"
  },
  {
    "label": "EML",
    "id": "mbox",
    "url": "/concepts/mbox.html"
  },
  {
    "label": "mckeeman-form",
    "id": "mckeeman-form",
    "url": "/concepts/mckeeman-form.html"
  },
  {
    "label": "McLeyvier Command Language",
    "id": "mcleyvier-command-language",
    "url": "/concepts/mcleyvier-command-language.html"
  },
  {
    "label": "MCOBOL",
    "id": "mcobol",
    "url": "/concepts/mcobol.html"
  },
  {
    "label": "MD5",
    "id": "md5-hash-function",
    "url": "/concepts/md5-hash-function.html"
  },
  {
    "label": "MDBS-QRS",
    "id": "mdbs-qrs",
    "url": "/concepts/mdbs-qrs.html"
  },
  {
    "label": "MDL",
    "id": "mdl",
    "url": "/concepts/mdl.html"
  },
  {
    "label": "MultiDimensional eXpressions",
    "id": "mdx-lang",
    "url": "/concepts/mdx-lang.html"
  },
  {
    "label": "MDX",
    "id": "mdx",
    "url": "/concepts/mdx.html"
  },
  {
    "label": "MeanscriptCLI",
    "id": "meanscriptcli",
    "url": "/concepts/meanscriptcli.html"
  },
  {
    "label": "Mech",
    "id": "mech-lang",
    "url": "/concepts/mech-lang.html"
  },
  {
    "label": "MediaWiki",
    "id": "mediawiki",
    "url": "/concepts/mediawiki.html"
  },
  {
    "label": "MEDIC",
    "id": "medic",
    "url": "/concepts/medic.html"
  },
  {
    "label": "MEDUSA",
    "id": "medusa",
    "url": "/concepts/medusa.html"
  },
  {
    "label": "Megalog",
    "id": "megalog",
    "url": "/concepts/megalog.html"
  },
  {
    "label": "Megaparsec",
    "id": "megaparsec",
    "url": "/concepts/megaparsec.html"
  },
  {
    "label": "MELD",
    "id": "meld",
    "url": "/concepts/meld.html"
  },
  {
    "label": "Melody",
    "id": "melody",
    "url": "/concepts/melody.html"
  },
  {
    "label": "melpha-pm",
    "id": "melpha-pm",
    "url": "/concepts/melpha-pm.html"
  },
  {
    "label": "Memcached",
    "id": "memcached",
    "url": "/concepts/memcached.html"
  },
  {
    "label": "Memex",
    "id": "memex-machine",
    "url": "/concepts/memex-machine.html"
  },
  {
    "label": "MENDEL",
    "id": "mendel",
    "url": "/concepts/mendel.html"
  },
  {
    "label": "Mentat",
    "id": "mentat",
    "url": "/concepts/mentat.html"
  },
  {
    "label": "Mercurial",
    "id": "mercurial",
    "url": "/concepts/mercurial.html"
  },
  {
    "label": "Mercury Programming System",
    "id": "mercury-programming-system",
    "url": "/concepts/mercury-programming-system.html"
  },
  {
    "label": "Mercury",
    "id": "mercury",
    "url": "/concepts/mercury.html"
  },
  {
    "label": "merd",
    "id": "merd",
    "url": "/concepts/merd.html"
  },
  {
    "label": "mermaid",
    "id": "mermaid",
    "url": "/concepts/mermaid.html"
  },
  {
    "label": "Meroon",
    "id": "meroon",
    "url": "/concepts/meroon.html"
  },
  {
    "label": "Mesa",
    "id": "mesa",
    "url": "/concepts/mesa.html"
  },
  {
    "label": "Meson",
    "id": "meson",
    "url": "/concepts/meson.html"
  },
  {
    "label": "MessagePack",
    "id": "messagepack",
    "url": "/concepts/messagepack.html"
  },
  {
    "label": "Met-English",
    "id": "met-english",
    "url": "/concepts/met-english.html"
  },
  {
    "label": "Meta-Assembler",
    "id": "meta-assembler",
    "url": "/concepts/meta-assembler.html"
  },
  {
    "label": "Meta II",
    "id": "meta-ii",
    "url": "/concepts/meta-ii.html"
  },
  {
    "label": "META/LISP",
    "id": "meta-lisp",
    "url": "/concepts/meta-lisp.html"
  },
  {
    "label": "META/PLUS",
    "id": "meta-plus",
    "url": "/concepts/meta-plus.html"
  },
  {
    "label": "MetaComCo",
    "id": "metacomco",
    "url": "/concepts/metacomco.html"
  },
  {
    "label": "METAFONT",
    "id": "metafont",
    "url": "/concepts/metafont.html"
  },
  {
    "label": "MetaH",
    "id": "metah",
    "url": "/concepts/metah.html"
  },
  {
    "label": "MetaL",
    "id": "metal-programming-language",
    "url": "/concepts/metal-programming-language.html"
  },
  {
    "label": "Metal",
    "id": "metal",
    "url": "/concepts/metal.html"
  },
  {
    "label": "Metalang99",
    "id": "metalang99",
    "url": "/concepts/metalang99.html"
  },
  {
    "label": "metalex",
    "id": "metalex",
    "url": "/concepts/metalex.html"
  },
  {
    "label": "MetaML",
    "id": "metaml",
    "url": "/concepts/metaml.html"
  },
  {
    "label": "METAPI",
    "id": "metapi",
    "url": "/concepts/metapi.html"
  },
  {
    "label": "METAPOST",
    "id": "metapost",
    "url": "/concepts/metapost.html"
  },
  {
    "label": "METASIM",
    "id": "metasim",
    "url": "/concepts/metasim.html"
  },
  {
    "label": "METATEM",
    "id": "metatem",
    "url": "/concepts/metatem.html"
  },
  {
    "label": "Metaweb Query Language",
    "id": "metaweb-query-language",
    "url": "/concepts/metaweb-query-language.html"
  },
  {
    "label": "MDL",
    "id": "methodology-description-language",
    "url": "/concepts/methodology-description-language.html"
  },
  {
    "label": "Mewl",
    "id": "mewl",
    "url": "/concepts/mewl.html"
  },
  {
    "label": "MewMew",
    "id": "mewmew",
    "url": "/concepts/mewmew.html"
  },
  {
    "label": "mgmt",
    "id": "mgmt",
    "url": "/concepts/mgmt.html"
  },
  {
    "label": "MHEG-5",
    "id": "mheg-5",
    "url": "/concepts/mheg-5.html"
  },
  {
    "label": "michelson",
    "id": "michelson",
    "url": "/concepts/michelson.html"
  },
  {
    "label": "ΜC++",
    "id": "micro-cpp",
    "url": "/concepts/micro-cpp.html"
  },
  {
    "label": "micro-editor",
    "id": "micro-editor",
    "url": "/concepts/micro-editor.html"
  },
  {
    "label": "Micro-flowcharts",
    "id": "micro-flowcharts",
    "url": "/concepts/micro-flowcharts.html"
  },
  {
    "label": "micro-mitten",
    "id": "micro-mitten",
    "url": "/concepts/micro-mitten.html"
  },
  {
    "label": "Micro-PROLOG",
    "id": "micro-prolog",
    "url": "/concepts/micro-prolog.html"
  },
  {
    "label": "mdl",
    "id": "microarchitecture-description-language",
    "url": "/concepts/microarchitecture-description-language.html"
  },
  {
    "label": "MICRODARE",
    "id": "microdare",
    "url": "/concepts/microdare.html"
  },
  {
    "label": "Microdata HTML",
    "id": "microdata",
    "url": "/concepts/microdata.html"
  },
  {
    "label": "microl",
    "id": "microl",
    "url": "/concepts/microl.html"
  },
  {
    "label": "microPLANNER",
    "id": "microplanner",
    "url": "/concepts/microplanner.html"
  },
  {
    "label": "MicroPython",
    "id": "micropython",
    "url": "/concepts/micropython.html"
  },
  {
    "label": "Microsoft Access",
    "id": "microsoft-access",
    "url": "/concepts/microsoft-access.html"
  },
  {
    "label": "Microsoft Azure Cosmos DB",
    "id": "microsoft-azure-cosmos-db",
    "url": "/concepts/microsoft-azure-cosmos-db.html"
  },
  {
    "label": "Microsoft BASIC",
    "id": "microsoft-basic",
    "url": "/concepts/microsoft-basic.html"
  },
  {
    "label": "Microsoft Equation Editor",
    "id": "microsoft-equation-editor",
    "url": "/concepts/microsoft-equation-editor.html"
  },
  {
    "label": "Microsoft Macro Assembler",
    "id": "microsoft-macro-assembler",
    "url": "/concepts/microsoft-macro-assembler.html"
  },
  {
    "label": "Microsoft SQL Server",
    "id": "microsoft-mysql-server",
    "url": "/concepts/microsoft-mysql-server.html"
  },
  {
    "label": "Microsoft Small Basic",
    "id": "microsoft-small-basic",
    "url": "/concepts/microsoft-small-basic.html"
  },
  {
    "label": "microTAL",
    "id": "microtal",
    "url": "/concepts/microtal.html"
  },
  {
    "label": "Modified Integration Digital Analog Simulator",
    "id": "midas",
    "url": "/concepts/midas.html"
  },
  {
    "label": "Meditech Interpretive Information System",
    "id": "miis",
    "url": "/concepts/miis.html"
  },
  {
    "label": "MiKe",
    "id": "mike",
    "url": "/concepts/mike.html"
  },
  {
    "label": "MIME",
    "id": "mime",
    "url": "/concepts/mime.html"
  },
  {
    "label": "MIMIC",
    "id": "mimic",
    "url": "/concepts/mimic.html"
  },
  {
    "label": "mimium",
    "id": "mimium",
    "url": "/concepts/mimium.html"
  },
  {
    "label": "mimix-stream-language",
    "id": "mimix-stream-language",
    "url": "/concepts/mimix-stream-language.html"
  },
  {
    "label": "min",
    "id": "min",
    "url": "/concepts/min.html"
  },
  {
    "label": "MINC",
    "id": "minc",
    "url": "/concepts/minc.html"
  },
  {
    "label": "Mini-ML",
    "id": "mini-ml",
    "url": "/concepts/mini-ml.html"
  },
  {
    "label": "MiniD",
    "id": "minid",
    "url": "/concepts/minid.html"
  },
  {
    "label": "Mindsdb",
    "id": "minidsdb",
    "url": "/concepts/minidsdb.html"
  },
  {
    "label": "minihaskell",
    "id": "minihaskell",
    "url": "/concepts/minihaskell.html"
  },
  {
    "label": "minikanren",
    "id": "minikanren",
    "url": "/concepts/minikanren.html"
  },
  {
    "label": "Minilang",
    "id": "minilang",
    "url": "/concepts/minilang.html"
  },
  {
    "label": "miniML_error",
    "id": "miniml-error",
    "url": "/concepts/miniml-error.html"
  },
  {
    "label": "miniml",
    "id": "miniml",
    "url": "/concepts/miniml.html"
  },
  {
    "label": "MINION",
    "id": "minion",
    "url": "/concepts/minion.html"
  },
  {
    "label": "miniprolog",
    "id": "miniprolog",
    "url": "/concepts/miniprolog.html"
  },
  {
    "label": "MINIVITAL",
    "id": "minivital",
    "url": "/concepts/minivital.html"
  },
  {
    "label": "MiniZinc",
    "id": "minizinc",
    "url": "/concepts/minizinc.html"
  },
  {
    "label": "MINOPT",
    "id": "minopt",
    "url": "/concepts/minopt.html"
  },
  {
    "label": "mint",
    "id": "mint",
    "url": "/concepts/mint.html"
  },
  {
    "label": "MIPS architecture",
    "id": "mips",
    "url": "/concepts/mips.html"
  },
  {
    "label": "mir",
    "id": "mir",
    "url": "/concepts/mir.html"
  },
  {
    "label": "MIRAGER",
    "id": "mirager",
    "url": "/concepts/mirager.html"
  },
  {
    "label": "Mirah",
    "id": "mirah",
    "url": "/concepts/mirah.html"
  },
  {
    "label": "Miranda",
    "id": "miranda",
    "url": "/concepts/miranda.html"
  },
  {
    "label": "Miranim",
    "id": "miranim",
    "url": "/concepts/miranim.html"
  },
  {
    "label": "MIRC scripting language",
    "id": "mirc",
    "url": "/concepts/mirc.html"
  },
  {
    "label": "MIRFAC",
    "id": "mirfac",
    "url": "/concepts/mirfac.html"
  },
  {
    "label": "mirth",
    "id": "mirth",
    "url": "/concepts/mirth.html"
  },
  {
    "label": "miso-framework",
    "id": "miso-framework",
    "url": "/concepts/miso-framework.html"
  },
  {
    "label": "Miva",
    "id": "miva",
    "url": "/concepts/miva.html"
  },
  {
    "label": "Mizar",
    "id": "mizar",
    "url": "/concepts/mizar.html"
  },
  {
    "label": "ML",
    "id": "ml",
    "url": "/concepts/ml.html"
  },
  {
    "label": "MLAB",
    "id": "mlab",
    "url": "/concepts/mlab.html"
  },
  {
    "label": "mlatu",
    "id": "mlatu",
    "url": "/concepts/mlatu.html"
  },
  {
    "label": "mlir",
    "id": "mlir",
    "url": "/concepts/mlir.html"
  },
  {
    "label": "MLISP2",
    "id": "mlisp2",
    "url": "/concepts/mlisp2.html"
  },
  {
    "label": "mlite",
    "id": "mlite",
    "url": "/concepts/mlite.html"
  },
  {
    "label": "mlpolyr",
    "id": "mlpolyr",
    "url": "/concepts/mlpolyr.html"
  },
  {
    "label": "mmix",
    "id": "mmix",
    "url": "/concepts/mmix.html"
  },
  {
    "label": "mmsearch",
    "id": "mmsearch",
    "url": "/concepts/mmsearch.html"
  },
  {
    "label": "MMX instruction set",
    "id": "mmx",
    "url": "/concepts/mmx.html"
  },
  {
    "label": "Mobl",
    "id": "mobl-lang",
    "url": "/concepts/mobl-lang.html"
  },
  {
    "label": "MOBL",
    "id": "mobl",
    "url": "/concepts/mobl.html"
  },
  {
    "label": "Moby",
    "id": "moby-programming-language",
    "url": "/concepts/moby-programming-language.html"
  },
  {
    "label": "mochajs",
    "id": "mochajs",
    "url": "/concepts/mochajs.html"
  },
  {
    "label": "mochi",
    "id": "mochi",
    "url": "/concepts/mochi.html"
  },
  {
    "label": "mockingbird-notation",
    "id": "mockingbird-notation",
    "url": "/concepts/mockingbird-notation.html"
  },
  {
    "label": "Mocklisp",
    "id": "mocklisp",
    "url": "/concepts/mocklisp.html"
  },
  {
    "label": "MODCAP",
    "id": "modcap",
    "url": "/concepts/modcap.html"
  },
  {
    "label": "Model 204",
    "id": "model-204",
    "url": "/concepts/model-204.html"
  },
  {
    "label": "MODEL-K",
    "id": "model-k",
    "url": "/concepts/model-k.html"
  },
  {
    "label": "Modelica",
    "id": "modelica",
    "url": "/concepts/modelica.html"
  },
  {
    "label": "modl",
    "id": "modl",
    "url": "/concepts/modl.html"
  },
  {
    "label": "MODLISP",
    "id": "modlisp",
    "url": "/concepts/modlisp.html"
  },
  {
    "label": "MODSIM III",
    "id": "modsim-iii",
    "url": "/concepts/modsim-iii.html"
  },
  {
    "label": "Modula-2",
    "id": "modula-2",
    "url": "/concepts/modula-2.html"
  },
  {
    "label": "Modula-2+",
    "id": "modula-2p",
    "url": "/concepts/modula-2p.html"
  },
  {
    "label": "Modula-3*",
    "id": "modula-3-star",
    "url": "/concepts/modula-3-star.html"
  },
  {
    "label": "Modula-3",
    "id": "modula-3",
    "url": "/concepts/modula-3.html"
  },
  {
    "label": "Modula-P",
    "id": "modula-p",
    "url": "/concepts/modula-p.html"
  },
  {
    "label": "Modula/R",
    "id": "modula-r",
    "url": "/concepts/modula-r.html"
  },
  {
    "label": "Modula",
    "id": "modula",
    "url": "/concepts/modula.html"
  },
  {
    "label": "Modular Prolog",
    "id": "modular-prolog",
    "url": "/concepts/modular-prolog.html"
  },
  {
    "label": "Module Management System",
    "id": "module-management-system",
    "url": "/concepts/module-management-system.html"
  },
  {
    "label": "Moescript",
    "id": "moescript",
    "url": "/concepts/moescript.html"
  },
  {
    "label": "moinmoin",
    "id": "moinmoin",
    "url": "/concepts/moinmoin.html"
  },
  {
    "label": "Mojo",
    "id": "mojo",
    "url": "/concepts/mojo.html"
  },
  {
    "label": "Molecular Query Language",
    "id": "molecular-query-language",
    "url": "/concepts/molecular-query-language.html"
  },
  {
    "label": "Molfile",
    "id": "molfile-format",
    "url": "/concepts/molfile-format.html"
  },
  {
    "label": "Molog",
    "id": "molog",
    "url": "/concepts/molog.html"
  },
  {
    "label": "Monaco Editor",
    "id": "monaco",
    "url": "/concepts/monaco.html"
  },
  {
    "label": "Mond",
    "id": "mond",
    "url": "/concepts/mond.html"
  },
  {
    "label": "Monesa",
    "id": "monesa",
    "url": "/concepts/monesa.html"
  },
  {
    "label": "MongoDB",
    "id": "mongodb",
    "url": "/concepts/mongodb.html"
  },
  {
    "label": "Monkey",
    "id": "monkey",
    "url": "/concepts/monkey.html"
  },
  {
    "label": "MonoDevelop",
    "id": "monodevelop-editor",
    "url": "/concepts/monodevelop-editor.html"
  },
  {
    "label": "monte",
    "id": "monte",
    "url": "/concepts/monte.html"
  },
  {
    "label": "MOO",
    "id": "moo",
    "url": "/concepts/moo.html"
  },
  {
    "label": "MINI OBJECT-ORIENTED LANGUAGE",
    "id": "mool",
    "url": "/concepts/mool.html"
  },
  {
    "label": "Moonrock Basic Compiler",
    "id": "moonrock-basic-compiler",
    "url": "/concepts/moonrock-basic-compiler.html"
  },
  {
    "label": "MoonScript",
    "id": "moonscript",
    "url": "/concepts/moonscript.html"
  },
  {
    "label": "MOOSE",
    "id": "moose",
    "url": "/concepts/moose.html"
  },
  {
    "label": "morfa",
    "id": "morfa",
    "url": "/concepts/morfa.html"
  },
  {
    "label": "Morfik",
    "id": "morfik",
    "url": "/concepts/morfik.html"
  },
  {
    "label": "Morphe",
    "id": "morphe",
    "url": "/concepts/morphe.html"
  },
  {
    "label": "MORPHISM",
    "id": "morphism",
    "url": "/concepts/morphism.html"
  },
  {
    "label": "Morse code",
    "id": "morse-code",
    "url": "/concepts/morse-code.html"
  },
  {
    "label": "Mortran",
    "id": "mortran",
    "url": "/concepts/mortran.html"
  },
  {
    "label": "Motif",
    "id": "motif-software",
    "url": "/concepts/motif-software.html"
  },
  {
    "label": "mountain",
    "id": "mountain",
    "url": "/concepts/mountain.html"
  },
  {
    "label": "Mouse",
    "id": "mouse",
    "url": "/concepts/mouse.html"
  },
  {
    "label": "MOUSE4",
    "id": "mouse4",
    "url": "/concepts/mouse4.html"
  },
  {
    "label": "Moxie",
    "id": "moxie",
    "url": "/concepts/moxie.html"
  },
  {
    "label": "moya",
    "id": "moya",
    "url": "/concepts/moya.html"
  },
  {
    "label": "MP3",
    "id": "mp3-format",
    "url": "/concepts/mp3-format.html"
  },
  {
    "label": "MPGS",
    "id": "mpgs",
    "url": "/concepts/mpgs.html"
  },
  {
    "label": "mpl",
    "id": "mpl",
    "url": "/concepts/mpl.html"
  },
  {
    "label": "MPS",
    "id": "mps",
    "url": "/concepts/mps.html"
  },
  {
    "label": "MPSX",
    "id": "mpsx",
    "url": "/concepts/mpsx.html"
  },
  {
    "label": "MQL5",
    "id": "mql",
    "url": "/concepts/mql.html"
  },
  {
    "label": "Message Queuing Telemetry Transport",
    "id": "mqtt",
    "url": "/concepts/mqtt.html"
  },
  {
    "label": "MRDB",
    "id": "mrdb",
    "url": "/concepts/mrdb.html"
  },
  {
    "label": "MS2",
    "id": "ms2",
    "url": "/concepts/ms2.html"
  },
  {
    "label": "Mscgen",
    "id": "mscgen",
    "url": "/concepts/mscgen.html"
  },
  {
    "label": "MSG.84",
    "id": "msg-84",
    "url": "/concepts/msg-84.html"
  },
  {
    "label": "MSL",
    "id": "msl",
    "url": "/concepts/msl.html"
  },
  {
    "label": "TI MSP430",
    "id": "msp430",
    "url": "/concepts/msp430.html"
  },
  {
    "label": "MSX BASIC",
    "id": "msx-basic",
    "url": "/concepts/msx-basic.html"
  },
  {
    "label": "Marine Trading Markup Language",
    "id": "mtml",
    "url": "/concepts/mtml.html"
  },
  {
    "label": "Mu",
    "id": "mu",
    "url": "/concepts/mu.html"
  },
  {
    "label": "MUDDL",
    "id": "muddl",
    "url": "/concepts/muddl.html"
  },
  {
    "label": "Mudlle",
    "id": "mudlle",
    "url": "/concepts/mudlle.html"
  },
  {
    "label": "Multi-User Forth",
    "id": "muf",
    "url": "/concepts/muf.html"
  },
  {
    "label": "muFP",
    "id": "mufp",
    "url": "/concepts/mufp.html"
  },
  {
    "label": "Mul-T",
    "id": "mul-t",
    "url": "/concepts/mul-t.html"
  },
  {
    "label": "Multi-user BASIC",
    "id": "multi-user-basic",
    "url": "/concepts/multi-user-basic.html"
  },
  {
    "label": "multiaddr",
    "id": "multiaddr",
    "url": "/concepts/multiaddr.html"
  },
  {
    "label": "multibase",
    "id": "multibase",
    "url": "/concepts/multibase.html"
  },
  {
    "label": "multicodec",
    "id": "multicodec",
    "url": "/concepts/multicodec.html"
  },
  {
    "label": "Multics",
    "id": "multics",
    "url": "/concepts/multics.html"
  },
  {
    "label": "Multigame",
    "id": "multigame",
    "url": "/concepts/multigame.html"
  },
  {
    "label": "Multihash",
    "id": "multihash-hash-function",
    "url": "/concepts/multihash-hash-function.html"
  },
  {
    "label": "muMath",
    "id": "mumath",
    "url": "/concepts/mumath.html"
  },
  {
    "label": "MUMPS",
    "id": "mumps",
    "url": "/concepts/mumps.html"
  },
  {
    "label": "MUMS",
    "id": "mums",
    "url": "/concepts/mums.html"
  },
  {
    "label": "mun-lang",
    "id": "mun-lang",
    "url": "/concepts/mun-lang.html"
  },
  {
    "label": "MUNIN",
    "id": "munin",
    "url": "/concepts/munin.html"
  },
  {
    "label": "muon",
    "id": "muon",
    "url": "/concepts/muon.html"
  },
  {
    "label": "muPad",
    "id": "mupad",
    "url": "/concepts/mupad.html"
  },
  {
    "label": "MurmurHash",
    "id": "murmur-hash-function",
    "url": "/concepts/murmur-hash-function.html"
  },
  {
    "label": "Mushroom",
    "id": "mushroom",
    "url": "/concepts/mushroom.html"
  },
  {
    "label": "MUSIC/SP",
    "id": "music-sp",
    "url": "/concepts/music-sp.html"
  },
  {
    "label": "MusicXML",
    "id": "musicxml",
    "url": "/concepts/musicxml.html"
  },
  {
    "label": "MuSimp",
    "id": "musimp",
    "url": "/concepts/musimp.html"
  },
  {
    "label": "MUSP",
    "id": "musp",
    "url": "/concepts/musp.html"
  },
  {
    "label": "mustache",
    "id": "mustache",
    "url": "/concepts/mustache.html"
  },
  {
    "label": "MUSYS",
    "id": "musys",
    "url": "/concepts/musys.html"
  },
  {
    "label": "MVEL",
    "id": "mvel",
    "url": "/concepts/mvel.html"
  },
  {
    "label": "MVL",
    "id": "mvl",
    "url": "/concepts/mvl.html"
  },
  {
    "label": "MXML",
    "id": "mxml",
    "url": "/concepts/mxml.html"
  },
  {
    "label": "MyBB",
    "id": "mybb",
    "url": "/concepts/mybb.html"
  },
  {
    "label": "mycroft",
    "id": "mycroft",
    "url": "/concepts/mycroft.html"
  },
  {
    "label": "Myghty",
    "id": "myghty",
    "url": "/concepts/myghty.html"
  },
  {
    "label": "myia",
    "id": "myia",
    "url": "/concepts/myia.html"
  },
  {
    "label": "mypy",
    "id": "mypy",
    "url": "/concepts/mypy.html"
  },
  {
    "label": "myrddin",
    "id": "myrddin",
    "url": "/concepts/myrddin.html"
  },
  {
    "label": "mys",
    "id": "mys",
    "url": "/concepts/mys.html"
  },
  {
    "label": "MySQL",
    "id": "mysql",
    "url": "/concepts/mysql.html"
  },
  {
    "label": "mythryl",
    "id": "mythryl",
    "url": "/concepts/mythryl.html"
  },
  {
    "label": "N-Prolog",
    "id": "n-prolog",
    "url": "/concepts/n-prolog.html"
  },
  {
    "label": "N-Triples",
    "id": "n-triples",
    "url": "/concepts/n-triples.html"
  },
  {
    "label": "N",
    "id": "n",
    "url": "/concepts/n.html"
  },
  {
    "label": "Nadesiko",
    "id": "nadesiko",
    "url": "/concepts/nadesiko.html"
  },
  {
    "label": "Nail",
    "id": "nail",
    "url": "/concepts/nail.html"
  },
  {
    "label": "NAKL",
    "id": "nakl",
    "url": "/concepts/nakl.html"
  },
  {
    "label": "GNU nano",
    "id": "nano-editor",
    "url": "/concepts/nano-editor.html"
  },
  {
    "label": "Napier88",
    "id": "napier88",
    "url": "/concepts/napier88.html"
  },
  {
    "label": "NAPSS",
    "id": "napss",
    "url": "/concepts/napss.html"
  },
  {
    "label": "NARPL",
    "id": "narpl",
    "url": "/concepts/narpl.html"
  },
  {
    "label": "Nasal",
    "id": "nasal",
    "url": "/concepts/nasal.html"
  },
  {
    "label": "Netwide Assembler",
    "id": "nasm",
    "url": "/concepts/nasm.html"
  },
  {
    "label": "Nassi-Shneiderman charts",
    "id": "nassi-shneiderman-charts",
    "url": "/concepts/nassi-shneiderman-charts.html"
  },
  {
    "label": "NSS",
    "id": "native-structured-storage",
    "url": "/concepts/native-structured-storage.html"
  },
  {
    "label": "NATO phonetic alphabet",
    "id": "nato-phonetic-alphabet",
    "url": "/concepts/nato-phonetic-alphabet.html"
  },
  {
    "label": "NATURAL",
    "id": "natural",
    "url": "/concepts/natural.html"
  },
  {
    "label": "Navier-Stokes Equation",
    "id": "navier-stokes-equation",
    "url": "/concepts/navier-stokes-equation.html"
  },
  {
    "label": "New AWK",
    "id": "nawk",
    "url": "/concepts/nawk.html"
  },
  {
    "label": "NCAR Command Language",
    "id": "ncar-command-language",
    "url": "/concepts/ncar-command-language.html"
  },
  {
    "label": "NCAR Command Language",
    "id": "ncl",
    "url": "/concepts/ncl.html"
  },
  {
    "label": "NDL",
    "id": "ndl",
    "url": "/concepts/ndl.html"
  },
  {
    "label": "Nearley",
    "id": "nearley",
    "url": "/concepts/nearley.html"
  },
  {
    "label": "NEATER 2",
    "id": "neater",
    "url": "/concepts/neater.html"
  },
  {
    "label": "NEBULA",
    "id": "nebula",
    "url": "/concepts/nebula.html"
  },
  {
    "label": "nectar",
    "id": "nectar",
    "url": "/concepts/nectar.html"
  },
  {
    "label": "neeilang",
    "id": "neeilang",
    "url": "/concepts/neeilang.html"
  },
  {
    "label": "Neko",
    "id": "neko",
    "url": "/concepts/neko.html"
  },
  {
    "label": "NELIAC",
    "id": "neliac",
    "url": "/concepts/neliac.html"
  },
  {
    "label": "Nelua",
    "id": "nelua",
    "url": "/concepts/nelua.html"
  },
  {
    "label": "Nemerle",
    "id": "nemerle",
    "url": "/concepts/nemerle.html"
  },
  {
    "label": "Neo4j",
    "id": "neo4j",
    "url": "/concepts/neo4j.html"
  },
  {
    "label": "neovim-editor",
    "id": "neovim-editor",
    "url": "/concepts/neovim-editor.html"
  },
  {
    "label": "neralie-format",
    "id": "neralie-format",
    "url": "/concepts/neralie-format.html"
  },
  {
    "label": "nesC",
    "id": "nesc",
    "url": "/concepts/nesc.html"
  },
  {
    "label": "NESL",
    "id": "nesl",
    "url": "/concepts/nesl.html"
  },
  {
    "label": "Ness",
    "id": "ness",
    "url": "/concepts/ness.html"
  },
  {
    "label": "Nested Context Language",
    "id": "nested-context-language",
    "url": "/concepts/nested-context-language.html"
  },
  {
    "label": "NestedText",
    "id": "nestedtext",
    "url": "/concepts/nestedtext.html"
  },
  {
    "label": "net-format",
    "id": "net-format",
    "url": "/concepts/net-format.html"
  },
  {
    "label": "NetBasic",
    "id": "netbasic",
    "url": "/concepts/netbasic.html"
  },
  {
    "label": "netbeans-editor",
    "id": "netbeans-editor",
    "url": "/concepts/netbeans-editor.html"
  },
  {
    "label": "Netform",
    "id": "netform",
    "url": "/concepts/netform.html"
  },
  {
    "label": "Netlib",
    "id": "netlib",
    "url": "/concepts/netlib.html"
  },
  {
    "label": "NetLinx",
    "id": "netlinx",
    "url": "/concepts/netlinx.html"
  },
  {
    "label": "NetLogo",
    "id": "netlogo",
    "url": "/concepts/netlogo.html"
  },
  {
    "label": "NetRexx",
    "id": "netrexx",
    "url": "/concepts/netrexx.html"
  },
  {
    "label": "Netscript",
    "id": "netscript",
    "url": "/concepts/netscript.html"
  },
  {
    "label": "Network Control Language",
    "id": "network-control-language",
    "url": "/concepts/network-control-language.html"
  },
  {
    "label": "NeuronC",
    "id": "neuronc",
    "url": "/concepts/neuronc.html"
  },
  {
    "label": "neut",
    "id": "neut",
    "url": "/concepts/neut.html"
  },
  {
    "label": "neutron",
    "id": "neutron",
    "url": "/concepts/neutron.html"
  },
  {
    "label": "never",
    "id": "never",
    "url": "/concepts/never.html"
  },
  {
    "label": "newclay",
    "id": "newclay",
    "url": "/concepts/newclay.html"
  },
  {
    "label": "Newick format",
    "id": "newick-format",
    "url": "/concepts/newick-format.html"
  },
  {
    "label": "NewLisp",
    "id": "newlisp",
    "url": "/concepts/newlisp.html"
  },
  {
    "label": "NEWP",
    "id": "newp",
    "url": "/concepts/newp.html"
  },
  {
    "label": "Newspeak",
    "id": "newspeak",
    "url": "/concepts/newspeak.html"
  },
  {
    "label": "Newsqueak",
    "id": "newsqueak",
    "url": "/concepts/newsqueak.html"
  },
  {
    "label": "Newton",
    "id": "newton",
    "url": "/concepts/newton.html"
  },
  {
    "label": "NewtonScript",
    "id": "newtonscript",
    "url": "/concepts/newtonscript.html"
  },
  {
    "label": "NeXML format",
    "id": "nexml",
    "url": "/concepts/nexml.html"
  },
  {
    "label": "Nextflow",
    "id": "nextflow",
    "url": "/concepts/nextflow.html"
  },
  {
    "label": "Nexus file",
    "id": "nexus-format",
    "url": "/concepts/nexus-format.html"
  },
  {
    "label": "NFQL",
    "id": "nfql",
    "url": "/concepts/nfql.html"
  },
  {
    "label": "Nginx",
    "id": "nginx-config",
    "url": "/concepts/nginx-config.html"
  },
  {
    "label": "NGL",
    "id": "ngl-programming-language",
    "url": "/concepts/ngl-programming-language.html"
  },
  {
    "label": "Noms GraphQL",
    "id": "ngql",
    "url": "/concepts/ngql.html"
  },
  {
    "label": "NGS",
    "id": "ngs",
    "url": "/concepts/ngs.html"
  },
  {
    "label": "The New Hampshire X Format",
    "id": "nhx",
    "url": "/concepts/nhx.html"
  },
  {
    "label": "Nial",
    "id": "nial",
    "url": "/concepts/nial.html"
  },
  {
    "label": "nianiolang",
    "id": "nianiolang",
    "url": "/concepts/nianiolang.html"
  },
  {
    "label": "Nice",
    "id": "nice",
    "url": "/concepts/nice.html"
  },
  {
    "label": "Nickle",
    "id": "nickle",
    "url": "/concepts/nickle.html"
  },
  {
    "label": "NIKL",
    "id": "nikl",
    "url": "/concepts/nikl.html"
  },
  {
    "label": "NIL",
    "id": "nil",
    "url": "/concepts/nil.html"
  },
  {
    "label": "NilScript",
    "id": "nilscript",
    "url": "/concepts/nilscript.html"
  },
  {
    "label": "Nim",
    "id": "nim",
    "url": "/concepts/nim.html"
  },
  {
    "label": "nimble-pm",
    "id": "nimble-pm",
    "url": "/concepts/nimble-pm.html"
  },
  {
    "label": "nimrod",
    "id": "nimrod",
    "url": "/concepts/nimrod.html"
  },
  {
    "label": "Nimskull",
    "id": "nimskull",
    "url": "/concepts/nimskull.html"
  },
  {
    "label": "Ninja",
    "id": "ninja",
    "url": "/concepts/ninja.html"
  },
  {
    "label": "Nios II",
    "id": "nios",
    "url": "/concepts/nios.html"
  },
  {
    "label": "nirvana",
    "id": "nirvana",
    "url": "/concepts/nirvana.html"
  },
  {
    "label": "Nit",
    "id": "nit",
    "url": "/concepts/nit.html"
  },
  {
    "label": "Nix",
    "id": "nix",
    "url": "/concepts/nix.html"
  },
  {
    "label": "NixOS",
    "id": "nixos",
    "url": "/concepts/nixos.html"
  },
  {
    "label": "NJCL",
    "id": "njcl",
    "url": "/concepts/njcl.html"
  },
  {
    "label": "NL",
    "id": "nl",
    "url": "/concepts/nl.html"
  },
  {
    "label": "nlpl",
    "id": "nlpl",
    "url": "/concepts/nlpl.html"
  },
  {
    "label": "Natural Language Toolkit",
    "id": "nltk",
    "url": "/concepts/nltk.html"
  },
  {
    "label": "nML",
    "id": "nml",
    "url": "/concepts/nml.html"
  },
  {
    "label": "NOAH",
    "id": "noah",
    "url": "/concepts/noah.html"
  },
  {
    "label": "NODAL",
    "id": "nodal",
    "url": "/concepts/nodal.html"
  },
  {
    "label": "Node.js",
    "id": "nodejs",
    "url": "/concepts/nodejs.html"
  },
  {
    "label": "noisecraft",
    "id": "noisecraft",
    "url": "/concepts/noisecraft.html"
  },
  {
    "label": "Nomad software",
    "id": "nomad-software",
    "url": "/concepts/nomad-software.html"
  },
  {
    "label": "noms-db",
    "id": "noms-db",
    "url": "/concepts/noms-db.html"
  },
  {
    "label": "none",
    "id": "none",
    "url": "/concepts/none.html"
  },
  {
    "label": "Noodle",
    "id": "noodle",
    "url": "/concepts/noodle.html"
  },
  {
    "label": "NOP-2",
    "id": "nop-2",
    "url": "/concepts/nop-2.html"
  },
  {
    "label": "Nord Programming Language",
    "id": "nord",
    "url": "/concepts/nord.html"
  },
  {
    "label": "Normal Distribution Equation",
    "id": "normal-distribution-equation",
    "url": "/concepts/normal-distribution-equation.html"
  },
  {
    "label": "NorthStar BASIC",
    "id": "northstar-basic",
    "url": "/concepts/northstar-basic.html"
  },
  {
    "label": "Nosica",
    "id": "nosica",
    "url": "/concepts/nosica.html"
  },
  {
    "label": "Notation3",
    "id": "notation3",
    "url": "/concepts/notation3.html"
  },
  {
    "label": "Note",
    "id": "note",
    "url": "/concepts/note.html"
  },
  {
    "label": "Microsoft Notepad",
    "id": "notepad-editor",
    "url": "/concepts/notepad-editor.html"
  },
  {
    "label": "Notepad++",
    "id": "notepad-plus-plus-editor",
    "url": "/concepts/notepad-plus-plus-editor.html"
  },
  {
    "label": "noulith",
    "id": "noulith",
    "url": "/concepts/noulith.html"
  },
  {
    "label": "Nova",
    "id": "nova-editor",
    "url": "/concepts/nova-editor.html"
  },
  {
    "label": "Noweb",
    "id": "noweb",
    "url": "/concepts/noweb.html"
  },
  {
    "label": "np",
    "id": "np",
    "url": "/concepts/np.html"
  },
  {
    "label": "NPL",
    "id": "npl-lang",
    "url": "/concepts/npl-lang.html"
  },
  {
    "label": "NPL",
    "id": "npl",
    "url": "/concepts/npl.html"
  },
  {
    "label": "npm",
    "id": "npm-pm",
    "url": "/concepts/npm-pm.html"
  },
  {
    "label": "npy",
    "id": "npy",
    "url": "/concepts/npy.html"
  },
  {
    "label": "Not Quite C",
    "id": "nqc",
    "url": "/concepts/nqc.html"
  },
  {
    "label": "Namespace Routing Language",
    "id": "nrl",
    "url": "/concepts/nrl.html"
  },
  {
    "label": "nroff",
    "id": "nroff",
    "url": "/concepts/nroff.html"
  },
  {
    "label": "NS Basic",
    "id": "ns-basic",
    "url": "/concepts/ns-basic.html"
  },
  {
    "label": "NSIS",
    "id": "nsis",
    "url": "/concepts/nsis.html"
  },
  {
    "label": "NSL",
    "id": "nsl",
    "url": "/concepts/nsl.html"
  },
  {
    "label": "New Technology File System",
    "id": "ntfs",
    "url": "/concepts/ntfs.html"
  },
  {
    "label": "Network Time Protocol",
    "id": "ntp",
    "url": "/concepts/ntp.html"
  },
  {
    "label": "NU-Prolog",
    "id": "nu-prolog",
    "url": "/concepts/nu-prolog.html"
  },
  {
    "label": "Nu",
    "id": "nu",
    "url": "/concepts/nu.html"
  },
  {
    "label": "NUA-Prolog",
    "id": "nua-prolog",
    "url": "/concepts/nua-prolog.html"
  },
  {
    "label": "NuGet",
    "id": "nuget-pm",
    "url": "/concepts/nuget-pm.html"
  },
  {
    "label": "Navigational User's Language",
    "id": "nul-lang",
    "url": "/concepts/nul-lang.html"
  },
  {
    "label": "nulan",
    "id": "nulan",
    "url": "/concepts/nulan.html"
  },
  {
    "label": "Numba",
    "id": "numba",
    "url": "/concepts/numba.html"
  },
  {
    "label": "Numbers",
    "id": "numbers-app",
    "url": "/concepts/numbers-app.html"
  },
  {
    "label": "Numerica",
    "id": "numerica",
    "url": "/concepts/numerica.html"
  },
  {
    "label": "NumPad",
    "id": "numpad",
    "url": "/concepts/numpad.html"
  },
  {
    "label": "NumPy",
    "id": "numpy",
    "url": "/concepts/numpy.html"
  },
  {
    "label": "Nuprl",
    "id": "nuprl",
    "url": "/concepts/nuprl.html"
  },
  {
    "label": "Nushell",
    "id": "nushell",
    "url": "/concepts/nushell.html"
  },
  {
    "label": "NUT",
    "id": "nut",
    "url": "/concepts/nut.html"
  },
  {
    "label": "Nuua",
    "id": "nuua",
    "url": "/concepts/nuua.html"
  },
  {
    "label": "Namespace-based Validation Dispatching Language",
    "id": "nvdl",
    "url": "/concepts/nvdl.html"
  },
  {
    "label": "NWScript",
    "id": "nwscript",
    "url": "/concepts/nwscript.html"
  },
  {
    "label": "Not eXactly C",
    "id": "nxc",
    "url": "/concepts/nxc.html"
  },
  {
    "label": "NXT-G",
    "id": "nxt-g",
    "url": "/concepts/nxt-g.html"
  },
  {
    "label": "nydp",
    "id": "nydp",
    "url": "/concepts/nydp.html"
  },
  {
    "label": "nylo",
    "id": "nylo",
    "url": "/concepts/nylo.html"
  },
  {
    "label": "Nymph",
    "id": "nymph",
    "url": "/concepts/nymph.html"
  },
  {
    "label": "Nyquist",
    "id": "nyquist",
    "url": "/concepts/nyquist.html"
  },
  {
    "label": "O-Matrix",
    "id": "o-matrix",
    "url": "/concepts/o-matrix.html"
  },
  {
    "label": "o:XML",
    "id": "o-xml",
    "url": "/concepts/o-xml.html"
  },
  {
    "label": "O",
    "id": "o",
    "url": "/concepts/o.html"
  },
  {
    "label": "o2",
    "id": "o2",
    "url": "/concepts/o2.html"
  },
  {
    "label": "o42a",
    "id": "o42a",
    "url": "/concepts/o42a.html"
  },
  {
    "label": "Oak",
    "id": "oak",
    "url": "/concepts/oak.html"
  },
  {
    "label": "Oaklisp",
    "id": "oaklisp",
    "url": "/concepts/oaklisp.html"
  },
  {
    "label": "oasis-operating-system",
    "id": "oasis-operating-system",
    "url": "/concepts/oasis-operating-system.html"
  },
  {
    "label": "OASIS",
    "id": "oasis",
    "url": "/concepts/oasis.html"
  },
  {
    "label": "Oberon-2",
    "id": "oberon-2",
    "url": "/concepts/oberon-2.html"
  },
  {
    "label": "Oberon",
    "id": "oberon",
    "url": "/concepts/oberon.html"
  },
  {
    "label": "OBJ",
    "id": "obj",
    "url": "/concepts/obj.html"
  },
  {
    "label": "OBJ2",
    "id": "obj2",
    "url": "/concepts/obj2.html"
  },
  {
    "label": "ObjDump",
    "id": "objdump",
    "url": "/concepts/objdump.html"
  },
  {
    "label": "Object Definition Language",
    "id": "object-definition-language",
    "url": "/concepts/object-definition-language.html"
  },
  {
    "label": "Object Oberon",
    "id": "object-oberon",
    "url": "/concepts/object-oberon.html"
  },
  {
    "label": "Object Pascal",
    "id": "object-pascal",
    "url": "/concepts/object-pascal.html"
  },
  {
    "label": "OQL",
    "id": "object-query-language",
    "url": "/concepts/object-query-language.html"
  },
  {
    "label": "Object Rexx",
    "id": "object-rexx",
    "url": "/concepts/object-rexx.html"
  },
  {
    "label": "Object-Z",
    "id": "object-z",
    "url": "/concepts/object-z.html"
  },
  {
    "label": "Objectcharts",
    "id": "objectcharts",
    "url": "/concepts/objectcharts.html"
  },
  {
    "label": "Objective-C",
    "id": "objective-c",
    "url": "/concepts/objective-c.html"
  },
  {
    "label": "Objective C++",
    "id": "objective-cpp",
    "url": "/concepts/objective-cpp.html"
  },
  {
    "label": "Objective-J",
    "id": "objective-j",
    "url": "/concepts/objective-j.html"
  },
  {
    "label": "objective-modula-2",
    "id": "objective-modula-2",
    "url": "/concepts/objective-modula-2.html"
  },
  {
    "label": "Objective-S",
    "id": "objective-s",
    "url": "/concepts/objective-s.html"
  },
  {
    "label": "ObjectLOGO",
    "id": "objectlogo",
    "url": "/concepts/objectlogo.html"
  },
  {
    "label": "ObjectPAL",
    "id": "objectpal",
    "url": "/concepts/objectpal.html"
  },
  {
    "label": "ObjectScript",
    "id": "objectscript",
    "url": "/concepts/objectscript.html"
  },
  {
    "label": "ObjectWorld",
    "id": "objectworld",
    "url": "/concepts/objectworld.html"
  },
  {
    "label": "ObjVlisp",
    "id": "objvlisp",
    "url": "/concepts/objvlisp.html"
  },
  {
    "label": "ObjVProlog",
    "id": "objvprolog",
    "url": "/concepts/objvprolog.html"
  },
  {
    "label": "Obliq",
    "id": "obliq",
    "url": "/concepts/obliq.html"
  },
  {
    "label": "OBSCURE",
    "id": "obscure",
    "url": "/concepts/obscure.html"
  },
  {
    "label": "Observable",
    "id": "observable-lang",
    "url": "/concepts/observable-lang.html"
  },
  {
    "label": "obsidian",
    "id": "obsidian",
    "url": "/concepts/obsidian.html"
  },
  {
    "label": "OCaml",
    "id": "ocaml",
    "url": "/concepts/ocaml.html"
  },
  {
    "label": "Occam 2",
    "id": "occam-2",
    "url": "/concepts/occam-2.html"
  },
  {
    "label": "Occam π",
    "id": "occam-pi",
    "url": "/concepts/occam-pi.html"
  },
  {
    "label": "Occam",
    "id": "occam",
    "url": "/concepts/occam.html"
  },
  {
    "label": "OCL",
    "id": "ocl",
    "url": "/concepts/ocl.html"
  },
  {
    "label": "GNU Octave",
    "id": "octave",
    "url": "/concepts/octave.html"
  },
  {
    "label": "Octopus",
    "id": "octopus",
    "url": "/concepts/octopus.html"
  },
  {
    "label": "Octune",
    "id": "octune",
    "url": "/concepts/octune.html"
  },
  {
    "label": "Open Data Protcol",
    "id": "odata",
    "url": "/concepts/odata.html"
  },
  {
    "label": "Open Database Connectivity",
    "id": "odbc",
    "url": "/concepts/odbc.html"
  },
  {
    "label": "oden",
    "id": "oden",
    "url": "/concepts/oden.html"
  },
  {
    "label": "odin",
    "id": "odin",
    "url": "/concepts/odin.html"
  },
  {
    "label": "ODRL",
    "id": "odrl",
    "url": "/concepts/odrl.html"
  },
  {
    "label": "OEM",
    "id": "oem",
    "url": "/concepts/oem.html"
  },
  {
    "label": "OFL",
    "id": "ofl",
    "url": "/concepts/ofl.html"
  },
  {
    "label": "oforth",
    "id": "oforth",
    "url": "/concepts/oforth.html"
  },
  {
    "label": "Open Financial Exchange",
    "id": "ofx",
    "url": "/concepts/ofx.html"
  },
  {
    "label": "Ordered graph data language",
    "id": "ogdl",
    "url": "/concepts/ogdl.html"
  },
  {
    "label": "OGNL",
    "id": "ognl",
    "url": "/concepts/ognl.html"
  },
  {
    "label": "O'Haskell",
    "id": "ohaskell",
    "url": "/concepts/ohaskell.html"
  },
  {
    "label": "Ohayo",
    "id": "ohayo",
    "url": "/concepts/ohayo.html"
  },
  {
    "label": "ohm",
    "id": "ohm",
    "url": "/concepts/ohm.html"
  },
  {
    "label": "oil",
    "id": "oil",
    "url": "/concepts/oil.html"
  },
  {
    "label": "OK",
    "id": "ok",
    "url": "/concepts/ok.html"
  },
  {
    "label": "OLDAS",
    "id": "oldas",
    "url": "/concepts/oldas.html"
  },
  {
    "label": "Object Linking and Embedding",
    "id": "ole-protocol",
    "url": "/concepts/ole-protocol.html"
  },
  {
    "label": "OLGA",
    "id": "olga",
    "url": "/concepts/olga.html"
  },
  {
    "label": "OLI",
    "id": "oli",
    "url": "/concepts/oli.html"
  },
  {
    "label": "OLIVER",
    "id": "oliver",
    "url": "/concepts/oliver.html"
  },
  {
    "label": "olog",
    "id": "olog",
    "url": "/concepts/olog.html"
  },
  {
    "label": "Om",
    "id": "om",
    "url": "/concepts/om.html"
  },
  {
    "label": "OMAR",
    "id": "omar",
    "url": "/concepts/omar.html"
  },
  {
    "label": "omega",
    "id": "omega",
    "url": "/concepts/omega.html"
  },
  {
    "label": "OMeta",
    "id": "ometa",
    "url": "/concepts/ometa.html"
  },
  {
    "label": "OMG IDL",
    "id": "omg-idl",
    "url": "/concepts/omg-idl.html"
  },
  {
    "label": "Omgrofl",
    "id": "omgrofl",
    "url": "/concepts/omgrofl.html"
  },
  {
    "label": "Omikron BASIC",
    "id": "omikron-basic",
    "url": "/concepts/omikron-basic.html"
  },
  {
    "label": "OMNIMARK",
    "id": "omnimark",
    "url": "/concepts/omnimark.html"
  },
  {
    "label": "Omnis Studio",
    "id": "omnis-studio",
    "url": "/concepts/omnis-studio.html"
  },
  {
    "label": "OMNITAB 80",
    "id": "omnitab-80",
    "url": "/concepts/omnitab-80.html"
  },
  {
    "label": "OMNITAB II",
    "id": "omnitab-ii",
    "url": "/concepts/omnitab-ii.html"
  },
  {
    "label": "OMNITAB",
    "id": "omnitab",
    "url": "/concepts/omnitab.html"
  },
  {
    "label": "One-man-language",
    "id": "one-man-language",
    "url": "/concepts/one-man-language.html"
  },
  {
    "label": "onex",
    "id": "onex",
    "url": "/concepts/onex.html"
  },
  {
    "label": "oniguruma",
    "id": "oniguruma",
    "url": "/concepts/oniguruma.html"
  },
  {
    "label": "onnx",
    "id": "onnx",
    "url": "/concepts/onnx.html"
  },
  {
    "label": "Onyx",
    "id": "onyx",
    "url": "/concepts/onyx.html"
  },
  {
    "label": "ooc",
    "id": "ooc",
    "url": "/concepts/ooc.html"
  },
  {
    "label": "Ook",
    "id": "ook",
    "url": "/concepts/ook.html"
  },
  {
    "label": "OOLP",
    "id": "oolp",
    "url": "/concepts/oolp.html"
  },
  {
    "label": "OOPAL",
    "id": "oopal",
    "url": "/concepts/oopal.html"
  },
  {
    "label": "OOPS",
    "id": "oops",
    "url": "/concepts/oops.html"
  },
  {
    "label": "oopsilon",
    "id": "oopsilon",
    "url": "/concepts/oopsilon.html"
  },
  {
    "label": "OOPS+",
    "id": "oopsp",
    "url": "/concepts/oopsp.html"
  },
  {
    "label": "Office Open XML",
    "id": "ooxml",
    "url": "/concepts/ooxml.html"
  },
  {
    "label": "Opa",
    "id": "opa",
    "url": "/concepts/opa.html"
  },
  {
    "label": "Opal",
    "id": "opal",
    "url": "/concepts/opal.html"
  },
  {
    "label": "opam-pm",
    "id": "opam-pm",
    "url": "/concepts/opam-pm.html"
  },
  {
    "label": "OpenNN",
    "id": "open-nn",
    "url": "/concepts/open-nn.html"
  },
  {
    "label": "Open Shading Language",
    "id": "open-shading-language",
    "url": "/concepts/open-shading-language.html"
  },
  {
    "label": "OpenAda",
    "id": "openada",
    "url": "/concepts/openada.html"
  },
  {
    "label": "OpenCL",
    "id": "opencl",
    "url": "/concepts/opencl.html"
  },
  {
    "label": "OpenComal",
    "id": "opencomal",
    "url": "/concepts/opencomal.html"
  },
  {
    "label": "OpenDoc",
    "id": "opendoc-protocol",
    "url": "/concepts/opendoc-protocol.html"
  },
  {
    "label": "OpenEdge ABL",
    "id": "openedge-advanced-business-language",
    "url": "/concepts/openedge-advanced-business-language.html"
  },
  {
    "label": "OpenEXR",
    "id": "openexr-format",
    "url": "/concepts/openexr-format.html"
  },
  {
    "label": "OpenGL",
    "id": "opengl",
    "url": "/concepts/opengl.html"
  },
  {
    "label": "opengraph",
    "id": "opengraph",
    "url": "/concepts/opengraph.html"
  },
  {
    "label": "OpenLisp",
    "id": "openlisp",
    "url": "/concepts/openlisp.html"
  },
  {
    "label": "OpenMusic",
    "id": "openmusic",
    "url": "/concepts/openmusic.html"
  },
  {
    "label": "OpenRC runscript",
    "id": "openrc-runscript",
    "url": "/concepts/openrc-runscript.html"
  },
  {
    "label": "OpenROAD",
    "id": "openroad",
    "url": "/concepts/openroad.html"
  },
  {
    "label": "OpenSCAD",
    "id": "openscad",
    "url": "/concepts/openscad.html"
  },
  {
    "label": "OpenSpice",
    "id": "openspice",
    "url": "/concepts/openspice.html"
  },
  {
    "label": "OpenType Feature File",
    "id": "opentype-feature-file",
    "url": "/concepts/opentype-feature-file.html"
  },
  {
    "label": "OpenVera",
    "id": "openvera",
    "url": "/concepts/openvera.html"
  },
  {
    "label": "Operational Control Language",
    "id": "operational-control-language",
    "url": "/concepts/operational-control-language.html"
  },
  {
    "label": "operon",
    "id": "operon",
    "url": "/concepts/operon.html"
  },
  {
    "label": "OPL",
    "id": "opl-langage-informatique",
    "url": "/concepts/opl-langage-informatique.html"
  },
  {
    "label": "OPL",
    "id": "opl",
    "url": "/concepts/opl.html"
  },
  {
    "label": "O++",
    "id": "opp",
    "url": "/concepts/opp.html"
  },
  {
    "label": "OPS-3",
    "id": "ops-3",
    "url": "/concepts/ops-3.html"
  },
  {
    "label": "OPS",
    "id": "ops",
    "url": "/concepts/ops.html"
  },
  {
    "label": "OPS5",
    "id": "ops5",
    "url": "/concepts/ops5.html"
  },
  {
    "label": "Optimization Programming Language",
    "id": "optimization-programming-language",
    "url": "/concepts/optimization-programming-language.html"
  },
  {
    "label": "Optimized Systems Software",
    "id": "optimized-systems-software",
    "url": "/concepts/optimized-systems-software.html"
  },
  {
    "label": "OptimJ",
    "id": "optimj",
    "url": "/concepts/optimj.html"
  },
  {
    "label": "Oracle Java",
    "id": "oracle-java",
    "url": "/concepts/oracle-java.html"
  },
  {
    "label": "Oracle",
    "id": "oracle",
    "url": "/concepts/oracle.html"
  },
  {
    "label": "orange",
    "id": "orange",
    "url": "/concepts/orange.html"
  },
  {
    "label": "Optimized Row Columnar",
    "id": "orc-format",
    "url": "/concepts/orc-format.html"
  },
  {
    "label": "Orc",
    "id": "orc-lang",
    "url": "/concepts/orc-lang.html"
  },
  {
    "label": "orca-lang",
    "id": "orca-lang",
    "url": "/concepts/orca-lang.html"
  },
  {
    "label": "orca-pl",
    "id": "orca-pl",
    "url": "/concepts/orca-pl.html"
  },
  {
    "label": "orca",
    "id": "orca",
    "url": "/concepts/orca.html"
  },
  {
    "label": "order",
    "id": "order",
    "url": "/concepts/order.html"
  },
  {
    "label": "OREGANO",
    "id": "oregano",
    "url": "/concepts/oregano.html"
  },
  {
    "label": "Org",
    "id": "org",
    "url": "/concepts/org.html"
  },
  {
    "label": "OrientDB",
    "id": "orient-db",
    "url": "/concepts/orient-db.html"
  },
  {
    "label": "Orient84/K",
    "id": "orient84-k",
    "url": "/concepts/orient84-k.html"
  },
  {
    "label": "Orlog",
    "id": "orlog",
    "url": "/concepts/orlog.html"
  },
  {
    "label": "OSIRIS",
    "id": "osiris",
    "url": "/concepts/osiris.html"
  },
  {
    "label": "OSL/2",
    "id": "osl-2",
    "url": "/concepts/osl-2.html"
  },
  {
    "label": "Object-oriented Structured Query Language",
    "id": "osql",
    "url": "/concepts/osql.html"
  },
  {
    "label": "Ottawa Euclid",
    "id": "ottawa-euclid",
    "url": "/concepts/ottawa-euclid.html"
  },
  {
    "label": "Otter",
    "id": "otter",
    "url": "/concepts/otter.html"
  },
  {
    "label": "OWBasic",
    "id": "owbasic",
    "url": "/concepts/owbasic.html"
  },
  {
    "label": "owen-lang",
    "id": "owen-lang",
    "url": "/concepts/owen-lang.html"
  },
  {
    "label": "OWL DL",
    "id": "owl-dl",
    "url": "/concepts/owl-dl.html"
  },
  {
    "label": "OWL",
    "id": "owl",
    "url": "/concepts/owl.html"
  },
  {
    "label": "OX",
    "id": "ox",
    "url": "/concepts/ox.html"
  },
  {
    "label": "Oxide",
    "id": "oxide",
    "url": "/concepts/oxide.html"
  },
  {
    "label": "Oxygene",
    "id": "oxygene",
    "url": "/concepts/oxygene.html"
  },
  {
    "label": "Oxyl",
    "id": "oxyl",
    "url": "/concepts/oxyl.html"
  },
  {
    "label": "Oz",
    "id": "oz",
    "url": "/concepts/oz.html"
  },
  {
    "label": "P/CL",
    "id": "p-cl",
    "url": "/concepts/p-cl.html"
  },
  {
    "label": "P-Prolog",
    "id": "p-prolog",
    "url": "/concepts/p-prolog.html"
  },
  {
    "label": "P*",
    "id": "p-star",
    "url": "/concepts/p-star.html"
  },
  {
    "label": "P-TAC",
    "id": "p-tac",
    "url": "/concepts/p-tac.html"
  },
  {
    "label": "P",
    "id": "p",
    "url": "/concepts/p.html"
  },
  {
    "label": "P3L",
    "id": "p3l",
    "url": "/concepts/p3l.html"
  },
  {
    "label": "P4",
    "id": "p4",
    "url": "/concepts/p4.html"
  },
  {
    "label": "p4p",
    "id": "p4p",
    "url": "/concepts/p4p.html"
  },
  {
    "label": "package-control-pm",
    "id": "package-control-pm",
    "url": "/concepts/package-control-pm.html"
  },
  {
    "label": "packagist-pm",
    "id": "packagist-pm",
    "url": "/concepts/packagist-pm.html"
  },
  {
    "label": "PacmanConf",
    "id": "pacmanconf",
    "url": "/concepts/pacmanconf.html"
  },
  {
    "label": "PACOL",
    "id": "pacol",
    "url": "/concepts/pacol.html"
  },
  {
    "label": "PACT I",
    "id": "pact-i",
    "url": "/concepts/pact-i.html"
  },
  {
    "label": "PACT IA",
    "id": "pact-ia",
    "url": "/concepts/pact-ia.html"
  },
  {
    "label": "Pact",
    "id": "pact",
    "url": "/concepts/pact.html"
  },
  {
    "label": "PACTOLUS",
    "id": "pactolus",
    "url": "/concepts/pactolus.html"
  },
  {
    "label": "PADL-1",
    "id": "padl-1",
    "url": "/concepts/padl-1.html"
  },
  {
    "label": "PaiLisp",
    "id": "pailisp",
    "url": "/concepts/pailisp.html"
  },
  {
    "label": "PAISley",
    "id": "paisley",
    "url": "/concepts/paisley.html"
  },
  {
    "label": "PALASM",
    "id": "palasm",
    "url": "/concepts/palasm.html"
  },
  {
    "label": "PALcode",
    "id": "palcode",
    "url": "/concepts/palcode.html"
  },
  {
    "label": "Palingol",
    "id": "palingol",
    "url": "/concepts/palingol.html"
  },
  {
    "label": "PAMELA",
    "id": "pamela",
    "url": "/concepts/pamela.html"
  },
  {
    "label": "Pan",
    "id": "pan",
    "url": "/concepts/pan.html"
  },
  {
    "label": "PANCODE",
    "id": "pancode",
    "url": "/concepts/pancode.html"
  },
  {
    "label": "Pandas",
    "id": "pandas",
    "url": "/concepts/pandas.html"
  },
  {
    "label": "Pandoc",
    "id": "pandoc-app",
    "url": "/concepts/pandoc-app.html"
  },
  {
    "label": "Pandora",
    "id": "pandora",
    "url": "/concepts/pandora.html"
  },
  {
    "label": "PANON-1",
    "id": "panon-1",
    "url": "/concepts/panon-1.html"
  },
  {
    "label": "PANON-1B",
    "id": "panon-1b",
    "url": "/concepts/panon-1b.html"
  },
  {
    "label": "panther-lang",
    "id": "panther-lang",
    "url": "/concepts/panther-lang.html"
  },
  {
    "label": "paperalgo",
    "id": "paperalgo",
    "url": "/concepts/paperalgo.html"
  },
  {
    "label": "Papyrus",
    "id": "papyrus",
    "url": "/concepts/papyrus.html"
  },
  {
    "label": "par",
    "id": "par",
    "url": "/concepts/par.html"
  },
  {
    "label": "Paragon",
    "id": "paragon",
    "url": "/concepts/paragon.html"
  },
  {
    "label": "Parallax Propeller",
    "id": "parallax-propeller",
    "url": "/concepts/parallax-propeller.html"
  },
  {
    "label": "Parallel ELLPACK",
    "id": "parallel-ellpack",
    "url": "/concepts/parallel-ellpack.html"
  },
  {
    "label": "Parallel Pascal",
    "id": "parallel-pascal",
    "url": "/concepts/parallel-pascal.html"
  },
  {
    "label": "ParaLog_e",
    "id": "paralog-e",
    "url": "/concepts/paralog-e.html"
  },
  {
    "label": "parasail",
    "id": "parasail",
    "url": "/concepts/parasail.html"
  },
  {
    "label": "Parasolid",
    "id": "parasolid",
    "url": "/concepts/parasolid.html"
  },
  {
    "label": "Parenscript",
    "id": "parenscript",
    "url": "/concepts/parenscript.html"
  },
  {
    "label": "parenthetic",
    "id": "parenthetic",
    "url": "/concepts/parenthetic.html"
  },
  {
    "label": "PARI/GP",
    "id": "pari-gp",
    "url": "/concepts/pari-gp.html"
  },
  {
    "label": "Parlog",
    "id": "parlog",
    "url": "/concepts/parlog.html"
  },
  {
    "label": "ParMod",
    "id": "parmod",
    "url": "/concepts/parmod.html"
  },
  {
    "label": "parquet",
    "id": "parquet",
    "url": "/concepts/parquet.html"
  },
  {
    "label": "Parrot Assembly",
    "id": "parrot-assembly",
    "url": "/concepts/parrot-assembly.html"
  },
  {
    "label": "Parrot BASIC",
    "id": "parrot-basic",
    "url": "/concepts/parrot-basic.html"
  },
  {
    "label": "PIR",
    "id": "parrot-internal-representation",
    "url": "/concepts/parrot-internal-representation.html"
  },
  {
    "label": "Parrot",
    "id": "parrot-vm",
    "url": "/concepts/parrot-vm.html"
  },
  {
    "label": "Parse Tree Notation",
    "id": "parse-tree-notation",
    "url": "/concepts/parse-tree-notation.html"
  },
  {
    "label": "Parser 3",
    "id": "parser",
    "url": "/concepts/parser.html"
  },
  {
    "label": "partiql",
    "id": "partiql",
    "url": "/concepts/partiql.html"
  },
  {
    "label": "PascalABC.NET",
    "id": "pascal-abc.net",
    "url": "/concepts/pascal-abc.net.html"
  },
  {
    "label": "Pascal-FC",
    "id": "pascal-fc",
    "url": "/concepts/pascal-fc.html"
  },
  {
    "label": "PASCAL-I",
    "id": "pascal-i",
    "url": "/concepts/pascal-i.html"
  },
  {
    "label": "PASCAL/MT+",
    "id": "pascal-mtp",
    "url": "/concepts/pascal-mtp.html"
  },
  {
    "label": "Pascal Plus",
    "id": "pascal-plus",
    "url": "/concepts/pascal-plus.html"
  },
  {
    "label": "Pascal-S",
    "id": "pascal-s",
    "url": "/concepts/pascal-s.html"
  },
  {
    "label": "Pascal-SC",
    "id": "pascal-sc",
    "url": "/concepts/pascal-sc.html"
  },
  {
    "label": "Pascal Script",
    "id": "pascal-script",
    "url": "/concepts/pascal-script.html"
  },
  {
    "label": "Pascal-XSC",
    "id": "pascal-xsc",
    "url": "/concepts/pascal-xsc.html"
  },
  {
    "label": "Pascal",
    "id": "pascal",
    "url": "/concepts/pascal.html"
  },
  {
    "label": "Pascal's calculator",
    "id": "pascals-calculator-machine",
    "url": "/concepts/pascals-calculator-machine.html"
  },
  {
    "label": "PASION",
    "id": "pasion",
    "url": "/concepts/pasion.html"
  },
  {
    "label": "PASRO",
    "id": "pasro",
    "url": "/concepts/pasro.html"
  },
  {
    "label": "passambler",
    "id": "passambler",
    "url": "/concepts/passambler.html"
  },
  {
    "label": "Passerine",
    "id": "passerine",
    "url": "/concepts/passerine.html"
  },
  {
    "label": "pasukon",
    "id": "pasukon",
    "url": "/concepts/pasukon.html"
  },
  {
    "label": "patch",
    "id": "patch",
    "url": "/concepts/patch.html"
  },
  {
    "label": "Patchwork",
    "id": "patchwork",
    "url": "/concepts/patchwork.html"
  },
  {
    "label": "Path Pascal",
    "id": "path-pascal",
    "url": "/concepts/path-pascal.html"
  },
  {
    "label": "Pawn",
    "id": "pawn-scripting-language",
    "url": "/concepts/pawn-scripting-language.html"
  },
  {
    "label": "PAWN",
    "id": "pawn",
    "url": "/concepts/pawn.html"
  },
  {
    "label": "paxScript",
    "id": "paxscript",
    "url": "/concepts/paxscript.html"
  },
  {
    "label": "PBASIC",
    "id": "pbasic",
    "url": "/concepts/pbasic.html"
  },
  {
    "label": "Portable Bit Map Format",
    "id": "pbm-format",
    "url": "/concepts/pbm-format.html"
  },
  {
    "label": "Omega",
    "id": "pbt-omega",
    "url": "/concepts/pbt-omega.html"
  },
  {
    "label": "PCLOS",
    "id": "pclos",
    "url": "/concepts/pclos.html"
  },
  {
    "label": "PCN",
    "id": "pcn",
    "url": "/concepts/pcn.html"
  },
  {
    "label": "PCOL",
    "id": "pcol",
    "url": "/concepts/pcol.html"
  },
  {
    "label": "pC++",
    "id": "pcpp",
    "url": "/concepts/pcpp.html"
  },
  {
    "label": "PCrap",
    "id": "pcrap",
    "url": "/concepts/pcrap.html"
  },
  {
    "label": "PCRE",
    "id": "pcre",
    "url": "/concepts/pcre.html"
  },
  {
    "label": "Partial Differential Equation Language",
    "id": "pdel",
    "url": "/concepts/pdel.html"
  },
  {
    "label": "PDF",
    "id": "pdf",
    "url": "/concepts/pdf.html"
  },
  {
    "label": "PDL/Ada",
    "id": "pdl-ada",
    "url": "/concepts/pdl-ada.html"
  },
  {
    "label": "PDL",
    "id": "pdl",
    "url": "/concepts/pdl.html"
  },
  {
    "label": "PDP-11",
    "id": "pdp-11-machine",
    "url": "/concepts/pdp-11-machine.html"
  },
  {
    "label": "PEAR",
    "id": "pear-pm",
    "url": "/concepts/pear-pm.html"
  },
  {
    "label": "PEARL",
    "id": "pearl",
    "url": "/concepts/pearl.html"
  },
  {
    "label": "PearScript",
    "id": "pearscript",
    "url": "/concepts/pearscript.html"
  },
  {
    "label": "Pearson correlation coefficient equation",
    "id": "pearson-correlation-coefficient-equation",
    "url": "/concepts/pearson-correlation-coefficient-equation.html"
  },
  {
    "label": "Pebble",
    "id": "pebble",
    "url": "/concepts/pebble.html"
  },
  {
    "label": "PEG",
    "id": "peg",
    "url": "/concepts/peg.html"
  },
  {
    "label": "Pegasus AUTOCODE",
    "id": "pegasus-autocode",
    "url": "/concepts/pegasus-autocode.html"
  },
  {
    "label": "PEG.js",
    "id": "pegjs",
    "url": "/concepts/pegjs.html"
  },
  {
    "label": "PEI",
    "id": "pei",
    "url": "/concepts/pei.html"
  },
  {
    "label": "penguor",
    "id": "penguor",
    "url": "/concepts/penguor.html"
  },
  {
    "label": "penrose",
    "id": "penrose",
    "url": "/concepts/penrose.html"
  },
  {
    "label": "PeopleCode",
    "id": "peoplecode",
    "url": "/concepts/peoplecode.html"
  },
  {
    "label": "PEP",
    "id": "pep",
    "url": "/concepts/pep.html"
  },
  {
    "label": "Pep8",
    "id": "pep8",
    "url": "/concepts/pep8.html"
  },
  {
    "label": "Perfectscript",
    "id": "perfectscript",
    "url": "/concepts/perfectscript.html"
  },
  {
    "label": "Peridot",
    "id": "peridot",
    "url": "/concepts/peridot.html"
  },
  {
    "label": "Perl 6",
    "id": "perl-6",
    "url": "/concepts/perl-6.html"
  },
  {
    "label": "Perl Data Language",
    "id": "perl-data-language",
    "url": "/concepts/perl-data-language.html"
  },
  {
    "label": "Perl",
    "id": "perl",
    "url": "/concepts/perl.html"
  },
  {
    "label": "Petr",
    "id": "petr",
    "url": "/concepts/petr.html"
  },
  {
    "label": "PFORT",
    "id": "pfort",
    "url": "/concepts/pfort.html"
  },
  {
    "label": "Pfortran",
    "id": "pfortran",
    "url": "/concepts/pfortran.html"
  },
  {
    "label": "PgBouncer",
    "id": "pgbouncer",
    "url": "/concepts/pgbouncer.html"
  },
  {
    "label": "PGen",
    "id": "pgen",
    "url": "/concepts/pgen.html"
  },
  {
    "label": "Netpbm grayscale image format",
    "id": "pgm-format",
    "url": "/concepts/pgm-format.html"
  },
  {
    "label": "pGOLOG",
    "id": "pgolog",
    "url": "/concepts/pgolog.html"
  },
  {
    "label": "pgql",
    "id": "pgql",
    "url": "/concepts/pgql.html"
  },
  {
    "label": "Pharen",
    "id": "pharen",
    "url": "/concepts/pharen.html"
  },
  {
    "label": "Pharo",
    "id": "pharo",
    "url": "/concepts/pharo.html"
  },
  {
    "label": "Phel",
    "id": "phel",
    "url": "/concepts/phel.html"
  },
  {
    "label": "PHIGS",
    "id": "phigs",
    "url": "/concepts/phigs.html"
  },
  {
    "label": "PHOCUS",
    "id": "phocus",
    "url": "/concepts/phocus.html"
  },
  {
    "label": "Phoenix Object Basic",
    "id": "phoenix-object-basic",
    "url": "/concepts/phoenix-object-basic.html"
  },
  {
    "label": "phorth",
    "id": "phorth",
    "url": "/concepts/phorth.html"
  },
  {
    "label": "PHP",
    "id": "php",
    "url": "/concepts/php.html"
  },
  {
    "label": "PhpStorm",
    "id": "phpstorm-editor",
    "url": "/concepts/phpstorm-editor.html"
  },
  {
    "label": "phylip",
    "id": "phylip",
    "url": "/concepts/phylip.html"
  },
  {
    "label": "PhyloXML",
    "id": "phyloxml-format",
    "url": "/concepts/phyloxml-format.html"
  },
  {
    "label": "PHYSICTRAN",
    "id": "physictran",
    "url": "/concepts/physictran.html"
  },
  {
    "label": "Pi Calculus",
    "id": "pi-calculus",
    "url": "/concepts/pi-calculus.html"
  },
  {
    "label": "PIC microcontroller",
    "id": "pic-microcontroller",
    "url": "/concepts/pic-microcontroller.html"
  },
  {
    "label": "PIC",
    "id": "pic",
    "url": "/concepts/pic.html"
  },
  {
    "label": "PICASSO",
    "id": "picasso",
    "url": "/concepts/picasso.html"
  },
  {
    "label": "Picat",
    "id": "picat",
    "url": "/concepts/picat.html"
  },
  {
    "label": "piccola",
    "id": "piccola",
    "url": "/concepts/piccola.html"
  },
  {
    "label": "Pick operating system",
    "id": "pick-operating-system",
    "url": "/concepts/pick-operating-system.html"
  },
  {
    "label": "PickCode",
    "id": "pickcode",
    "url": "/concepts/pickcode.html"
  },
  {
    "label": "Pickle",
    "id": "pickle-format",
    "url": "/concepts/pickle-format.html"
  },
  {
    "label": "PICO",
    "id": "pico",
    "url": "/concepts/pico.html"
  },
  {
    "label": "PicoLisp",
    "id": "picolisp",
    "url": "/concepts/picolisp.html"
  },
  {
    "label": "PICT",
    "id": "pict",
    "url": "/concepts/pict.html"
  },
  {
    "label": "PICTOL",
    "id": "pictol",
    "url": "/concepts/pictol.html"
  },
  {
    "label": "PICTUREBALM",
    "id": "picturebalm",
    "url": "/concepts/picturebalm.html"
  },
  {
    "label": "pie-lang",
    "id": "pie-lang",
    "url": "/concepts/pie-lang.html"
  },
  {
    "label": "PIE",
    "id": "pie",
    "url": "/concepts/pie.html"
  },
  {
    "label": "Piet",
    "id": "piet-programming-language",
    "url": "/concepts/piet-programming-language.html"
  },
  {
    "label": "Pig Latin",
    "id": "pig",
    "url": "/concepts/pig.html"
  },
  {
    "label": "pikachu",
    "id": "pikachu",
    "url": "/concepts/pikachu.html"
  },
  {
    "label": "Pike",
    "id": "pike",
    "url": "/concepts/pike.html"
  },
  {
    "label": "pikelet",
    "id": "pikelet",
    "url": "/concepts/pikelet.html"
  },
  {
    "label": "PIKT",
    "id": "pikt",
    "url": "/concepts/pikt.html"
  },
  {
    "label": "PiLib",
    "id": "pilib",
    "url": "/concepts/pilib.html"
  },
  {
    "label": "PILOT",
    "id": "pilot",
    "url": "/concepts/pilot.html"
  },
  {
    "label": "PIN",
    "id": "pin",
    "url": "/concepts/pin.html"
  },
  {
    "label": "pinto",
    "id": "pinto",
    "url": "/concepts/pinto.html"
  },
  {
    "label": "pipelines",
    "id": "pipelines",
    "url": "/concepts/pipelines.html"
  },
  {
    "label": "pisc",
    "id": "pisc",
    "url": "/concepts/pisc.html"
  },
  {
    "label": "PIT",
    "id": "pit",
    "url": "/concepts/pit.html"
  },
  {
    "label": "PIXIN",
    "id": "pixin",
    "url": "/concepts/pixin.html"
  },
  {
    "label": "Pizza",
    "id": "pizza",
    "url": "/concepts/pizza.html"
  },
  {
    "label": "PkgConfig",
    "id": "pkgconfig",
    "url": "/concepts/pkgconfig.html"
  },
  {
    "label": "PL/0",
    "id": "pl-0",
    "url": "/concepts/pl-0.html"
  },
  {
    "label": "PL-11",
    "id": "pl-11",
    "url": "/concepts/pl-11.html"
  },
  {
    "label": "IBM Programming Language/Advanced Systems",
    "id": "pl-as",
    "url": "/concepts/pl-as.html"
  },
  {
    "label": "PL/C",
    "id": "pl-c",
    "url": "/concepts/pl-c.html"
  },
  {
    "label": "PL/EXUS",
    "id": "pl-exus",
    "url": "/concepts/pl-exus.html"
  },
  {
    "label": "PL/I-FORMAC",
    "id": "pl-i-formac",
    "url": "/concepts/pl-i-formac.html"
  },
  {
    "label": "PL/I",
    "id": "pl-i-subset-g",
    "url": "/concepts/pl-i-subset-g.html"
  },
  {
    "label": "PL/I",
    "id": "pl-i",
    "url": "/concepts/pl-i.html"
  },
  {
    "label": "PL/LL",
    "id": "pl-ll",
    "url": "/concepts/pl-ll.html"
  },
  {
    "label": "PL/M",
    "id": "pl-m",
    "url": "/concepts/pl-m.html"
  },
  {
    "label": "PL/P",
    "id": "pl-p",
    "url": "/concepts/pl-p.html"
  },
  {
    "label": "PL/S-II",
    "id": "pl-s-ii",
    "url": "/concepts/pl-s-ii.html"
  },
  {
    "label": "PL/S",
    "id": "pl-s",
    "url": "/concepts/pl-s.html"
  },
  {
    "label": "PL/SQL",
    "id": "pl-sql",
    "url": "/concepts/pl-sql.html"
  },
  {
    "label": "PL-X",
    "id": "pl-x",
    "url": "/concepts/pl-x.html"
  },
  {
    "label": "PL360",
    "id": "pl360",
    "url": "/concepts/pl360.html"
  },
  {
    "label": "PL4",
    "id": "pl4",
    "url": "/concepts/pl4.html"
  },
  {
    "label": "PLACA",
    "id": "placa",
    "url": "/concepts/placa.html"
  },
  {
    "label": "Plaid",
    "id": "plaid-programming-language",
    "url": "/concepts/plaid-programming-language.html"
  },
  {
    "label": "Plain English",
    "id": "plain-english",
    "url": "/concepts/plain-english.html"
  },
  {
    "label": "PLAIN",
    "id": "plain",
    "url": "/concepts/plain.html"
  },
  {
    "label": "plam",
    "id": "plam",
    "url": "/concepts/plam.html"
  },
  {
    "label": "PLAN2D",
    "id": "plan2d",
    "url": "/concepts/plan2d.html"
  },
  {
    "label": "Planguage",
    "id": "planguage",
    "url": "/concepts/planguage.html"
  },
  {
    "label": "PLANIT",
    "id": "planit",
    "url": "/concepts/planit.html"
  },
  {
    "label": "Plankalkul",
    "id": "plankalkul",
    "url": "/concepts/plankalkul.html"
  },
  {
    "label": "PLANNER-73",
    "id": "planner-73",
    "url": "/concepts/planner-73.html"
  },
  {
    "label": "PLANNER",
    "id": "planner",
    "url": "/concepts/planner.html"
  },
  {
    "label": "plantuml",
    "id": "plantuml",
    "url": "/concepts/plantuml.html"
  },
  {
    "label": "plasma",
    "id": "plasma",
    "url": "/concepts/plasma.html"
  },
  {
    "label": "Playground",
    "id": "playground",
    "url": "/concepts/playground.html"
  },
  {
    "label": "Programming Language for Business",
    "id": "plb",
    "url": "/concepts/plb.html"
  },
  {
    "label": "Please Build",
    "id": "please-build",
    "url": "/concepts/please-build.html"
  },
  {
    "label": "PLEASE",
    "id": "please",
    "url": "/concepts/please.html"
  },
  {
    "label": "PLEX",
    "id": "plex",
    "url": "/concepts/plex.html"
  },
  {
    "label": "PLEXIL",
    "id": "plexil",
    "url": "/concepts/plexil.html"
  },
  {
    "label": "pliant",
    "id": "pliant",
    "url": "/concepts/pliant.html"
  },
  {
    "label": "plink-bed-format",
    "id": "plink-bed-format",
    "url": "/concepts/plink-bed-format.html"
  },
  {
    "label": "plink-bim-format",
    "id": "plink-bim-format",
    "url": "/concepts/plink-bim-format.html"
  },
  {
    "label": "plink-fam-format",
    "id": "plink-fam-format",
    "url": "/concepts/plink-fam-format.html"
  },
  {
    "label": "plink-map-format",
    "id": "plink-map-format",
    "url": "/concepts/plink-map-format.html"
  },
  {
    "label": "plink-ped-format",
    "id": "plink-ped-format",
    "url": "/concepts/plink-ped-format.html"
  },
  {
    "label": "Property list",
    "id": "plist",
    "url": "/concepts/plist.html"
  },
  {
    "label": "Plot",
    "id": "plot-lang",
    "url": "/concepts/plot-lang.html"
  },
  {
    "label": "plot",
    "id": "plot",
    "url": "/concepts/plot.html"
  },
  {
    "label": "PL/pgSQL",
    "id": "plpgsql",
    "url": "/concepts/plpgsql.html"
  },
  {
    "label": "Pluk",
    "id": "pluk",
    "url": "/concepts/pluk.html"
  },
  {
    "label": "Programming Language for the University of Maryland",
    "id": "plum",
    "url": "/concepts/plum.html"
  },
  {
    "label": "plumb",
    "id": "plumb",
    "url": "/concepts/plumb.html"
  },
  {
    "label": "Pλ⍵NK",
    "id": "plunk",
    "url": "/concepts/plunk.html"
  },
  {
    "label": "Plus",
    "id": "plus",
    "url": "/concepts/plus.html"
  },
  {
    "label": "Plush",
    "id": "plush",
    "url": "/concepts/plush.html"
  },
  {
    "label": "PLZ",
    "id": "plz",
    "url": "/concepts/plz.html"
  },
  {
    "label": "PM2",
    "id": "pm2",
    "url": "/concepts/pm2.html"
  },
  {
    "label": "PML",
    "id": "pml",
    "url": "/concepts/pml.html"
  },
  {
    "label": "PNG",
    "id": "png-format",
    "url": "/concepts/png-format.html"
  },
  {
    "label": "Pnuts",
    "id": "pnuts",
    "url": "/concepts/pnuts.html"
  },
  {
    "label": "PO",
    "id": "po",
    "url": "/concepts/po.html"
  },
  {
    "label": "Pocket Smalltalk",
    "id": "pocket-smalltalk",
    "url": "/concepts/pocket-smalltalk.html"
  },
  {
    "label": "Pod",
    "id": "pod",
    "url": "/concepts/pod.html"
  },
  {
    "label": "Pod6",
    "id": "pod6",
    "url": "/concepts/pod6.html"
  },
  {
    "label": "POGOL",
    "id": "pogol",
    "url": "/concepts/pogol.html"
  },
  {
    "label": "PogoScript",
    "id": "pogoscript",
    "url": "/concepts/pogoscript.html"
  },
  {
    "label": "pointless",
    "id": "pointless",
    "url": "/concepts/pointless.html"
  },
  {
    "label": "POLAC",
    "id": "polac",
    "url": "/concepts/polac.html"
  },
  {
    "label": "polly",
    "id": "polly",
    "url": "/concepts/polly.html"
  },
  {
    "label": "poly",
    "id": "poly",
    "url": "/concepts/poly.html"
  },
  {
    "label": "polyglot-compiler",
    "id": "polyglot-compiler",
    "url": "/concepts/polyglot-compiler.html"
  },
  {
    "label": "Polylith",
    "id": "polylith",
    "url": "/concepts/polylith.html"
  },
  {
    "label": "polymath",
    "id": "polymath",
    "url": "/concepts/polymath.html"
  },
  {
    "label": "Polymorphic Programming Language",
    "id": "polymorphic-programming-language",
    "url": "/concepts/polymorphic-programming-language.html"
  },
  {
    "label": "PolyP",
    "id": "polyp",
    "url": "/concepts/polyp.html"
  },
  {
    "label": "PolyTOIL",
    "id": "polytoil",
    "url": "/concepts/polytoil.html"
  },
  {
    "label": "Pomsky",
    "id": "pomsky",
    "url": "/concepts/pomsky.html"
  },
  {
    "label": "Pony",
    "id": "pony",
    "url": "/concepts/pony.html"
  },
  {
    "label": "Pop-11",
    "id": "pop-11",
    "url": "/concepts/pop-11.html"
  },
  {
    "label": "POP-2",
    "id": "pop-2",
    "url": "/concepts/pop-2.html"
  },
  {
    "label": "Patient-Oriented Prescription Programming Language",
    "id": "pop-pl",
    "url": "/concepts/pop-pl.html"
  },
  {
    "label": "Post Office Protocol",
    "id": "pop-protocol",
    "url": "/concepts/pop-protocol.html"
  },
  {
    "label": "PopAsm",
    "id": "popasm",
    "url": "/concepts/popasm.html"
  },
  {
    "label": "popcorn-linux",
    "id": "popcorn-linux",
    "url": "/concepts/popcorn-linux.html"
  },
  {
    "label": "POPLOG",
    "id": "poplog",
    "url": "/concepts/poplog.html"
  },
  {
    "label": "popr",
    "id": "popr",
    "url": "/concepts/popr.html"
  },
  {
    "label": "POPSY",
    "id": "popsy",
    "url": "/concepts/popsy.html"
  },
  {
    "label": "PORT-ALG",
    "id": "port-alg",
    "url": "/concepts/port-alg.html"
  },
  {
    "label": "Portable Standard Lisp",
    "id": "portable-standard-lisp",
    "url": "/concepts/portable-standard-lisp.html"
  },
  {
    "label": "Portal langage",
    "id": "portal-langage",
    "url": "/concepts/portal-langage.html"
  },
  {
    "label": "POSE",
    "id": "pose",
    "url": "/concepts/pose.html"
  },
  {
    "label": "Post production",
    "id": "post-canonical-system",
    "url": "/concepts/post-canonical-system.html"
  },
  {
    "label": "Post-X",
    "id": "post-x",
    "url": "/concepts/post-x.html"
  },
  {
    "label": "PostCSS",
    "id": "postcss",
    "url": "/concepts/postcss.html"
  },
  {
    "label": "PostgreSQL",
    "id": "postgresql",
    "url": "/concepts/postgresql.html"
  },
  {
    "label": "PostScript",
    "id": "postscript",
    "url": "/concepts/postscript.html"
  },
  {
    "label": "potential",
    "id": "potential",
    "url": "/concepts/potential.html"
  },
  {
    "label": "Potion",
    "id": "potion",
    "url": "/concepts/potion.html"
  },
  {
    "label": "POV-Ray SDL",
    "id": "pov-ray-sdl",
    "url": "/concepts/pov-ray-sdl.html"
  },
  {
    "label": "Power BI",
    "id": "power-bi-app",
    "url": "/concepts/power-bi-app.html"
  },
  {
    "label": "PowerQuery M",
    "id": "power-query-m",
    "url": "/concepts/power-query-m.html"
  },
  {
    "label": "PowerBASIC",
    "id": "powerbasic",
    "url": "/concepts/powerbasic.html"
  },
  {
    "label": "PowerBuilder",
    "id": "powerbuilder",
    "url": "/concepts/powerbuilder.html"
  },
  {
    "label": "PowerHouse",
    "id": "powerhouse-programming-language",
    "url": "/concepts/powerhouse-programming-language.html"
  },
  {
    "label": "IBM POWER Instruction Set Architecture",
    "id": "powerisa",
    "url": "/concepts/powerisa.html"
  },
  {
    "label": "PowerLanguage",
    "id": "powerlanguage",
    "url": "/concepts/powerlanguage.html"
  },
  {
    "label": "powerloom-knowledgeBase",
    "id": "powerloom-knowledgebase",
    "url": "/concepts/powerloom-knowledgebase.html"
  },
  {
    "label": "PowerPC",
    "id": "powerpc",
    "url": "/concepts/powerpc.html"
  },
  {
    "label": "powershell-gallery-pm",
    "id": "powershell-gallery-pm",
    "url": "/concepts/powershell-gallery-pm.html"
  },
  {
    "label": "PowerShell",
    "id": "powershell",
    "url": "/concepts/powershell.html"
  },
  {
    "label": "ppm-format",
    "id": "ppm-format",
    "url": "/concepts/ppm-format.html"
  },
  {
    "label": "P′′",
    "id": "pqq",
    "url": "/concepts/pqq.html"
  },
  {
    "label": "Praat Script",
    "id": "praat-script",
    "url": "/concepts/praat-script.html"
  },
  {
    "label": "praxis-lang",
    "id": "praxis-lang",
    "url": "/concepts/praxis-lang.html"
  },
  {
    "label": "PRAXIS",
    "id": "praxis",
    "url": "/concepts/praxis.html"
  },
  {
    "label": "Preferred Executable Format",
    "id": "preferred-executable-format",
    "url": "/concepts/preferred-executable-format.html"
  },
  {
    "label": "preforth",
    "id": "preforth",
    "url": "/concepts/preforth.html"
  },
  {
    "label": "PRESTO",
    "id": "presto",
    "url": "/concepts/presto.html"
  },
  {
    "label": "Price Equation",
    "id": "price-equation",
    "url": "/concepts/price-equation.html"
  },
  {
    "label": "Principle of sufficient reason",
    "id": "principle-of-sufficient-reason",
    "url": "/concepts/principle-of-sufficient-reason.html"
  },
  {
    "label": "PRISM",
    "id": "prism",
    "url": "/concepts/prism.html"
  },
  {
    "label": "Prisma Schema Language",
    "id": "prisma-schema-language",
    "url": "/concepts/prisma-schema-language.html"
  },
  {
    "label": "Prism",
    "id": "prismjs",
    "url": "/concepts/prismjs.html"
  },
  {
    "label": "PRIZ",
    "id": "priz",
    "url": "/concepts/priz.html"
  },
  {
    "label": "Pro*C",
    "id": "pro-star-c",
    "url": "/concepts/pro-star-c.html"
  },
  {
    "label": "ProbeVue",
    "id": "probevue",
    "url": "/concepts/probevue.html"
  },
  {
    "label": "PROC procedure language",
    "id": "proc-procedure-language",
    "url": "/concepts/proc-procedure-language.html"
  },
  {
    "label": "Processing",
    "id": "processing",
    "url": "/concepts/processing.html"
  },
  {
    "label": "Processor Technology",
    "id": "processor-technology",
    "url": "/concepts/processor-technology.html"
  },
  {
    "label": "Procfile",
    "id": "procfile",
    "url": "/concepts/procfile.html"
  },
  {
    "label": "PROCOL",
    "id": "procol",
    "url": "/concepts/procol.html"
  },
  {
    "label": "prodel",
    "id": "prodel",
    "url": "/concepts/prodel.html"
  },
  {
    "label": "ProFIT",
    "id": "profit",
    "url": "/concepts/profit.html"
  },
  {
    "label": "Progol",
    "id": "progol",
    "url": "/concepts/progol.html"
  },
  {
    "label": "Prograph",
    "id": "prograph",
    "url": "/concepts/prograph.html"
  },
  {
    "label": "PROGRES",
    "id": "progres",
    "url": "/concepts/progres.html"
  },
  {
    "label": "progsbase",
    "id": "progsbase",
    "url": "/concepts/progsbase.html"
  },
  {
    "label": "PROIV",
    "id": "proiv",
    "url": "/concepts/proiv.html"
  },
  {
    "label": "Project Mentat",
    "id": "project-mentat",
    "url": "/concepts/project-mentat.html"
  },
  {
    "label": "Prolog-D-Linda",
    "id": "prolog-d-linda",
    "url": "/concepts/prolog-d-linda.html"
  },
  {
    "label": "Prolog-ELF",
    "id": "prolog-elf",
    "url": "/concepts/prolog-elf.html"
  },
  {
    "label": "Prolog III",
    "id": "prolog-iii",
    "url": "/concepts/prolog-iii.html"
  },
  {
    "label": "Prolog/KR",
    "id": "prolog-kr",
    "url": "/concepts/prolog-kr.html"
  },
  {
    "label": "Prolog-Linda",
    "id": "prolog-linda",
    "url": "/concepts/prolog-linda.html"
  },
  {
    "label": "Prolog Pack",
    "id": "prolog-pack-pm",
    "url": "/concepts/prolog-pack-pm.html"
  },
  {
    "label": "Prolog",
    "id": "prolog",
    "url": "/concepts/prolog.html"
  },
  {
    "label": "Prolog++",
    "id": "prologpp",
    "url": "/concepts/prologpp.html"
  },
  {
    "label": "PROMAL",
    "id": "promal",
    "url": "/concepts/promal.html"
  },
  {
    "label": "Promela",
    "id": "promela",
    "url": "/concepts/promela.html"
  },
  {
    "label": "PROMETHEUS",
    "id": "prometheus",
    "url": "/concepts/prometheus.html"
  },
  {
    "label": "prompter",
    "id": "prompter",
    "url": "/concepts/prompter.html"
  },
  {
    "label": "PromQL",
    "id": "promql",
    "url": "/concepts/promql.html"
  },
  {
    "label": "Property Specification Language",
    "id": "property-specification-language",
    "url": "/concepts/property-specification-language.html"
  },
  {
    "label": "PROPHET",
    "id": "prophet",
    "url": "/concepts/prophet.html"
  },
  {
    "label": "PROPLAN",
    "id": "proplan",
    "url": "/concepts/proplan.html"
  },
  {
    "label": "ProSet",
    "id": "proset",
    "url": "/concepts/proset.html"
  },
  {
    "label": "PROSPER",
    "id": "prosper",
    "url": "/concepts/prosper.html"
  },
  {
    "label": "Protel",
    "id": "protel",
    "url": "/concepts/protel.html"
  },
  {
    "label": "Proteus",
    "id": "proteus-programming-language",
    "url": "/concepts/proteus-programming-language.html"
  },
  {
    "label": "protium",
    "id": "protium",
    "url": "/concepts/protium.html"
  },
  {
    "label": "proto-GNOSIS",
    "id": "proto-gnosis",
    "url": "/concepts/proto-gnosis.html"
  },
  {
    "label": "Protocol Buffers",
    "id": "protobuf",
    "url": "/concepts/protobuf.html"
  },
  {
    "label": "PROTOS-L",
    "id": "protos-l",
    "url": "/concepts/protos-l.html"
  },
  {
    "label": "Protosynthex",
    "id": "protosynthex",
    "url": "/concepts/protosynthex.html"
  },
  {
    "label": "ProVerif",
    "id": "proverif-lang",
    "url": "/concepts/proverif-lang.html"
  },
  {
    "label": "ProvideX",
    "id": "providex",
    "url": "/concepts/providex.html"
  },
  {
    "label": "PROW",
    "id": "prow",
    "url": "/concepts/prow.html"
  },
  {
    "label": "Proxy",
    "id": "proxy",
    "url": "/concepts/proxy.html"
  },
  {
    "label": "PRQL",
    "id": "prql",
    "url": "/concepts/prql.html"
  },
  {
    "label": "PS-algol",
    "id": "ps-algol",
    "url": "/concepts/ps-algol.html"
  },
  {
    "label": "pSather",
    "id": "psather",
    "url": "/concepts/psather.html"
  },
  {
    "label": "PSeInt",
    "id": "pseint",
    "url": "/concepts/pseint.html"
  },
  {
    "label": "PSG",
    "id": "psg",
    "url": "/concepts/psg.html"
  },
  {
    "label": "PSI",
    "id": "psi",
    "url": "/concepts/psi.html"
  },
  {
    "label": "PSL",
    "id": "psl",
    "url": "/concepts/psl.html"
  },
  {
    "label": "psyche-c",
    "id": "psyche-c",
    "url": "/concepts/psyche-c.html"
  },
  {
    "label": "psyche",
    "id": "psyche",
    "url": "/concepts/psyche.html"
  },
  {
    "label": "PSYCO",
    "id": "psyco",
    "url": "/concepts/psyco.html"
  },
  {
    "label": "PT",
    "id": "pt",
    "url": "/concepts/pt.html"
  },
  {
    "label": "PTX",
    "id": "ptx",
    "url": "/concepts/ptx.html"
  },
  {
    "label": "Public Key File",
    "id": "public-key-file",
    "url": "/concepts/public-key-file.html"
  },
  {
    "label": "PUFFT",
    "id": "pufft",
    "url": "/concepts/pufft.html"
  },
  {
    "label": "Pug",
    "id": "pug",
    "url": "/concepts/pug.html"
  },
  {
    "label": "PUMPKIN",
    "id": "pumpkin",
    "url": "/concepts/pumpkin.html"
  },
  {
    "label": "Punched tape",
    "id": "punched-tape",
    "url": "/concepts/punched-tape.html"
  },
  {
    "label": "Punycode",
    "id": "punycode",
    "url": "/concepts/punycode.html"
  },
  {
    "label": "Puppet",
    "id": "puppet",
    "url": "/concepts/puppet.html"
  },
  {
    "label": "Pure",
    "id": "pure",
    "url": "/concepts/pure.html"
  },
  {
    "label": "PureBasic",
    "id": "purebasic",
    "url": "/concepts/purebasic.html"
  },
  {
    "label": "Pure Data",
    "id": "puredata",
    "url": "/concepts/puredata.html"
  },
  {
    "label": "PureScript",
    "id": "purescript",
    "url": "/concepts/purescript.html"
  },
  {
    "label": "Pursuit PureScript Package Repository",
    "id": "pursuit-pm",
    "url": "/concepts/pursuit-pm.html"
  },
  {
    "label": "Push",
    "id": "push",
    "url": "/concepts/push.html"
  },
  {
    "label": "PV-Wave",
    "id": "pv-wave",
    "url": "/concepts/pv-wave.html"
  },
  {
    "label": "PVS",
    "id": "pvs",
    "url": "/concepts/pvs.html"
  },
  {
    "label": "Py",
    "id": "py",
    "url": "/concepts/py.html"
  },
  {
    "label": "pycharm-editor",
    "id": "pycharm-editor",
    "url": "/concepts/pycharm-editor.html"
  },
  {
    "label": "Pycket",
    "id": "pycket",
    "url": "/concepts/pycket.html"
  },
  {
    "label": "Pygmalion",
    "id": "pygmalion",
    "url": "/concepts/pygmalion.html"
  },
  {
    "label": "Pygments",
    "id": "pygments",
    "url": "/concepts/pygments.html"
  },
  {
    "label": "pyke",
    "id": "pyke",
    "url": "/concepts/pyke.html"
  },
  {
    "label": "PyPI",
    "id": "pypi-pm",
    "url": "/concepts/pypi-pm.html"
  },
  {
    "label": "Pyret",
    "id": "pyret-lang",
    "url": "/concepts/pyret-lang.html"
  },
  {
    "label": "pyret",
    "id": "pyret",
    "url": "/concepts/pyret.html"
  },
  {
    "label": "Pyrex",
    "id": "pyrex",
    "url": "/concepts/pyrex.html"
  },
  {
    "label": "Pyth",
    "id": "pyth",
    "url": "/concepts/pyth.html"
  },
  {
    "label": "Pythagorean Equation",
    "id": "pythagorean-equation",
    "url": "/concepts/pythagorean-equation.html"
  },
  {
    "label": "python-cl-compiler",
    "id": "python-cl-compiler",
    "url": "/concepts/python-cl-compiler.html"
  },
  {
    "label": "Python for S60",
    "id": "python-for-s60",
    "url": "/concepts/python-for-s60.html"
  },
  {
    "label": "Python Format Specification",
    "id": "python-format-spec",
    "url": "/concepts/python-format-spec.html"
  },
  {
    "label": "Python",
    "id": "python",
    "url": "/concepts/python.html"
  },
  {
    "label": "PyTorch",
    "id": "pytorch",
    "url": "/concepts/pytorch.html"
  },
  {
    "label": "Q",
    "id": "q-equational-programming-language",
    "url": "/concepts/q-equational-programming-language.html"
  },
  {
    "label": "Q-GERT",
    "id": "q-gert",
    "url": "/concepts/q-gert.html"
  },
  {
    "label": "Q#",
    "id": "q-sharp",
    "url": "/concepts/q-sharp.html"
  },
  {
    "label": "Q",
    "id": "q",
    "url": "/concepts/q.html"
  },
  {
    "label": "QA4",
    "id": "qa4",
    "url": "/concepts/qa4.html"
  },
  {
    "label": "Qalb",
    "id": "qalb",
    "url": "/concepts/qalb.html"
  },
  {
    "label": "QAS",
    "id": "qas",
    "url": "/concepts/qas.html"
  },
  {
    "label": "QB64",
    "id": "qb64",
    "url": "/concepts/qb64.html"
  },
  {
    "label": "QBasic",
    "id": "qbasic",
    "url": "/concepts/qbasic.html"
  },
  {
    "label": "qbe",
    "id": "qbe",
    "url": "/concepts/qbe.html"
  },
  {
    "label": "QCL",
    "id": "qcl",
    "url": "/concepts/qcl.html"
  },
  {
    "label": "QED",
    "id": "qed-editor",
    "url": "/concepts/qed-editor.html"
  },
  {
    "label": "qed-lang",
    "id": "qed-lang",
    "url": "/concepts/qed-lang.html"
  },
  {
    "label": "QFX file format",
    "id": "qfx",
    "url": "/concepts/qfx.html"
  },
  {
    "label": "Quicken Interchange Format",
    "id": "qif",
    "url": "/concepts/qif.html"
  },
  {
    "label": "QLISP",
    "id": "qlisp",
    "url": "/concepts/qlisp.html"
  },
  {
    "label": "QMake",
    "id": "qmake",
    "url": "/concepts/qmake.html"
  },
  {
    "label": "QML",
    "id": "qml",
    "url": "/concepts/qml.html"
  },
  {
    "label": "QOIR",
    "id": "qoir",
    "url": "/concepts/qoir.html"
  },
  {
    "label": "Qore",
    "id": "qore",
    "url": "/concepts/qore.html"
  },
  {
    "label": "QR code",
    "id": "qr-code",
    "url": "/concepts/qr-code.html"
  },
  {
    "label": "Qt",
    "id": "qt",
    "url": "/concepts/qt.html"
  },
  {
    "label": "QtScript",
    "id": "qtscript",
    "url": "/concepts/qtscript.html"
  },
  {
    "label": "QUADRIL",
    "id": "quadril",
    "url": "/concepts/quadril.html"
  },
  {
    "label": "quaint-lang",
    "id": "quaint-lang",
    "url": "/concepts/quaint-lang.html"
  },
  {
    "label": "Quaint",
    "id": "quaint",
    "url": "/concepts/quaint.html"
  },
  {
    "label": "Quake",
    "id": "quake",
    "url": "/concepts/quake.html"
  },
  {
    "label": "QuakeC",
    "id": "quakec",
    "url": "/concepts/quakec.html"
  },
  {
    "label": "Quanta",
    "id": "quanta",
    "url": "/concepts/quanta.html"
  },
  {
    "label": "QUEL",
    "id": "quel",
    "url": "/concepts/quel.html"
  },
  {
    "label": "Query by Example",
    "id": "query-by-example",
    "url": "/concepts/query-by-example.html"
  },
  {
    "label": "quexal",
    "id": "quexal",
    "url": "/concepts/quexal.html"
  },
  {
    "label": "Quick Macros",
    "id": "quick-macros",
    "url": "/concepts/quick-macros.html"
  },
  {
    "label": "QuickBASIC",
    "id": "quickbasic",
    "url": "/concepts/quickbasic.html"
  },
  {
    "label": "quicklisp-pm",
    "id": "quicklisp-pm",
    "url": "/concepts/quicklisp-pm.html"
  },
  {
    "label": "quicksight-app",
    "id": "quicksight-app",
    "url": "/concepts/quicksight-app.html"
  },
  {
    "label": "QUIKSCRIPT",
    "id": "quikscript",
    "url": "/concepts/quikscript.html"
  },
  {
    "label": "QUIKTRAN",
    "id": "quiktran",
    "url": "/concepts/quiktran.html"
  },
  {
    "label": "QUILT",
    "id": "quilt",
    "url": "/concepts/quilt.html"
  },
  {
    "label": "Qunity",
    "id": "qunity",
    "url": "/concepts/qunity.html"
  },
  {
    "label": "quorum",
    "id": "quorum",
    "url": "/concepts/quorum.html"
  },
  {
    "label": "QUTE",
    "id": "qute",
    "url": "/concepts/qute.html"
  },
  {
    "label": "Quty",
    "id": "quty",
    "url": "/concepts/quty.html"
  },
  {
    "label": "R",
    "id": "r",
    "url": "/concepts/r.html"
  },
  {
    "label": "R2ML",
    "id": "r2ml",
    "url": "/concepts/r2ml.html"
  },
  {
    "label": "r3",
    "id": "r3",
    "url": "/concepts/r3.html"
  },
  {
    "label": "r4",
    "id": "r4",
    "url": "/concepts/r4.html"
  },
  {
    "label": "ra",
    "id": "ra",
    "url": "/concepts/ra.html"
  },
  {
    "label": "RACK",
    "id": "rack",
    "url": "/concepts/rack.html"
  },
  {
    "label": "Racket",
    "id": "racket",
    "url": "/concepts/racket.html"
  },
  {
    "label": "raco-pm",
    "id": "raco-pm",
    "url": "/concepts/raco-pm.html"
  },
  {
    "label": "Radish",
    "id": "radish",
    "url": "/concepts/radish.html"
  },
  {
    "label": "Ragel",
    "id": "ragel",
    "url": "/concepts/ragel.html"
  },
  {
    "label": "Ruby on Rails",
    "id": "rails",
    "url": "/concepts/rails.html"
  },
  {
    "label": "rainbow",
    "id": "rainbow",
    "url": "/concepts/rainbow.html"
  },
  {
    "label": "Raku",
    "id": "raku",
    "url": "/concepts/raku.html"
  },
  {
    "label": "ralph",
    "id": "ralph",
    "url": "/concepts/ralph.html"
  },
  {
    "label": "RamdaScript",
    "id": "ramdascript",
    "url": "/concepts/ramdascript.html"
  },
  {
    "label": "ramen",
    "id": "ramen",
    "url": "/concepts/ramen.html"
  },
  {
    "label": "Ramis software",
    "id": "ramis-software",
    "url": "/concepts/ramis-software.html"
  },
  {
    "label": "RAML",
    "id": "raml",
    "url": "/concepts/raml.html"
  },
  {
    "label": "RAND-ABEL",
    "id": "rand-abel",
    "url": "/concepts/rand-abel.html"
  },
  {
    "label": "rant",
    "id": "rant",
    "url": "/concepts/rant.html"
  },
  {
    "label": "RAPID",
    "id": "rapid",
    "url": "/concepts/rapid.html"
  },
  {
    "label": "RapidBatch",
    "id": "rapidbatch",
    "url": "/concepts/rapidbatch.html"
  },
  {
    "label": "rapidgen-rpl",
    "id": "rapidgen-rpl",
    "url": "/concepts/rapidgen-rpl.html"
  },
  {
    "label": "RapidQ",
    "id": "rapidq",
    "url": "/concepts/rapidq.html"
  },
  {
    "label": "RAPIDWRITE",
    "id": "rapidwrite",
    "url": "/concepts/rapidwrite.html"
  },
  {
    "label": "Rapira",
    "id": "rapira",
    "url": "/concepts/rapira.html"
  },
  {
    "label": "raptor",
    "id": "raptor",
    "url": "/concepts/raptor.html"
  },
  {
    "label": "raptorjit",
    "id": "raptorjit",
    "url": "/concepts/raptorjit.html"
  },
  {
    "label": "Rascal",
    "id": "rascal",
    "url": "/concepts/rascal.html"
  },
  {
    "label": "RascalMPL",
    "id": "rascalmpl",
    "url": "/concepts/rascalmpl.html"
  },
  {
    "label": "rason",
    "id": "rason",
    "url": "/concepts/rason.html"
  },
  {
    "label": "RASP",
    "id": "rasp",
    "url": "/concepts/rasp.html"
  },
  {
    "label": "Ratfiv",
    "id": "ratfiv",
    "url": "/concepts/ratfiv.html"
  },
  {
    "label": "RATFOR",
    "id": "ratfor",
    "url": "/concepts/ratfor.html"
  },
  {
    "label": "RATSNO",
    "id": "ratsno",
    "url": "/concepts/ratsno.html"
  },
  {
    "label": "Ravenscar profile",
    "id": "ravenscar-profile",
    "url": "/concepts/ravenscar-profile.html"
  },
  {
    "label": "Razor",
    "id": "razor",
    "url": "/concepts/razor.html"
  },
  {
    "label": "rbasic",
    "id": "rbasic",
    "url": "/concepts/rbasic.html"
  },
  {
    "label": "rbs",
    "id": "rbs",
    "url": "/concepts/rbs.html"
  },
  {
    "label": "rbscript",
    "id": "rbscript",
    "url": "/concepts/rbscript.html"
  },
  {
    "label": "Rc",
    "id": "rc",
    "url": "/concepts/rc.html"
  },
  {
    "label": "RC++",
    "id": "rcpp",
    "url": "/concepts/rcpp.html"
  },
  {
    "label": "rdata-format",
    "id": "rdata-format",
    "url": "/concepts/rdata-format.html"
  },
  {
    "label": "RDF Schema",
    "id": "rdf-schema",
    "url": "/concepts/rdf-schema.html"
  },
  {
    "label": "RDF",
    "id": "rdf",
    "url": "/concepts/rdf.html"
  },
  {
    "label": "RDFa",
    "id": "rdfa",
    "url": "/concepts/rdfa.html"
  },
  {
    "label": "Rapid Development and Maintenance Language",
    "id": "rdml",
    "url": "/concepts/rdml.html"
  },
  {
    "label": "RDoc",
    "id": "rdoc",
    "url": "/concepts/rdoc.html"
  },
  {
    "label": "rds-format",
    "id": "rds-format",
    "url": "/concepts/rds-format.html"
  },
  {
    "label": "React Native",
    "id": "react-native",
    "url": "/concepts/react-native.html"
  },
  {
    "label": "readable-lisp",
    "id": "readable-lisp",
    "url": "/concepts/readable-lisp.html"
  },
  {
    "label": "Readable",
    "id": "readable",
    "url": "/concepts/readable.html"
  },
  {
    "label": "Real-time Cmix",
    "id": "real-time-cmix",
    "url": "/concepts/real-time-cmix.html"
  },
  {
    "label": "Real-Time Concurrent C",
    "id": "real-time-concurrent-c",
    "url": "/concepts/real-time-concurrent-c.html"
  },
  {
    "label": "Real-Time Euclid",
    "id": "real-time-euclid",
    "url": "/concepts/real-time-euclid.html"
  },
  {
    "label": "Real-Time Mentat",
    "id": "real-time-mentat",
    "url": "/concepts/real-time-mentat.html"
  },
  {
    "label": "REALBasic (now Xojo)",
    "id": "realbasic",
    "url": "/concepts/realbasic.html"
  },
  {
    "label": "Reason",
    "id": "reason",
    "url": "/concepts/reason.html"
  },
  {
    "label": "Rebeca Modeling Language",
    "id": "rebeca-modeling-language",
    "url": "/concepts/rebeca-modeling-language.html"
  },
  {
    "label": "REBOL",
    "id": "rebol",
    "url": "/concepts/rebol.html"
  },
  {
    "label": "Rebus",
    "id": "rebus",
    "url": "/concepts/rebus.html"
  },
  {
    "label": "REC/SM",
    "id": "rec-sm",
    "url": "/concepts/rec-sm.html"
  },
  {
    "label": "REC Studio",
    "id": "rec-studio",
    "url": "/concepts/rec-studio.html"
  },
  {
    "label": "Recfiles",
    "id": "recfiles",
    "url": "/concepts/recfiles.html"
  },
  {
    "label": "RECOL",
    "id": "recol",
    "url": "/concepts/recol.html"
  },
  {
    "label": "Red",
    "id": "red-lang",
    "url": "/concepts/red-lang.html"
  },
  {
    "label": "Red",
    "id": "red",
    "url": "/concepts/red.html"
  },
  {
    "label": "Redcode",
    "id": "redcode",
    "url": "/concepts/redcode.html"
  },
  {
    "label": "Redis",
    "id": "redis",
    "url": "/concepts/redis.html"
  },
  {
    "label": "redpanda-app",
    "id": "redpanda-app",
    "url": "/concepts/redpanda-app.html"
  },
  {
    "label": "redprl",
    "id": "redprl",
    "url": "/concepts/redprl.html"
  },
  {
    "label": "redscript",
    "id": "redscript",
    "url": "/concepts/redscript.html"
  },
  {
    "label": "Amazon Redshift",
    "id": "redshift",
    "url": "/concepts/redshift.html"
  },
  {
    "label": "REDUCE",
    "id": "reduce",
    "url": "/concepts/reduce.html"
  },
  {
    "label": "REF-ARF",
    "id": "ref-arf",
    "url": "/concepts/ref-arf.html"
  },
  {
    "label": "Refal",
    "id": "refal",
    "url": "/concepts/refal.html"
  },
  {
    "label": "Refer",
    "id": "refer",
    "url": "/concepts/refer.html"
  },
  {
    "label": "Refined C",
    "id": "refined-c",
    "url": "/concepts/refined-c.html"
  },
  {
    "label": "reflex-framework",
    "id": "reflex-framework",
    "url": "/concepts/reflex-framework.html"
  },
  {
    "label": "RefLisp",
    "id": "reflisp",
    "url": "/concepts/reflisp.html"
  },
  {
    "label": "reforth",
    "id": "reforth",
    "url": "/concepts/reforth.html"
  },
  {
    "label": "REGENT",
    "id": "regent",
    "url": "/concepts/regent.html"
  },
  {
    "label": "Regular Expressions",
    "id": "regex",
    "url": "/concepts/regex.html"
  },
  {
    "label": "Regina",
    "id": "regina",
    "url": "/concepts/regina.html"
  },
  {
    "label": "REGULUS",
    "id": "regulus",
    "url": "/concepts/regulus.html"
  },
  {
    "label": "Reia",
    "id": "reia",
    "url": "/concepts/reia.html"
  },
  {
    "label": "Reko",
    "id": "reko-decompiler",
    "url": "/concepts/reko-decompiler.html"
  },
  {
    "label": "REL English",
    "id": "rel-english",
    "url": "/concepts/rel-english.html"
  },
  {
    "label": "rel-lang",
    "id": "rel-lang",
    "url": "/concepts/rel-lang.html"
  },
  {
    "label": "REL",
    "id": "rel",
    "url": "/concepts/rel.html"
  },
  {
    "label": "Relational Data File",
    "id": "relational-data-file",
    "url": "/concepts/relational-data-file.html"
  },
  {
    "label": "RPL",
    "id": "relational-production-language",
    "url": "/concepts/relational-production-language.html"
  },
  {
    "label": "Relationlog",
    "id": "relationlog",
    "url": "/concepts/relationlog.html"
  },
  {
    "label": "relax",
    "id": "relax",
    "url": "/concepts/relax.html"
  },
  {
    "label": "RELAX NG",
    "id": "relaxng",
    "url": "/concepts/relaxng.html"
  },
  {
    "label": "RELFUN",
    "id": "relfun",
    "url": "/concepts/relfun.html"
  },
  {
    "label": "Relix",
    "id": "relix",
    "url": "/concepts/relix.html"
  },
  {
    "label": "remix",
    "id": "remix",
    "url": "/concepts/remix.html"
  },
  {
    "label": "Ren-C",
    "id": "ren-c",
    "url": "/concepts/ren-c.html"
  },
  {
    "label": "Ren",
    "id": "ren-notation",
    "url": "/concepts/ren-notation.html"
  },
  {
    "label": "RenderMan Shading Language",
    "id": "renderman-shading-language",
    "url": "/concepts/renderman-shading-language.html"
  },
  {
    "label": "RenderScript",
    "id": "renderscript",
    "url": "/concepts/renderscript.html"
  },
  {
    "label": "Ren'Py",
    "id": "renpy",
    "url": "/concepts/renpy.html"
  },
  {
    "label": "RPT",
    "id": "report-writer-language",
    "url": "/concepts/report-writer-language.html"
  },
  {
    "label": "Rescript",
    "id": "rescript",
    "url": "/concepts/rescript.html"
  },
  {
    "label": "resharper-editor",
    "id": "resharper-editor",
    "url": "/concepts/resharper-editor.html"
  },
  {
    "label": "REST",
    "id": "rest",
    "url": "/concepts/rest.html"
  },
  {
    "label": "reStructuredText",
    "id": "restructuredtext",
    "url": "/concepts/restructuredtext.html"
  },
  {
    "label": "RetDec",
    "id": "retdec",
    "url": "/concepts/retdec.html"
  },
  {
    "label": "retroforth",
    "id": "retroforth",
    "url": "/concepts/retroforth.html"
  },
  {
    "label": "Reuse Description Language",
    "id": "reuse-description-language",
    "url": "/concepts/reuse-description-language.html"
  },
  {
    "label": "Reverse Polish notation",
    "id": "reverse-polish-notation",
    "url": "/concepts/reverse-polish-notation.html"
  },
  {
    "label": "Autodesk Revit",
    "id": "revit-app",
    "url": "/concepts/revit-app.html"
  },
  {
    "label": "Revolution",
    "id": "revolution-programming-language",
    "url": "/concepts/revolution-programming-language.html"
  },
  {
    "label": "Rexon",
    "id": "rexon",
    "url": "/concepts/rexon.html"
  },
  {
    "label": "Rexx",
    "id": "rexx",
    "url": "/concepts/rexx.html"
  },
  {
    "label": "RF-Maple",
    "id": "rf-maple",
    "url": "/concepts/rf-maple.html"
  },
  {
    "label": "RFC",
    "id": "rfc",
    "url": "/concepts/rfc.html"
  },
  {
    "label": "Silicon Graphics Image",
    "id": "rgb-format",
    "url": "/concepts/rgb-format.html"
  },
  {
    "label": "RHET",
    "id": "rhet",
    "url": "/concepts/rhet.html"
  },
  {
    "label": "rhine",
    "id": "rhine",
    "url": "/concepts/rhine.html"
  },
  {
    "label": "Rholang",
    "id": "rholang",
    "url": "/concepts/rholang.html"
  },
  {
    "label": "rhoscript",
    "id": "rhoscript",
    "url": "/concepts/rhoscript.html"
  },
  {
    "label": "RHTML",
    "id": "rhtml",
    "url": "/concepts/rhtml.html"
  },
  {
    "label": "RicScript",
    "id": "ricscript",
    "url": "/concepts/ricscript.html"
  },
  {
    "label": "rider-editor",
    "id": "rider-editor",
    "url": "/concepts/rider-editor.html"
  },
  {
    "label": "Riff",
    "id": "riff",
    "url": "/concepts/riff.html"
  },
  {
    "label": "RIGAL",
    "id": "rigal",
    "url": "/concepts/rigal.html"
  },
  {
    "label": "RigC",
    "id": "rigc",
    "url": "/concepts/rigc.html"
  },
  {
    "label": "Ring",
    "id": "ring",
    "url": "/concepts/ring.html"
  },
  {
    "label": "rio",
    "id": "rio",
    "url": "/concepts/rio.html"
  },
  {
    "label": "Ripple",
    "id": "ripple",
    "url": "/concepts/ripple.html"
  },
  {
    "label": "RISC-V",
    "id": "risc-v",
    "url": "/concepts/risc-v.html"
  },
  {
    "label": "rise",
    "id": "rise",
    "url": "/concepts/rise.html"
  },
  {
    "label": "Rita",
    "id": "rita",
    "url": "/concepts/rita.html"
  },
  {
    "label": "RLaB",
    "id": "rlab",
    "url": "/concepts/rlab.html"
  },
  {
    "label": "RLISP",
    "id": "rlisp",
    "url": "/concepts/rlisp.html"
  },
  {
    "label": "rlmeta",
    "id": "rlmeta",
    "url": "/concepts/rlmeta.html"
  },
  {
    "label": "rlox",
    "id": "rlox",
    "url": "/concepts/rlox.html"
  },
  {
    "label": "RMarkdown",
    "id": "rmarkdown",
    "url": "/concepts/rmarkdown.html"
  },
  {
    "label": "Robic",
    "id": "robic",
    "url": "/concepts/robic.html"
  },
  {
    "label": "RoboMind",
    "id": "robomind",
    "url": "/concepts/robomind.html"
  },
  {
    "label": "Robot Battle",
    "id": "robot-battle",
    "url": "/concepts/robot-battle.html"
  },
  {
    "label": "RoboTalk",
    "id": "robotalk",
    "url": "/concepts/robotalk.html"
  },
  {
    "label": "robotc",
    "id": "robotc",
    "url": "/concepts/robotc.html"
  },
  {
    "label": "RobotFramework",
    "id": "robotframework",
    "url": "/concepts/robotframework.html"
  },
  {
    "label": "Robots.txt",
    "id": "robots.txt",
    "url": "/concepts/robots.txt.html"
  },
  {
    "label": "Roc",
    "id": "roc",
    "url": "/concepts/roc.html"
  },
  {
    "label": "rocket",
    "id": "rocket",
    "url": "/concepts/rocket.html"
  },
  {
    "label": "rockstar-rkt",
    "id": "rockstar-rkt",
    "url": "/concepts/rockstar-rkt.html"
  },
  {
    "label": "Rockstar",
    "id": "rockstar",
    "url": "/concepts/rockstar.html"
  },
  {
    "label": "Rocky Mountain BASIC",
    "id": "rocky-mountain-basic",
    "url": "/concepts/rocky-mountain-basic.html"
  },
  {
    "label": "ROFF",
    "id": "roff",
    "url": "/concepts/roff.html"
  },
  {
    "label": "Brightscript",
    "id": "roku-brightscript",
    "url": "/concepts/roku-brightscript.html"
  },
  {
    "label": "ROL",
    "id": "rol",
    "url": "/concepts/rol.html"
  },
  {
    "label": "ROL2",
    "id": "rol2",
    "url": "/concepts/rol2.html"
  },
  {
    "label": "Roman abacus",
    "id": "roman-abacus-machine",
    "url": "/concepts/roman-abacus-machine.html"
  },
  {
    "label": "Roman numerals",
    "id": "roman-numerals",
    "url": "/concepts/roman-numerals.html"
  },
  {
    "label": "Ron",
    "id": "ron",
    "url": "/concepts/ron.html"
  },
  {
    "label": "ROOP",
    "id": "roop",
    "url": "/concepts/roop.html"
  },
  {
    "label": "root-format",
    "id": "root-format",
    "url": "/concepts/root-format.html"
  },
  {
    "label": "ROOT",
    "id": "root-lib",
    "url": "/concepts/root-lib.html"
  },
  {
    "label": "ROS Message",
    "id": "ros-msg",
    "url": "/concepts/ros-msg.html"
  },
  {
    "label": "ROSCOE",
    "id": "roscoe",
    "url": "/concepts/roscoe.html"
  },
  {
    "label": "Rosetta-2",
    "id": "rosetta-2",
    "url": "/concepts/rosetta-2.html"
  },
  {
    "label": "Rosetta SMALLTALK",
    "id": "rosetta-smalltalk",
    "url": "/concepts/rosetta-smalltalk.html"
  },
  {
    "label": "rosette-lang",
    "id": "rosette-lang",
    "url": "/concepts/rosette-lang.html"
  },
  {
    "label": "Rosette",
    "id": "rosette",
    "url": "/concepts/rosette.html"
  },
  {
    "label": "rosie",
    "id": "rosie",
    "url": "/concepts/rosie.html"
  },
  {
    "label": "Roslyn compiler",
    "id": "roslyn-compiler",
    "url": "/concepts/roslyn-compiler.html"
  },
  {
    "label": "Rouge",
    "id": "rouge",
    "url": "/concepts/rouge.html"
  },
  {
    "label": "roy",
    "id": "roy",
    "url": "/concepts/roy.html"
  },
  {
    "label": "RoyalScript",
    "id": "royalscript",
    "url": "/concepts/royalscript.html"
  },
  {
    "label": "RPG II",
    "id": "rpg-ii",
    "url": "/concepts/rpg-ii.html"
  },
  {
    "label": "RPG III",
    "id": "rpg-iii",
    "url": "/concepts/rpg-iii.html"
  },
  {
    "label": "Reactive Plan Language",
    "id": "rpl-lang",
    "url": "/concepts/rpl-lang.html"
  },
  {
    "label": "RPL",
    "id": "rpl",
    "url": "/concepts/rpl.html"
  },
  {
    "label": "Rpm",
    "id": "rpm-package-manager",
    "url": "/concepts/rpm-package-manager.html"
  },
  {
    "label": "RPM Spec",
    "id": "rpm-spec",
    "url": "/concepts/rpm-spec.html"
  },
  {
    "label": "R++",
    "id": "rpp",
    "url": "/concepts/rpp.html"
  },
  {
    "label": "rpscript",
    "id": "rpscript",
    "url": "/concepts/rpscript.html"
  },
  {
    "label": "Restricted Python",
    "id": "rpython",
    "url": "/concepts/rpython.html"
  },
  {
    "label": "RQL",
    "id": "rql",
    "url": "/concepts/rql.html"
  },
  {
    "label": "rsharp",
    "id": "rsharp",
    "url": "/concepts/rsharp.html"
  },
  {
    "label": "RAISE Specification Language",
    "id": "rsl",
    "url": "/concepts/rsl.html"
  },
  {
    "label": "RSS",
    "id": "rss",
    "url": "/concepts/rss.html"
  },
  {
    "label": "RStudio",
    "id": "rstudio-editor",
    "url": "/concepts/rstudio-editor.html"
  },
  {
    "label": "RT-ASLAN",
    "id": "rt-aslan",
    "url": "/concepts/rt-aslan.html"
  },
  {
    "label": "RT-CDL",
    "id": "rt-cdl",
    "url": "/concepts/rt-cdl.html"
  },
  {
    "label": "RT-Z",
    "id": "rt-z",
    "url": "/concepts/rt-z.html"
  },
  {
    "label": "RTF",
    "id": "rtf",
    "url": "/concepts/rtf.html"
  },
  {
    "label": "RTL/2",
    "id": "rtl-2",
    "url": "/concepts/rtl-2.html"
  },
  {
    "label": "Real-time Transport Protocol",
    "id": "rtp-protocol",
    "url": "/concepts/rtp-protocol.html"
  },
  {
    "label": "ru",
    "id": "ru",
    "url": "/concepts/ru.html"
  },
  {
    "label": "Ruby Document format",
    "id": "ruby-document-format",
    "url": "/concepts/ruby-document-format.html"
  },
  {
    "label": "ruby-mine-editor",
    "id": "ruby-mine-editor",
    "url": "/concepts/ruby-mine-editor.html"
  },
  {
    "label": "Ruby",
    "id": "ruby",
    "url": "/concepts/ruby.html"
  },
  {
    "label": "RubyGems",
    "id": "rubygems-pm",
    "url": "/concepts/rubygems-pm.html"
  },
  {
    "label": "RuleML",
    "id": "ruleml",
    "url": "/concepts/ruleml.html"
  },
  {
    "label": "Run BASIC",
    "id": "run-basic",
    "url": "/concepts/run-basic.html"
  },
  {
    "label": "RUNCIBLE",
    "id": "runcible",
    "url": "/concepts/runcible.html"
  },
  {
    "label": "runescript",
    "id": "runescript",
    "url": "/concepts/runescript.html"
  },
  {
    "label": "runic",
    "id": "runic",
    "url": "/concepts/runic.html"
  },
  {
    "label": "runiq",
    "id": "runiq",
    "url": "/concepts/runiq.html"
  },
  {
    "label": "RUNOFF",
    "id": "runoff",
    "url": "/concepts/runoff.html"
  },
  {
    "label": "RunRev",
    "id": "runrev",
    "url": "/concepts/runrev.html"
  },
  {
    "label": "Ruri",
    "id": "ruri",
    "url": "/concepts/ruri.html"
  },
  {
    "label": "RUSSELL",
    "id": "russell",
    "url": "/concepts/russell.html"
  },
  {
    "label": "Rust HIR",
    "id": "rust-hir",
    "url": "/concepts/rust-hir.html"
  },
  {
    "label": "Rust MIR",
    "id": "rust-mir",
    "url": "/concepts/rust-mir.html"
  },
  {
    "label": "Rust",
    "id": "rust",
    "url": "/concepts/rust.html"
  },
  {
    "label": "RustScript",
    "id": "rustscript",
    "url": "/concepts/rustscript.html"
  },
  {
    "label": "RUTH",
    "id": "ruth",
    "url": "/concepts/ruth.html"
  },
  {
    "label": "Rye",
    "id": "rye",
    "url": "/concepts/rye.html"
  },
  {
    "label": "S-algol",
    "id": "s-algol",
    "url": "/concepts/s-algol.html"
  },
  {
    "label": "S-expressions",
    "id": "s-expressions",
    "url": "/concepts/s-expressions.html"
  },
  {
    "label": "s-lang",
    "id": "s-lang",
    "url": "/concepts/s-lang.html"
  },
  {
    "label": "S-PLUS",
    "id": "s-plus",
    "url": "/concepts/s-plus.html"
  },
  {
    "label": "S/SL",
    "id": "s-sl",
    "url": "/concepts/s-sl.html"
  },
  {
    "label": "S-Snobol",
    "id": "s-snobol",
    "url": "/concepts/s-snobol.html"
  },
  {
    "label": "S",
    "id": "s",
    "url": "/concepts/s.html"
  },
  {
    "label": "System 2",
    "id": "s2",
    "url": "/concepts/s2.html"
  },
  {
    "label": "S3",
    "id": "s3",
    "url": "/concepts/s3.html"
  },
  {
    "label": "SA-C",
    "id": "sa-c-programming-language",
    "url": "/concepts/sa-c-programming-language.html"
  },
  {
    "label": "SA",
    "id": "sa",
    "url": "/concepts/sa.html"
  },
  {
    "label": "SAAL",
    "id": "saal",
    "url": "/concepts/saal.html"
  },
  {
    "label": "SAC-1",
    "id": "sac-1",
    "url": "/concepts/sac-1.html"
  },
  {
    "label": "SAC-2",
    "id": "sac-2",
    "url": "/concepts/sac-2.html"
  },
  {
    "label": "SAC",
    "id": "sac-programming-language",
    "url": "/concepts/sac-programming-language.html"
  },
  {
    "label": "Safari",
    "id": "safari",
    "url": "/concepts/safari.html"
  },
  {
    "label": "Sage",
    "id": "sagemath",
    "url": "/concepts/sagemath.html"
  },
  {
    "label": "System Automatycznego Kodowania Operacji",
    "id": "sako",
    "url": "/concepts/sako.html"
  },
  {
    "label": "SALE",
    "id": "sale",
    "url": "/concepts/sale.html"
  },
  {
    "label": "SALEM",
    "id": "salem",
    "url": "/concepts/salem.html"
  },
  {
    "label": "Simple Actor Language System and Architecture",
    "id": "salsa",
    "url": "/concepts/salsa.html"
  },
  {
    "label": "SaltStack",
    "id": "saltstack",
    "url": "/concepts/saltstack.html"
  },
  {
    "label": "Sam Coupé",
    "id": "sam-coupe",
    "url": "/concepts/sam-coupe.html"
  },
  {
    "label": "SAM file format",
    "id": "sam-format",
    "url": "/concepts/sam-format.html"
  },
  {
    "label": "SAM76",
    "id": "sam76",
    "url": "/concepts/sam76.html"
  },
  {
    "label": "Security Assertion Markup Language",
    "id": "saml",
    "url": "/concepts/saml.html"
  },
  {
    "label": "Sampletalk",
    "id": "sampletalk",
    "url": "/concepts/sampletalk.html"
  },
  {
    "label": "SAOL",
    "id": "saol",
    "url": "/concepts/saol.html"
  },
  {
    "label": "SAP HANA",
    "id": "sap-hana",
    "url": "/concepts/sap-hana.html"
  },
  {
    "label": "Sapphire",
    "id": "sapphire",
    "url": "/concepts/sapphire.html"
  },
  {
    "label": "SARL",
    "id": "sarl",
    "url": "/concepts/sarl.html"
  },
  {
    "label": "SARTEX",
    "id": "sartex",
    "url": "/concepts/sartex.html"
  },
  {
    "label": "SAS",
    "id": "sas",
    "url": "/concepts/sas.html"
  },
  {
    "label": "SASL",
    "id": "sasl-programming-language",
    "url": "/concepts/sasl-programming-language.html"
  },
  {
    "label": "Sass",
    "id": "sass",
    "url": "/concepts/sass.html"
  },
  {
    "label": "Sassy",
    "id": "sassy",
    "url": "/concepts/sassy.html"
  },
  {
    "label": "Sather-K",
    "id": "sather-k",
    "url": "/concepts/sather-k.html"
  },
  {
    "label": "Sather",
    "id": "sather",
    "url": "/concepts/sather.html"
  },
  {
    "label": "SATySFi",
    "id": "satysfi",
    "url": "/concepts/satysfi.html"
  },
  {
    "label": "SAUSTALL",
    "id": "saustall",
    "url": "/concepts/saustall.html"
  },
  {
    "label": "Savi",
    "id": "savi",
    "url": "/concepts/savi.html"
  },
  {
    "label": "Sawzall",
    "id": "sawzall",
    "url": "/concepts/sawzall.html"
  },
  {
    "label": "SB-ONE",
    "id": "sb-one",
    "url": "/concepts/sb-one.html"
  },
  {
    "label": "SBA",
    "id": "sba",
    "url": "/concepts/sba.html"
  },
  {
    "label": "SBASIC",
    "id": "sbasic",
    "url": "/concepts/sbasic.html"
  },
  {
    "label": "Steel Bank Common Lisp",
    "id": "sbcl",
    "url": "/concepts/sbcl.html"
  },
  {
    "label": "Systems Biology Markup Language",
    "id": "sbml",
    "url": "/concepts/sbml.html"
  },
  {
    "label": "The Synthetic Biology Open Language",
    "id": "sbol",
    "url": "/concepts/sbol.html"
  },
  {
    "label": "Scala.js",
    "id": "scala-js",
    "url": "/concepts/scala-js.html"
  },
  {
    "label": "Scala",
    "id": "scala",
    "url": "/concepts/scala.html"
  },
  {
    "label": "SCALPEL",
    "id": "scalpel",
    "url": "/concepts/scalpel.html"
  },
  {
    "label": "Scala Markup Language",
    "id": "scaml",
    "url": "/concepts/scaml.html"
  },
  {
    "label": "SCAN",
    "id": "scan",
    "url": "/concepts/scan.html"
  },
  {
    "label": "SCAT",
    "id": "scat",
    "url": "/concepts/scat.html"
  },
  {
    "label": "Scenic",
    "id": "scenic",
    "url": "/concepts/scenic.html"
  },
  {
    "label": "SCHEMAL",
    "id": "schemal",
    "url": "/concepts/schemal.html"
  },
  {
    "label": "Schema.org",
    "id": "schemaorg",
    "url": "/concepts/schemaorg.html"
  },
  {
    "label": "Schematron",
    "id": "schematron",
    "url": "/concepts/schematron.html"
  },
  {
    "label": "Scheme 2-D",
    "id": "scheme-2-d",
    "url": "/concepts/scheme-2-d.html"
  },
  {
    "label": "Scheme",
    "id": "scheme",
    "url": "/concepts/scheme.html"
  },
  {
    "label": "School",
    "id": "school",
    "url": "/concepts/school.html"
  },
  {
    "label": "Schoonschip",
    "id": "schoonschip",
    "url": "/concepts/schoonschip.html"
  },
  {
    "label": "Schrödinger's Equation",
    "id": "schrodingers-equation",
    "url": "/concepts/schrodingers-equation.html"
  },
  {
    "label": "Scieneer Common Lisp",
    "id": "scieneer-common-lisp",
    "url": "/concepts/scieneer-common-lisp.html"
  },
  {
    "label": "Scikit-learn",
    "id": "scikit-learn",
    "url": "/concepts/scikit-learn.html"
  },
  {
    "label": "SCIL-VP",
    "id": "scil-vp",
    "url": "/concepts/scil-vp.html"
  },
  {
    "label": "Scilab",
    "id": "scilab",
    "url": "/concepts/scilab.html"
  },
  {
    "label": "SciPy",
    "id": "scipy",
    "url": "/concepts/scipy.html"
  },
  {
    "label": "Structured Control Language",
    "id": "scl",
    "url": "/concepts/scl.html"
  },
  {
    "label": "Sclipting",
    "id": "sclipting",
    "url": "/concepts/sclipting.html"
  },
  {
    "label": "SCM",
    "id": "scm",
    "url": "/concepts/scm.html"
  },
  {
    "label": "Scoop",
    "id": "scoop-pm",
    "url": "/concepts/scoop-pm.html"
  },
  {
    "label": "SCOOP",
    "id": "scoop",
    "url": "/concepts/scoop.html"
  },
  {
    "label": "scopes",
    "id": "scopes",
    "url": "/concepts/scopes.html"
  },
  {
    "label": "score",
    "id": "score",
    "url": "/concepts/score.html"
  },
  {
    "label": "Scrapscript",
    "id": "scrapscript",
    "url": "/concepts/scrapscript.html"
  },
  {
    "label": "Scratch",
    "id": "scratch",
    "url": "/concepts/scratch.html"
  },
  {
    "label": "Scratchpad II",
    "id": "scratchpad-ii",
    "url": "/concepts/scratchpad-ii.html"
  },
  {
    "label": "Scratchpad",
    "id": "scratchpad",
    "url": "/concepts/scratchpad.html"
  },
  {
    "label": "SCREAMER",
    "id": "screamer",
    "url": "/concepts/screamer.html"
  },
  {
    "label": "scribble",
    "id": "scribble",
    "url": "/concepts/scribble.html"
  },
  {
    "label": "Scribe",
    "id": "scribe",
    "url": "/concepts/scribe.html"
  },
  {
    "label": "Scrimshaw",
    "id": "scrimshaw",
    "url": "/concepts/scrimshaw.html"
  },
  {
    "label": "SCRIPT markup",
    "id": "script",
    "url": "/concepts/script.html"
  },
  {
    "label": "ScriptBasic",
    "id": "scriptbasic",
    "url": "/concepts/scriptbasic.html"
  },
  {
    "label": "ScriptEase",
    "id": "scriptease",
    "url": "/concepts/scriptease.html"
  },
  {
    "label": "Scriptol",
    "id": "scriptol",
    "url": "/concepts/scriptol.html"
  },
  {
    "label": "ScriptX",
    "id": "scriptx",
    "url": "/concepts/scriptx.html"
  },
  {
    "label": "SCROLL",
    "id": "scroll-lang",
    "url": "/concepts/scroll-lang.html"
  },
  {
    "label": "Scroll",
    "id": "scroll",
    "url": "/concepts/scroll.html"
  },
  {
    "label": "Scsh",
    "id": "scsh",
    "url": "/concepts/scsh.html"
  },
  {
    "label": "SCSS",
    "id": "scss",
    "url": "/concepts/scss.html"
  },
  {
    "label": "sdf-format",
    "id": "sdf-format",
    "url": "/concepts/sdf-format.html"
  },
  {
    "label": "SDF",
    "id": "sdf",
    "url": "/concepts/sdf.html"
  },
  {
    "label": "Shared Dataspace Language",
    "id": "sdl",
    "url": "/concepts/sdl.html"
  },
  {
    "label": "SdlBasic",
    "id": "sdlbasic",
    "url": "/concepts/sdlbasic.html"
  },
  {
    "label": "SDMS",
    "id": "sdms",
    "url": "/concepts/sdms.html"
  },
  {
    "label": "SDTM",
    "id": "sdtm",
    "url": "/concepts/sdtm.html"
  },
  {
    "label": "SEARCH",
    "id": "search",
    "url": "/concepts/search.html"
  },
  {
    "label": "SectorC",
    "id": "sectorc",
    "url": "/concepts/sectorc.html"
  },
  {
    "label": "Secure Operations Language",
    "id": "secure-operations-language",
    "url": "/concepts/secure-operations-language.html"
  },
  {
    "label": "sed",
    "id": "sed",
    "url": "/concepts/sed.html"
  },
  {
    "label": "Seed7",
    "id": "seed7",
    "url": "/concepts/seed7.html"
  },
  {
    "label": "SEGRAS",
    "id": "segras",
    "url": "/concepts/segras.html"
  },
  {
    "label": "Self",
    "id": "self",
    "url": "/concepts/self.html"
  },
  {
    "label": "SEMANOL",
    "id": "semanol",
    "url": "/concepts/semanol.html"
  },
  {
    "label": "Semi-Thue",
    "id": "semi-thue-system",
    "url": "/concepts/semi-thue-system.html"
  },
  {
    "label": "semicolon",
    "id": "semicolon",
    "url": "/concepts/semicolon.html"
  },
  {
    "label": "Semantic Versioning",
    "id": "semver",
    "url": "/concepts/semver.html"
  },
  {
    "label": "Standard for Exchange of Non-clinical Data",
    "id": "send-standard",
    "url": "/concepts/send-standard.html"
  },
  {
    "label": "SenseTalk",
    "id": "sensetalk",
    "url": "/concepts/sensetalk.html"
  },
  {
    "label": "sentient",
    "id": "sentient",
    "url": "/concepts/sentient.html"
  },
  {
    "label": "Seph",
    "id": "seph-programming-language",
    "url": "/concepts/seph-programming-language.html"
  },
  {
    "label": "sepi",
    "id": "sepi",
    "url": "/concepts/sepi.html"
  },
  {
    "label": "Seq",
    "id": "seq",
    "url": "/concepts/seq.html"
  },
  {
    "label": "Seque",
    "id": "seque",
    "url": "/concepts/seque.html"
  },
  {
    "label": "SEQUEL 2",
    "id": "sequel-2",
    "url": "/concepts/sequel-2.html"
  },
  {
    "label": "SequenceL",
    "id": "sequencel",
    "url": "/concepts/sequencel.html"
  },
  {
    "label": "SFC",
    "id": "sequential-function-chart",
    "url": "/concepts/sequential-function-chart.html"
  },
  {
    "label": "Sequential Pascal",
    "id": "sequential-pascal",
    "url": "/concepts/sequential-pascal.html"
  },
  {
    "label": "Serious",
    "id": "serious",
    "url": "/concepts/serious.html"
  },
  {
    "label": "Service Modeling Language",
    "id": "service-modeling-language",
    "url": "/concepts/service-modeling-language.html"
  },
  {
    "label": "SESPATH",
    "id": "sespath",
    "url": "/concepts/sespath.html"
  },
  {
    "label": "SESPOOL",
    "id": "sespool",
    "url": "/concepts/sespool.html"
  },
  {
    "label": "Set-builder notation",
    "id": "set-builder-notation",
    "url": "/concepts/set-builder-notation.html"
  },
  {
    "label": "SETL",
    "id": "setl",
    "url": "/concepts/setl.html"
  },
  {
    "label": "SetLog",
    "id": "setlog",
    "url": "/concepts/setlog.html"
  },
  {
    "label": "setlx",
    "id": "setlx",
    "url": "/concepts/setlx.html"
  },
  {
    "label": "Setun",
    "id": "setun",
    "url": "/concepts/setun.html"
  },
  {
    "label": "SEVAL",
    "id": "seval",
    "url": "/concepts/seval.html"
  },
  {
    "label": "Seymour",
    "id": "seymour",
    "url": "/concepts/seymour.html"
  },
  {
    "label": "SGML",
    "id": "sgml",
    "url": "/concepts/sgml.html"
  },
  {
    "label": "sh",
    "id": "sh",
    "url": "/concepts/sh.html"
  },
  {
    "label": "SHA-1",
    "id": "sha-1-hash-function",
    "url": "/concepts/sha-1-hash-function.html"
  },
  {
    "label": "SHA-2",
    "id": "sha-2-hash-function",
    "url": "/concepts/sha-2-hash-function.html"
  },
  {
    "label": "SHA-3",
    "id": "sha-3-hash-function",
    "url": "/concepts/sha-3-hash-function.html"
  },
  {
    "label": "SHACL",
    "id": "shacl",
    "url": "/concepts/shacl.html"
  },
  {
    "label": "shadama",
    "id": "shadama",
    "url": "/concepts/shadama.html"
  },
  {
    "label": "shade",
    "id": "shade",
    "url": "/concepts/shade.html"
  },
  {
    "label": "ShaderLab",
    "id": "shaderlab",
    "url": "/concepts/shaderlab.html"
  },
  {
    "label": "SHADOW",
    "id": "shadow",
    "url": "/concepts/shadow.html"
  },
  {
    "label": "Shakespeare",
    "id": "shakespeare-programming-language",
    "url": "/concepts/shakespeare-programming-language.html"
  },
  {
    "label": "shakti",
    "id": "shakti",
    "url": "/concepts/shakti.html"
  },
  {
    "label": "sham",
    "id": "sham",
    "url": "/concepts/sham.html"
  },
  {
    "label": "Shapefile",
    "id": "shapefile",
    "url": "/concepts/shapefile.html"
  },
  {
    "label": "ShapeUp",
    "id": "shapeup",
    "url": "/concepts/shapeup.html"
  },
  {
    "label": "Shared Prolog",
    "id": "shared-prolog",
    "url": "/concepts/shared-prolog.html"
  },
  {
    "label": "sharpscript",
    "id": "sharpscript",
    "url": "/concepts/sharpscript.html"
  },
  {
    "label": "Sheep",
    "id": "sheep-lang",
    "url": "/concepts/sheep-lang.html"
  },
  {
    "label": "SHEEP",
    "id": "sheep",
    "url": "/concepts/sheep.html"
  },
  {
    "label": "SheerPower4GL",
    "id": "sheerpower4gl",
    "url": "/concepts/sheerpower4gl.html"
  },
  {
    "label": "Shen",
    "id": "shen",
    "url": "/concepts/shen.html"
  },
  {
    "label": "ShEx",
    "id": "shex",
    "url": "/concepts/shex.html"
  },
  {
    "label": "SHIFT",
    "id": "shift",
    "url": "/concepts/shift.html"
  },
  {
    "label": "shill",
    "id": "shill",
    "url": "/concepts/shill.html"
  },
  {
    "label": "shiv",
    "id": "shiv",
    "url": "/concepts/shiv.html"
  },
  {
    "label": "shml",
    "id": "shml",
    "url": "/concepts/shml.html"
  },
  {
    "label": "SHOE",
    "id": "shoe",
    "url": "/concepts/shoe.html"
  },
  {
    "label": "Short Code computer language",
    "id": "short-code-computer-language",
    "url": "/concepts/short-code-computer-language.html"
  },
  {
    "label": "SHRDLU",
    "id": "shrdlu",
    "url": "/concepts/shrdlu.html"
  },
  {
    "label": "SI Library",
    "id": "si-library",
    "url": "/concepts/si-library.html"
  },
  {
    "label": "SI",
    "id": "si",
    "url": "/concepts/si.html"
  },
  {
    "label": "Sibelius",
    "id": "sibelius-software",
    "url": "/concepts/sibelius-software.html"
  },
  {
    "label": "Sibilant",
    "id": "sibilant",
    "url": "/concepts/sibilant.html"
  },
  {
    "label": "SIDOPS+",
    "id": "sidopsp",
    "url": "/concepts/sidopsp.html"
  },
  {
    "label": "sierra",
    "id": "sierra",
    "url": "/concepts/sierra.html"
  },
  {
    "label": "Sieve mail filtering language",
    "id": "sieve",
    "url": "/concepts/sieve.html"
  },
  {
    "label": "SIGMA 76",
    "id": "sigma-76",
    "url": "/concepts/sigma-76.html"
  },
  {
    "label": "SIGNAL",
    "id": "signal",
    "url": "/concepts/signal.html"
  },
  {
    "label": "SIL",
    "id": "sil",
    "url": "/concepts/sil.html"
  },
  {
    "label": "sile",
    "id": "sile",
    "url": "/concepts/sile.html"
  },
  {
    "label": "silk",
    "id": "silk",
    "url": "/concepts/silk.html"
  },
  {
    "label": "sill",
    "id": "sill",
    "url": "/concepts/sill.html"
  },
  {
    "label": "SIMAN IV",
    "id": "siman-iv",
    "url": "/concepts/siman-iv.html"
  },
  {
    "label": "SIMAN",
    "id": "siman",
    "url": "/concepts/siman.html"
  },
  {
    "label": "SIMCAL",
    "id": "simcal",
    "url": "/concepts/simcal.html"
  },
  {
    "label": "SimCode",
    "id": "simcode",
    "url": "/concepts/simcode.html"
  },
  {
    "label": "SIMDIS",
    "id": "simdis",
    "url": "/concepts/simdis.html"
  },
  {
    "label": "SIMFACTORY",
    "id": "simfactory",
    "url": "/concepts/simfactory.html"
  },
  {
    "label": "simit",
    "id": "simit",
    "url": "/concepts/simit.html"
  },
  {
    "label": "Simkin",
    "id": "simkin-programming-language",
    "url": "/concepts/simkin-programming-language.html"
  },
  {
    "label": "SIML/I",
    "id": "siml-i",
    "url": "/concepts/siml-i.html"
  },
  {
    "label": "SIMNET",
    "id": "simnet",
    "url": "/concepts/simnet.html"
  },
  {
    "label": "SIMODULA",
    "id": "simodula",
    "url": "/concepts/simodula.html"
  },
  {
    "label": "Simons' BASIC",
    "id": "simons-basic",
    "url": "/concepts/simons-basic.html"
  },
  {
    "label": "SIMPAS",
    "id": "simpas",
    "url": "/concepts/simpas.html"
  },
  {
    "label": "SIMPL",
    "id": "simpl",
    "url": "/concepts/simpl.html"
  },
  {
    "label": "Simple Binary Encoding",
    "id": "simple-binary-encoding",
    "url": "/concepts/simple-binary-encoding.html"
  },
  {
    "label": "Simple Stackless Lisp",
    "id": "simple-stackless-lisp",
    "url": "/concepts/simple-stackless-lisp.html"
  },
  {
    "label": "SIMPLE",
    "id": "simple",
    "url": "/concepts/simple.html"
  },
  {
    "label": "SimpleScript",
    "id": "simplescript",
    "url": "/concepts/simplescript.html"
  },
  {
    "label": "Simplicity",
    "id": "simplictiy",
    "url": "/concepts/simplictiy.html"
  },
  {
    "label": "Sim++",
    "id": "simpp",
    "url": "/concepts/simpp.html"
  },
  {
    "label": "SIMSCRIPT",
    "id": "simscript",
    "url": "/concepts/simscript.html"
  },
  {
    "label": "SIMUL",
    "id": "simul",
    "url": "/concepts/simul.html"
  },
  {
    "label": "SIMULA 67",
    "id": "simula-67",
    "url": "/concepts/simula-67.html"
  },
  {
    "label": "Simula",
    "id": "simula",
    "url": "/concepts/simula.html"
  },
  {
    "label": "Simulink",
    "id": "simulink",
    "url": "/concepts/simulink.html"
  },
  {
    "label": "sina",
    "id": "sina",
    "url": "/concepts/sina.html"
  },
  {
    "label": "Sinclair BASIC",
    "id": "sinclair-basic",
    "url": "/concepts/sinclair-basic.html"
  },
  {
    "label": "Sing Sharp",
    "id": "sing-sharp",
    "url": "/concepts/sing-sharp.html"
  },
  {
    "label": "singular",
    "id": "singular",
    "url": "/concepts/singular.html"
  },
  {
    "label": "SipHash",
    "id": "siphash-hash-function",
    "url": "/concepts/siphash-hash-function.html"
  },
  {
    "label": "Siprol",
    "id": "siprol",
    "url": "/concepts/siprol.html"
  },
  {
    "label": "Siri",
    "id": "siri",
    "url": "/concepts/siri.html"
  },
  {
    "label": "SISAL",
    "id": "sisal",
    "url": "/concepts/sisal.html"
  },
  {
    "label": "SISC",
    "id": "sisc",
    "url": "/concepts/sisc.html"
  },
  {
    "label": "Sitemap",
    "id": "sitemap",
    "url": "/concepts/sitemap.html"
  },
  {
    "label": "sixten",
    "id": "sixten",
    "url": "/concepts/sixten.html"
  },
  {
    "label": "sizzle",
    "id": "sizzle",
    "url": "/concepts/sizzle.html"
  },
  {
    "label": "SK8",
    "id": "sk8",
    "url": "/concepts/sk8.html"
  },
  {
    "label": "Sketchpad III",
    "id": "sketchpad-iii",
    "url": "/concepts/sketchpad-iii.html"
  },
  {
    "label": "Sketchpad",
    "id": "sketchpad",
    "url": "/concepts/sketchpad.html"
  },
  {
    "label": "skew",
    "id": "skew",
    "url": "/concepts/skew.html"
  },
  {
    "label": "SKIL",
    "id": "skil",
    "url": "/concepts/skil.html"
  },
  {
    "label": "skip",
    "id": "skip",
    "url": "/concepts/skip.html"
  },
  {
    "label": "skookumscript",
    "id": "skookumscript",
    "url": "/concepts/skookumscript.html"
  },
  {
    "label": "skulpt",
    "id": "skulpt",
    "url": "/concepts/skulpt.html"
  },
  {
    "label": "SKY",
    "id": "sky",
    "url": "/concepts/sky.html"
  },
  {
    "label": "SL",
    "id": "sl",
    "url": "/concepts/sl.html"
  },
  {
    "label": "SL5",
    "id": "sl5",
    "url": "/concepts/sl5.html"
  },
  {
    "label": "SLAM II",
    "id": "slam-ii",
    "url": "/concepts/slam-ii.html"
  },
  {
    "label": "SLANG",
    "id": "slang",
    "url": "/concepts/slang.html"
  },
  {
    "label": "Slash",
    "id": "slash",
    "url": "/concepts/slash.html"
  },
  {
    "label": "SLEUTH",
    "id": "sleuth",
    "url": "/concepts/sleuth.html"
  },
  {
    "label": "Slice",
    "id": "slice",
    "url": "/concepts/slice.html"
  },
  {
    "label": "Slick",
    "id": "slick",
    "url": "/concepts/slick.html"
  },
  {
    "label": "Slideshow",
    "id": "slideshow",
    "url": "/concepts/slideshow.html"
  },
  {
    "label": "Slim Framework",
    "id": "slim-framework",
    "url": "/concepts/slim-framework.html"
  },
  {
    "label": "slim-pl",
    "id": "slim-pl",
    "url": "/concepts/slim-pl.html"
  },
  {
    "label": "Slim",
    "id": "slim",
    "url": "/concepts/slim.html"
  },
  {
    "label": "SLIP",
    "id": "slip",
    "url": "/concepts/slip.html"
  },
  {
    "label": "SLIPS",
    "id": "slips",
    "url": "/concepts/slips.html"
  },
  {
    "label": "SLOG",
    "id": "slog",
    "url": "/concepts/slog.html"
  },
  {
    "label": "Slony",
    "id": "slony",
    "url": "/concepts/slony.html"
  },
  {
    "label": "Slope",
    "id": "slope",
    "url": "/concepts/slope.html"
  },
  {
    "label": "SLPL",
    "id": "slpl",
    "url": "/concepts/slpl.html"
  },
  {
    "label": "SMALGOL",
    "id": "smalgol",
    "url": "/concepts/smalgol.html"
  },
  {
    "label": "Smali",
    "id": "smali",
    "url": "/concepts/smali.html"
  },
  {
    "label": "Small-C",
    "id": "small-c",
    "url": "/concepts/small-c.html"
  },
  {
    "label": "Small Euclid",
    "id": "small-euclid",
    "url": "/concepts/small-euclid.html"
  },
  {
    "label": "SMALL-X",
    "id": "small-x",
    "url": "/concepts/small-x.html"
  },
  {
    "label": "Small",
    "id": "small",
    "url": "/concepts/small.html"
  },
  {
    "label": "SmallBASIC",
    "id": "smallbasic",
    "url": "/concepts/smallbasic.html"
  },
  {
    "label": "Smalltalk-76",
    "id": "smalltalk-76",
    "url": "/concepts/smalltalk-76.html"
  },
  {
    "label": "Smalltalk-80",
    "id": "smalltalk-80",
    "url": "/concepts/smalltalk-80.html"
  },
  {
    "label": "Smalltalk MT",
    "id": "smalltalk-mt",
    "url": "/concepts/smalltalk-mt.html"
  },
  {
    "label": "Smalltalk/V",
    "id": "smalltalk-v",
    "url": "/concepts/smalltalk-v.html"
  },
  {
    "label": "Smalltalk YX",
    "id": "smalltalk-yx",
    "url": "/concepts/smalltalk-yx.html"
  },
  {
    "label": "Smalltalk",
    "id": "smalltalk",
    "url": "/concepts/smalltalk.html"
  },
  {
    "label": "smalltalkhub-pm",
    "id": "smalltalkhub-pm",
    "url": "/concepts/smalltalkhub-pm.html"
  },
  {
    "label": "SmallVDM",
    "id": "smallvdm",
    "url": "/concepts/smallvdm.html"
  },
  {
    "label": "SMART",
    "id": "smart",
    "url": "/concepts/smart.html"
  },
  {
    "label": "SmartGameFormat",
    "id": "smartgameformat",
    "url": "/concepts/smartgameformat.html"
  },
  {
    "label": "SMILES arbitrary target specification",
    "id": "smarts",
    "url": "/concepts/smarts.html"
  },
  {
    "label": "Smartsheet",
    "id": "smartsheet-app",
    "url": "/concepts/smartsheet-app.html"
  },
  {
    "label": "Smarty",
    "id": "smarty",
    "url": "/concepts/smarty.html"
  },
  {
    "label": "SMDL",
    "id": "smdl",
    "url": "/concepts/smdl.html"
  },
  {
    "label": "Smile data interchange format",
    "id": "smile",
    "url": "/concepts/smile.html"
  },
  {
    "label": "Smiles",
    "id": "smiles-format",
    "url": "/concepts/smiles-format.html"
  },
  {
    "label": "Smithy",
    "id": "smithy",
    "url": "/concepts/smithy.html"
  },
  {
    "label": "SMOKE",
    "id": "smoke",
    "url": "/concepts/smoke.html"
  },
  {
    "label": "SMoLCS",
    "id": "smolcs",
    "url": "/concepts/smolcs.html"
  },
  {
    "label": "Semantic Patch Language",
    "id": "smpl",
    "url": "/concepts/smpl.html"
  },
  {
    "label": "SMSL",
    "id": "smsl",
    "url": "/concepts/smsl.html"
  },
  {
    "label": "SMT",
    "id": "smt",
    "url": "/concepts/smt.html"
  },
  {
    "label": "SMTP",
    "id": "smtp",
    "url": "/concepts/smtp.html"
  },
  {
    "label": "SMX",
    "id": "smx-computer-language",
    "url": "/concepts/smx-computer-language.html"
  },
  {
    "label": "snakemake",
    "id": "snakemake",
    "url": "/concepts/snakemake.html"
  },
  {
    "label": "Snap!",
    "id": "snap",
    "url": "/concepts/snap.html"
  },
  {
    "label": "SnapTag",
    "id": "snaptag",
    "url": "/concepts/snaptag.html"
  },
  {
    "label": "SNBT",
    "id": "snbt",
    "url": "/concepts/snbt.html"
  },
  {
    "label": "Snit",
    "id": "snit",
    "url": "/concepts/snit.html"
  },
  {
    "label": "SNOBAT",
    "id": "snobat",
    "url": "/concepts/snobat.html"
  },
  {
    "label": "SNOBOL",
    "id": "snobol",
    "url": "/concepts/snobol.html"
  },
  {
    "label": "SNOBOL3",
    "id": "snobol3",
    "url": "/concepts/snobol3.html"
  },
  {
    "label": "SNOBOL4",
    "id": "snobol4",
    "url": "/concepts/snobol4.html"
  },
  {
    "label": "SNOOP",
    "id": "snoop",
    "url": "/concepts/snoop.html"
  },
  {
    "label": "Snostorm",
    "id": "snostorm",
    "url": "/concepts/snostorm.html"
  },
  {
    "label": "Snowball",
    "id": "snowball-programming-language",
    "url": "/concepts/snowball-programming-language.html"
  },
  {
    "label": "Snowman",
    "id": "snowman-decompiler",
    "url": "/concepts/snowman-decompiler.html"
  },
  {
    "label": "SNQL: A Social Network Query and Transformation Language",
    "id": "snql",
    "url": "/concepts/snql.html"
  },
  {
    "label": "SOAP",
    "id": "soap",
    "url": "/concepts/soap.html"
  },
  {
    "label": "Symbolic Optimal Assembly Program",
    "id": "soaplang",
    "url": "/concepts/soaplang.html"
  },
  {
    "label": "Soar Markup Language",
    "id": "soar-ml",
    "url": "/concepts/soar-ml.html"
  },
  {
    "label": "SoQL",
    "id": "social-networks-query-language",
    "url": "/concepts/social-networks-query-language.html"
  },
  {
    "label": "socialite",
    "id": "socialite",
    "url": "/concepts/socialite.html"
  },
  {
    "label": "solaris-pm",
    "id": "solaris-pm",
    "url": "/concepts/solaris-pm.html"
  },
  {
    "label": "Solaris",
    "id": "solaris",
    "url": "/concepts/solaris.html"
  },
  {
    "label": "solid",
    "id": "solid",
    "url": "/concepts/solid.html"
  },
  {
    "label": "Solidity",
    "id": "solidity",
    "url": "/concepts/solidity.html"
  },
  {
    "label": "SOLMAR",
    "id": "solmar",
    "url": "/concepts/solmar.html"
  },
  {
    "label": "son",
    "id": "son",
    "url": "/concepts/son.html"
  },
  {
    "label": "Sophia",
    "id": "sophia",
    "url": "/concepts/sophia.html"
  },
  {
    "label": "Socrata Query Language",
    "id": "soql-lang",
    "url": "/concepts/soql-lang.html"
  },
  {
    "label": "SOQL",
    "id": "soql",
    "url": "/concepts/soql.html"
  },
  {
    "label": "sora",
    "id": "sora",
    "url": "/concepts/sora.html"
  },
  {
    "label": "SORCA",
    "id": "sorca",
    "url": "/concepts/sorca.html"
  },
  {
    "label": "Sort Merge Generator",
    "id": "sort-merge-generator",
    "url": "/concepts/sort-merge-generator.html"
  },
  {
    "label": "SOSL",
    "id": "sosl",
    "url": "/concepts/sosl.html"
  },
  {
    "label": "souffle",
    "id": "souffle",
    "url": "/concepts/souffle.html"
  },
  {
    "label": "soul",
    "id": "soul",
    "url": "/concepts/soul.html"
  },
  {
    "label": "Soulver",
    "id": "soulver",
    "url": "/concepts/soulver.html"
  },
  {
    "label": "souper",
    "id": "souper",
    "url": "/concepts/souper.html"
  },
  {
    "label": "sourcelair-editor",
    "id": "sourcelair-editor",
    "url": "/concepts/sourcelair-editor.html"
  },
  {
    "label": "SourcePawn",
    "id": "sourcepawn",
    "url": "/concepts/sourcepawn.html"
  },
  {
    "label": "Sourcetree",
    "id": "sourcetree",
    "url": "/concepts/sourcetree.html"
  },
  {
    "label": "Southampton BASIC System",
    "id": "southampton-basic-system",
    "url": "/concepts/southampton-basic-system.html"
  },
  {
    "label": "Schema for Object-Oriented XML",
    "id": "sox",
    "url": "/concepts/sox.html"
  },
  {
    "label": "Soy",
    "id": "soy",
    "url": "/concepts/soy.html"
  },
  {
    "label": "SP/k",
    "id": "sp-k",
    "url": "/concepts/sp-k.html"
  },
  {
    "label": "Space",
    "id": "space",
    "url": "/concepts/space.html"
  },
  {
    "label": "SPARC",
    "id": "sparc",
    "url": "/concepts/sparc.html"
  },
  {
    "label": "Spark",
    "id": "spark-pl",
    "url": "/concepts/spark-pl.html"
  },
  {
    "label": "spark-pm",
    "id": "spark-pm",
    "url": "/concepts/spark-pm.html"
  },
  {
    "label": "Apache Spark",
    "id": "spark",
    "url": "/concepts/spark.html"
  },
  {
    "label": "SPARQCode",
    "id": "sparqcode",
    "url": "/concepts/sparqcode.html"
  },
  {
    "label": "SPARQL",
    "id": "sparql",
    "url": "/concepts/sparql.html"
  },
  {
    "label": "Spatial",
    "id": "spatial",
    "url": "/concepts/spatial.html"
  },
  {
    "label": "Speakeasy",
    "id": "speakeasy",
    "url": "/concepts/speakeasy.html"
  },
  {
    "label": "Spec Sharp",
    "id": "spec-sharp",
    "url": "/concepts/spec-sharp.html"
  },
  {
    "label": "Spec",
    "id": "spec",
    "url": "/concepts/spec.html"
  },
  {
    "label": "SPECL",
    "id": "specl",
    "url": "/concepts/specl.html"
  },
  {
    "label": "SPECOL",
    "id": "specol",
    "url": "/concepts/specol.html"
  },
  {
    "label": "specrtl",
    "id": "specrtl",
    "url": "/concepts/specrtl.html"
  },
  {
    "label": "Speedcoding",
    "id": "speedcoding",
    "url": "/concepts/speedcoding.html"
  },
  {
    "label": "Speedie",
    "id": "speedie",
    "url": "/concepts/speedie.html"
  },
  {
    "label": "Sender Policy Framework",
    "id": "spf-standard",
    "url": "/concepts/spf-standard.html"
  },
  {
    "label": "Spice Lisp",
    "id": "spice-lisp",
    "url": "/concepts/spice-lisp.html"
  },
  {
    "label": "Spice",
    "id": "spice",
    "url": "/concepts/spice.html"
  },
  {
    "label": "spider",
    "id": "spider",
    "url": "/concepts/spider.html"
  },
  {
    "label": "SpiderBasic",
    "id": "spiderbasic",
    "url": "/concepts/spiderbasic.html"
  },
  {
    "label": "SpiderMonkey",
    "id": "spidermonkey",
    "url": "/concepts/spidermonkey.html"
  },
  {
    "label": "SPIL",
    "id": "spil",
    "url": "/concepts/spil.html"
  },
  {
    "label": "Spill",
    "id": "spill",
    "url": "/concepts/spill.html"
  },
  {
    "label": "Spin",
    "id": "spin",
    "url": "/concepts/spin.html"
  },
  {
    "label": "SPIP",
    "id": "spip",
    "url": "/concepts/spip.html"
  },
  {
    "label": "spir-v",
    "id": "spir-v",
    "url": "/concepts/spir-v.html"
  },
  {
    "label": "Standard Portable Intermediate Representation",
    "id": "spir",
    "url": "/concepts/spir.html"
  },
  {
    "label": "spiral",
    "id": "spiral",
    "url": "/concepts/spiral.html"
  },
  {
    "label": "SPITBOL",
    "id": "spitbol",
    "url": "/concepts/spitbol.html"
  },
  {
    "label": "Structured Product Labeling",
    "id": "spl",
    "url": "/concepts/spl.html"
  },
  {
    "label": "SPLAW",
    "id": "splaw",
    "url": "/concepts/splaw.html"
  },
  {
    "label": "Spline Font Database",
    "id": "spline-font-database",
    "url": "/concepts/spline-font-database.html"
  },
  {
    "label": "Split-C",
    "id": "split-c",
    "url": "/concepts/split-c.html"
  },
  {
    "label": "sporth",
    "id": "sporth",
    "url": "/concepts/sporth.html"
  },
  {
    "label": "SPRINT",
    "id": "sprint",
    "url": "/concepts/sprint.html"
  },
  {
    "label": "Sprite Operating System",
    "id": "sprite-os",
    "url": "/concepts/sprite-os.html"
  },
  {
    "label": "spry",
    "id": "spry",
    "url": "/concepts/spry.html"
  },
  {
    "label": "Symbolic Programming System",
    "id": "sps",
    "url": "/concepts/sps.html"
  },
  {
    "label": "SPSS",
    "id": "spss",
    "url": "/concepts/spss.html"
  },
  {
    "label": "Spyder",
    "id": "spyder-editor",
    "url": "/concepts/spyder-editor.html"
  },
  {
    "label": "SQHTML",
    "id": "sqhtml",
    "url": "/concepts/sqhtml.html"
  },
  {
    "label": "SQL-92",
    "id": "sql-92",
    "url": "/concepts/sql-92.html"
  },
  {
    "label": "SQL/PSM",
    "id": "sql-psm",
    "url": "/concepts/sql-psm.html"
  },
  {
    "label": "SQL",
    "id": "sql",
    "url": "/concepts/sql.html"
  },
  {
    "label": "Sqlalchemy",
    "id": "sqlalchemy",
    "url": "/concepts/sqlalchemy.html"
  },
  {
    "label": "sqlar-format",
    "id": "sqlar-format",
    "url": "/concepts/sqlar-format.html"
  },
  {
    "label": "sqlite-storage-format",
    "id": "sqlite-storage-format",
    "url": "/concepts/sqlite-storage-format.html"
  },
  {
    "label": "SQLite",
    "id": "sqlite",
    "url": "/concepts/sqlite.html"
  },
  {
    "label": "SQLMP",
    "id": "sqlmp",
    "url": "/concepts/sqlmp.html"
  },
  {
    "label": "SQLPL",
    "id": "sqlpl",
    "url": "/concepts/sqlpl.html"
  },
  {
    "label": "Structured Query Reporter",
    "id": "sqr",
    "url": "/concepts/sqr.html"
  },
  {
    "label": "SQRL",
    "id": "sqrl",
    "url": "/concepts/sqrl.html"
  },
  {
    "label": "SQUARE",
    "id": "square",
    "url": "/concepts/square.html"
  },
  {
    "label": "Squeak",
    "id": "squeak",
    "url": "/concepts/squeak.html"
  },
  {
    "label": "SquidConf",
    "id": "squidconf",
    "url": "/concepts/squidconf.html"
  },
  {
    "label": "squiggle",
    "id": "squiggle",
    "url": "/concepts/squiggle.html"
  },
  {
    "label": "Squire",
    "id": "squire",
    "url": "/concepts/squire.html"
  },
  {
    "label": "Squirrel",
    "id": "squirrel",
    "url": "/concepts/squirrel.html"
  },
  {
    "label": "SQUOZE",
    "id": "squoze",
    "url": "/concepts/squoze.html"
  },
  {
    "label": "SQURL",
    "id": "squrl",
    "url": "/concepts/squrl.html"
  },
  {
    "label": "SR",
    "id": "sr-programming-language",
    "url": "/concepts/sr-programming-language.html"
  },
  {
    "label": "SR",
    "id": "sr",
    "url": "/concepts/sr.html"
  },
  {
    "label": "SRecode Template",
    "id": "srecode-template",
    "url": "/concepts/srecode-template.html"
  },
  {
    "label": "SRL",
    "id": "srl",
    "url": "/concepts/srl.html"
  },
  {
    "label": "srv",
    "id": "srv",
    "url": "/concepts/srv.html"
  },
  {
    "label": "Secure Scuttlebutt",
    "id": "ssb",
    "url": "/concepts/ssb.html"
  },
  {
    "label": "Boston College Statistical Software Components",
    "id": "ssc-pm",
    "url": "/concepts/ssc-pm.html"
  },
  {
    "label": "Script.NET",
    "id": "ssharp",
    "url": "/concepts/ssharp.html"
  },
  {
    "label": "SSI",
    "id": "ssi",
    "url": "/concepts/ssi.html"
  },
  {
    "label": "ssl-lang",
    "id": "ssl-lang",
    "url": "/concepts/ssl-lang.html"
  },
  {
    "label": "SSL",
    "id": "ssl",
    "url": "/concepts/ssl.html"
  },
  {
    "label": "Speech Synthesis Markup Language",
    "id": "ssml",
    "url": "/concepts/ssml.html"
  },
  {
    "label": "stacklang",
    "id": "stacklang",
    "url": "/concepts/stacklang.html"
  },
  {
    "label": "Stackless Python",
    "id": "stackless-python",
    "url": "/concepts/stackless-python.html"
  },
  {
    "label": "STAGE2",
    "id": "stage2",
    "url": "/concepts/stage2.html"
  },
  {
    "label": "Stalin",
    "id": "stalin",
    "url": "/concepts/stalin.html"
  },
  {
    "label": "Stan",
    "id": "stan",
    "url": "/concepts/stan.html"
  },
  {
    "label": "Standard Lisp",
    "id": "standard-lisp",
    "url": "/concepts/standard-lisp.html"
  },
  {
    "label": "Standard ML",
    "id": "standard-ml",
    "url": "/concepts/standard-ml.html"
  },
  {
    "label": "STAPLE",
    "id": "staple",
    "url": "/concepts/staple.html"
  },
  {
    "label": "*Prolog",
    "id": "star-prolog",
    "url": "/concepts/star-prolog.html"
  },
  {
    "label": "Star",
    "id": "star",
    "url": "/concepts/star.html"
  },
  {
    "label": "starlark",
    "id": "starlark",
    "url": "/concepts/starlark.html"
  },
  {
    "label": "StarLogo",
    "id": "starlogo",
    "url": "/concepts/starlogo.html"
  },
  {
    "label": "StarOffice Basic",
    "id": "staroffice-basic",
    "url": "/concepts/staroffice-basic.html"
  },
  {
    "label": "starpial",
    "id": "starpial",
    "url": "/concepts/starpial.html"
  },
  {
    "label": "Stata",
    "id": "stata",
    "url": "/concepts/stata.html"
  },
  {
    "label": "statebox",
    "id": "statebox",
    "url": "/concepts/statebox.html"
  },
  {
    "label": "Statemate",
    "id": "statemate",
    "url": "/concepts/statemate.html"
  },
  {
    "label": "Static Typescript",
    "id": "static-typescript",
    "url": "/concepts/static-typescript.html"
  },
  {
    "label": "Statsplorer",
    "id": "statsplorer",
    "url": "/concepts/statsplorer.html"
  },
  {
    "label": "SQF",
    "id": "status-quo-function",
    "url": "/concepts/status-quo-function.html"
  },
  {
    "label": "status-quo-script",
    "id": "status-quo-script",
    "url": "/concepts/status-quo-script.html"
  },
  {
    "label": "Steinhaus-Moser notation",
    "id": "steinhaus-moser-notation",
    "url": "/concepts/steinhaus-moser-notation.html"
  },
  {
    "label": "stella",
    "id": "stella",
    "url": "/concepts/stella.html"
  },
  {
    "label": "Stencil",
    "id": "stencil",
    "url": "/concepts/stencil.html"
  },
  {
    "label": "Statement List",
    "id": "stl",
    "url": "/concepts/stl.html"
  },
  {
    "label": "Stockholm format",
    "id": "stockholm-format",
    "url": "/concepts/stockholm-format.html"
  },
  {
    "label": "STOICAL",
    "id": "stoical",
    "url": "/concepts/stoical.html"
  },
  {
    "label": "STON",
    "id": "ston",
    "url": "/concepts/ston.html"
  },
  {
    "label": "StoneCutter",
    "id": "stonecutter",
    "url": "/concepts/stonecutter.html"
  },
  {
    "label": "stoneknifeforth",
    "id": "stoneknifeforth",
    "url": "/concepts/stoneknifeforth.html"
  },
  {
    "label": "Storymatic",
    "id": "storymatic",
    "url": "/concepts/storymatic.html"
  },
  {
    "label": "storyscript",
    "id": "storyscript",
    "url": "/concepts/storyscript.html"
  },
  {
    "label": "STOS BASIC",
    "id": "stos-basic",
    "url": "/concepts/stos-basic.html"
  },
  {
    "label": "Strand",
    "id": "strand-programming-language",
    "url": "/concepts/strand-programming-language.html"
  },
  {
    "label": "strat",
    "id": "strat",
    "url": "/concepts/strat.html"
  },
  {
    "label": "Stratego/XT",
    "id": "stratego",
    "url": "/concepts/stratego.html"
  },
  {
    "label": "STRCMACS",
    "id": "strcmacs",
    "url": "/concepts/strcmacs.html"
  },
  {
    "label": "StreamIt",
    "id": "streamit",
    "url": "/concepts/streamit.html"
  },
  {
    "label": "Streem",
    "id": "streem",
    "url": "/concepts/streem.html"
  },
  {
    "label": "STREMA",
    "id": "strema",
    "url": "/concepts/strema.html"
  },
  {
    "label": "STRESS",
    "id": "stress",
    "url": "/concepts/stress.html"
  },
  {
    "label": "String diagram",
    "id": "string-diagrams-notation",
    "url": "/concepts/string-diagrams-notation.html"
  },
  {
    "label": "stringbean",
    "id": "stringbean",
    "url": "/concepts/stringbean.html"
  },
  {
    "label": "STRINGCOMP",
    "id": "stringcomp",
    "url": "/concepts/stringcomp.html"
  },
  {
    "label": "Stripe company",
    "id": "stripe",
    "url": "/concepts/stripe.html"
  },
  {
    "label": "Strips",
    "id": "strips",
    "url": "/concepts/strips.html"
  },
  {
    "label": "Strongtalk",
    "id": "strongtalk",
    "url": "/concepts/strongtalk.html"
  },
  {
    "label": "COM Structured Storage",
    "id": "structured-storage",
    "url": "/concepts/structured-storage.html"
  },
  {
    "label": "Structured text",
    "id": "structured-text",
    "url": "/concepts/structured-text.html"
  },
  {
    "label": "strudel",
    "id": "strudel",
    "url": "/concepts/strudel.html"
  },
  {
    "label": "STRUDL",
    "id": "strudl",
    "url": "/concepts/strudl.html"
  },
  {
    "label": "StruQL",
    "id": "struql",
    "url": "/concepts/struql.html"
  },
  {
    "label": "Stutter",
    "id": "stutter-lang",
    "url": "/concepts/stutter-lang.html"
  },
  {
    "label": "stx",
    "id": "stx",
    "url": "/concepts/stx.html"
  },
  {
    "label": "Stylus",
    "id": "stylus",
    "url": "/concepts/stylus.html"
  },
  {
    "label": "sub",
    "id": "sub",
    "url": "/concepts/sub.html"
  },
  {
    "label": "SubL",
    "id": "subl",
    "url": "/concepts/subl.html"
  },
  {
    "label": "Subleq",
    "id": "subleq",
    "url": "/concepts/subleq.html"
  },
  {
    "label": "Sublime Text",
    "id": "sublime-editor",
    "url": "/concepts/sublime-editor.html"
  },
  {
    "label": "Sublime Syntax Test Lang",
    "id": "sublime-syntax-test",
    "url": "/concepts/sublime-syntax-test.html"
  },
  {
    "label": "Sublime Syntax",
    "id": "sublime-syntax",
    "url": "/concepts/sublime-syntax.html"
  },
  {
    "label": "SubRip Text",
    "id": "subrip-text",
    "url": "/concepts/subrip-text.html"
  },
  {
    "label": "subscript",
    "id": "subscript",
    "url": "/concepts/subscript.html"
  },
  {
    "label": "Subtext",
    "id": "subtext",
    "url": "/concepts/subtext.html"
  },
  {
    "label": "Subversion",
    "id": "subversion",
    "url": "/concepts/subversion.html"
  },
  {
    "label": "SubX",
    "id": "subx",
    "url": "/concepts/subx.html"
  },
  {
    "label": "Sue",
    "id": "sue",
    "url": "/concepts/sue.html"
  },
  {
    "label": "Sugar",
    "id": "sugar",
    "url": "/concepts/sugar.html"
  },
  {
    "label": "sugarj",
    "id": "sugarj",
    "url": "/concepts/sugarj.html"
  },
  {
    "label": "SugarSS",
    "id": "sugarss",
    "url": "/concepts/sugarss.html"
  },
  {
    "label": "sugartex",
    "id": "sugartex",
    "url": "/concepts/sugartex.html"
  },
  {
    "label": "Sugi",
    "id": "sugi",
    "url": "/concepts/sugi.html"
  },
  {
    "label": "SUMMER",
    "id": "summer",
    "url": "/concepts/summer.html"
  },
  {
    "label": "Sun Raster",
    "id": "sun-raster-format",
    "url": "/concepts/sun-raster-format.html"
  },
  {
    "label": "Suneido",
    "id": "suneido",
    "url": "/concepts/suneido.html"
  },
  {
    "label": "SuperBASIC",
    "id": "superbasic",
    "url": "/concepts/superbasic.html"
  },
  {
    "label": "SuperCollider",
    "id": "supercollider",
    "url": "/concepts/supercollider.html"
  },
  {
    "label": "SuperForth",
    "id": "superforth",
    "url": "/concepts/superforth.html"
  },
  {
    "label": "Superjson",
    "id": "superjson",
    "url": "/concepts/superjson.html"
  },
  {
    "label": "SUPERMAC",
    "id": "supermac",
    "url": "/concepts/supermac.html"
  },
  {
    "label": "Superplan",
    "id": "superplan",
    "url": "/concepts/superplan.html"
  },
  {
    "label": "SuperTalk",
    "id": "supertalk",
    "url": "/concepts/supertalk.html"
  },
  {
    "label": "Superx++",
    "id": "superxpp",
    "url": "/concepts/superxpp.html"
  },
  {
    "label": "SURGE",
    "id": "surge",
    "url": "/concepts/surge.html"
  },
  {
    "label": "Svelte",
    "id": "svelte",
    "url": "/concepts/svelte.html"
  },
  {
    "label": "SVG",
    "id": "svg",
    "url": "/concepts/svg.html"
  },
  {
    "label": "svgbob",
    "id": "svgbob",
    "url": "/concepts/svgbob.html"
  },
  {
    "label": "SVL",
    "id": "svl",
    "url": "/concepts/svl.html"
  },
  {
    "label": "SW2",
    "id": "sw2",
    "url": "/concepts/sw2.html"
  },
  {
    "label": "Swagger",
    "id": "swagger",
    "url": "/concepts/swagger.html"
  },
  {
    "label": "Swallow",
    "id": "swallow",
    "url": "/concepts/swallow.html"
  },
  {
    "label": "Sweave",
    "id": "sweave",
    "url": "/concepts/sweave.html"
  },
  {
    "label": "Sweet Expressions",
    "id": "sweet-expressions",
    "url": "/concepts/sweet-expressions.html"
  },
  {
    "label": "Sweet.js",
    "id": "sweetjs",
    "url": "/concepts/sweetjs.html"
  },
  {
    "label": "SWI Prolog",
    "id": "swi-prolog",
    "url": "/concepts/swi-prolog.html"
  },
  {
    "label": "SIL",
    "id": "swift-il",
    "url": "/concepts/swift-il.html"
  },
  {
    "label": "Swift",
    "id": "swift",
    "url": "/concepts/swift.html"
  },
  {
    "label": "swizzle",
    "id": "swizzle",
    "url": "/concepts/swizzle.html"
  },
  {
    "label": "Semantic Web Rule Language",
    "id": "swrl",
    "url": "/concepts/swrl.html"
  },
  {
    "label": "Swym",
    "id": "swym",
    "url": "/concepts/swym.html"
  },
  {
    "label": "SYBYL line notation",
    "id": "sybyl-notation",
    "url": "/concepts/sybyl-notation.html"
  },
  {
    "label": "SYMBAL",
    "id": "symbal",
    "url": "/concepts/symbal.html"
  },
  {
    "label": "SymbMath",
    "id": "symbmath",
    "url": "/concepts/symbmath.html"
  },
  {
    "label": "SYMBOL",
    "id": "symbol",
    "url": "/concepts/symbol.html"
  },
  {
    "label": "SYMBOLIC ASSEMBLY",
    "id": "symbolic-assembly",
    "url": "/concepts/symbolic-assembly.html"
  },
  {
    "label": "SYMPL",
    "id": "sympl",
    "url": "/concepts/sympl.html"
  },
  {
    "label": "SymPy",
    "id": "sympy",
    "url": "/concepts/sympy.html"
  },
  {
    "label": "SYNAPSE",
    "id": "synapse",
    "url": "/concepts/synapse.html"
  },
  {
    "label": "SMIL",
    "id": "synchronized-multimedia-integration-language",
    "url": "/concepts/synchronized-multimedia-integration-language.html"
  },
  {
    "label": "syndicate",
    "id": "syndicate",
    "url": "/concepts/syndicate.html"
  },
  {
    "label": "synergist",
    "id": "synergist",
    "url": "/concepts/synergist.html"
  },
  {
    "label": "SYNGLISH",
    "id": "synglish",
    "url": "/concepts/synglish.html"
  },
  {
    "label": "Synon",
    "id": "synon",
    "url": "/concepts/synon.html"
  },
  {
    "label": "SYNPROC",
    "id": "synproc",
    "url": "/concepts/synproc.html"
  },
  {
    "label": "SYNTEX",
    "id": "syntex",
    "url": "/concepts/syntex.html"
  },
  {
    "label": "SYNTOL",
    "id": "syntol",
    "url": "/concepts/syntol.html"
  },
  {
    "label": "SysML",
    "id": "sysml",
    "url": "/concepts/sysml.html"
  },
  {
    "label": "System V ABI",
    "id": "system-v-abi",
    "url": "/concepts/system-v-abi.html"
  },
  {
    "label": "SystemVerilog",
    "id": "systemverilog",
    "url": "/concepts/systemverilog.html"
  },
  {
    "label": "IBM System z",
    "id": "systemz",
    "url": "/concepts/systemz.html"
  },
  {
    "label": "t-lang",
    "id": "t-lang",
    "url": "/concepts/t-lang.html"
  },
  {
    "label": "T",
    "id": "t",
    "url": "/concepts/t.html"
  },
  {
    "label": "t2b",
    "id": "t2b",
    "url": "/concepts/t2b.html"
  },
  {
    "label": "T3X",
    "id": "t3x",
    "url": "/concepts/t3x.html"
  },
  {
    "label": "tab",
    "id": "tab",
    "url": "/concepts/tab.html"
  },
  {
    "label": "tablam",
    "id": "tablam",
    "url": "/concepts/tablam.html"
  },
  {
    "label": "tablatal",
    "id": "tablatal",
    "url": "/concepts/tablatal.html"
  },
  {
    "label": "Tableau Software",
    "id": "tableau-app",
    "url": "/concepts/tableau-app.html"
  },
  {
    "label": "TABLOG",
    "id": "tablog",
    "url": "/concepts/tablog.html"
  },
  {
    "label": "Tabloid",
    "id": "tabloid",
    "url": "/concepts/tabloid.html"
  },
  {
    "label": "TABSOL",
    "id": "tabsol",
    "url": "/concepts/tabsol.html"
  },
  {
    "label": "TABTRAN",
    "id": "tabtran",
    "url": "/concepts/tabtran.html"
  },
  {
    "label": "TAC",
    "id": "tac",
    "url": "/concepts/tac.html"
  },
  {
    "label": "Tandem Advanced Command Language",
    "id": "tacl",
    "url": "/concepts/tacl.html"
  },
  {
    "label": "TACPOL",
    "id": "tacpol-programming-language",
    "url": "/concepts/tacpol-programming-language.html"
  },
  {
    "label": "TACTICS",
    "id": "tactics",
    "url": "/concepts/tactics.html"
  },
  {
    "label": "Text Adventure Development System",
    "id": "tads",
    "url": "/concepts/tads.html"
  },
  {
    "label": "taf",
    "id": "taf",
    "url": "/concepts/taf.html"
  },
  {
    "label": "Tahoe-LAFS",
    "id": "tahoe-lafs",
    "url": "/concepts/tahoe-lafs.html"
  },
  {
    "label": "Taichi",
    "id": "taichi",
    "url": "/concepts/taichi.html"
  },
  {
    "label": "Taijilang",
    "id": "taijilang",
    "url": "/concepts/taijilang.html"
  },
  {
    "label": "taktentus",
    "id": "taktentus",
    "url": "/concepts/taktentus.html"
  },
  {
    "label": "TAL",
    "id": "tal",
    "url": "/concepts/tal.html"
  },
  {
    "label": "TALE",
    "id": "tale",
    "url": "/concepts/tale.html"
  },
  {
    "label": "TALL",
    "id": "tall",
    "url": "/concepts/tall.html"
  },
  {
    "label": "tamgu",
    "id": "tamgu",
    "url": "/concepts/tamgu.html"
  },
  {
    "label": "tampio",
    "id": "tampio",
    "url": "/concepts/tampio.html"
  },
  {
    "label": "tangledown",
    "id": "tangledown",
    "url": "/concepts/tangledown.html"
  },
  {
    "label": "Tao",
    "id": "tao-lang",
    "url": "/concepts/tao-lang.html"
  },
  {
    "label": "TAO",
    "id": "tao",
    "url": "/concepts/tao.html"
  },
  {
    "label": "tao3d",
    "id": "tao3d",
    "url": "/concepts/tao3d.html"
  },
  {
    "label": "Tap code",
    "id": "tap-code",
    "url": "/concepts/tap-code.html"
  },
  {
    "label": "TAP",
    "id": "tap",
    "url": "/concepts/tap.html"
  },
  {
    "label": "Table Query Language",
    "id": "taql",
    "url": "/concepts/taql.html"
  },
  {
    "label": "Tarmac",
    "id": "tarmac",
    "url": "/concepts/tarmac.html"
  },
  {
    "label": "tarot",
    "id": "tarot",
    "url": "/concepts/tarot.html"
  },
  {
    "label": "TASM",
    "id": "tasm",
    "url": "/concepts/tasm.html"
  },
  {
    "label": "Tawa",
    "id": "tawa",
    "url": "/concepts/tawa.html"
  },
  {
    "label": "taxa",
    "id": "taxa",
    "url": "/concepts/taxa.html"
  },
  {
    "label": "Taxis",
    "id": "taxis",
    "url": "/concepts/taxis.html"
  },
  {
    "label": "tbox-lib",
    "id": "tbox-lib",
    "url": "/concepts/tbox-lib.html"
  },
  {
    "label": "tcc",
    "id": "tcc",
    "url": "/concepts/tcc.html"
  },
  {
    "label": "Tcl",
    "id": "tcl",
    "url": "/concepts/tcl.html"
  },
  {
    "label": "TCOZ",
    "id": "tcoz",
    "url": "/concepts/tcoz.html"
  },
  {
    "label": "TCP",
    "id": "tcp",
    "url": "/concepts/tcp.html"
  },
  {
    "label": "tcsh",
    "id": "tcsh",
    "url": "/concepts/tcsh.html"
  },
  {
    "label": "TCSP",
    "id": "tcsp",
    "url": "/concepts/tcsp.html"
  },
  {
    "label": "TDFL",
    "id": "tdfl",
    "url": "/concepts/tdfl.html"
  },
  {
    "label": "TDMS",
    "id": "tdms",
    "url": "/concepts/tdms.html"
  },
  {
    "label": "Tea",
    "id": "tea-pl",
    "url": "/concepts/tea-pl.html"
  },
  {
    "label": "tea",
    "id": "tea-pm",
    "url": "/concepts/tea-pm.html"
  },
  {
    "label": "Tea",
    "id": "tea",
    "url": "/concepts/tea.html"
  },
  {
    "label": "teal",
    "id": "teal",
    "url": "/concepts/teal.html"
  },
  {
    "label": "TeaSharp",
    "id": "teasharp",
    "url": "/concepts/teasharp.html"
  },
  {
    "label": "TECO",
    "id": "teco",
    "url": "/concepts/teco.html"
  },
  {
    "label": "Tefkat",
    "id": "tefkat",
    "url": "/concepts/tefkat.html"
  },
  {
    "label": "Tektronix 4050",
    "id": "tektronix",
    "url": "/concepts/tektronix.html"
  },
  {
    "label": "TeLa",
    "id": "tela",
    "url": "/concepts/tela.html"
  },
  {
    "label": "TELCOMP",
    "id": "telcomp",
    "url": "/concepts/telcomp.html"
  },
  {
    "label": "telefile-assembly",
    "id": "telefile-assembly",
    "url": "/concepts/telefile-assembly.html"
  },
  {
    "label": "Telnet",
    "id": "telnet-protocol",
    "url": "/concepts/telnet-protocol.html"
  },
  {
    "label": "TELOS",
    "id": "telos",
    "url": "/concepts/telos.html"
  },
  {
    "label": "TELSIM",
    "id": "telsim",
    "url": "/concepts/telsim.html"
  },
  {
    "label": "Templar",
    "id": "templar",
    "url": "/concepts/templar.html"
  },
  {
    "label": "Template Attribute Language",
    "id": "template-attribute-language",
    "url": "/concepts/template-attribute-language.html"
  },
  {
    "label": "TEMPO",
    "id": "tempo",
    "url": "/concepts/tempo.html"
  },
  {
    "label": "Temporal Prolog",
    "id": "temporal-prolog",
    "url": "/concepts/temporal-prolog.html"
  },
  {
    "label": "ten",
    "id": "ten",
    "url": "/concepts/ten.html"
  },
  {
    "label": "tengo",
    "id": "tengo",
    "url": "/concepts/tengo.html"
  },
  {
    "label": "TensorFlow",
    "id": "tensorflow",
    "url": "/concepts/tensorflow.html"
  },
  {
    "label": "Teradata Aster",
    "id": "teradata-aster",
    "url": "/concepts/teradata-aster.html"
  },
  {
    "label": "Teradata",
    "id": "teradata",
    "url": "/concepts/teradata.html"
  },
  {
    "label": "tern",
    "id": "tern",
    "url": "/concepts/tern.html"
  },
  {
    "label": "Ternary numeral system",
    "id": "ternary-notation",
    "url": "/concepts/ternary-notation.html"
  },
  {
    "label": "Terra",
    "id": "terra",
    "url": "/concepts/terra.html"
  },
  {
    "label": "terse",
    "id": "terse",
    "url": "/concepts/terse.html"
  },
  {
    "label": "tetra",
    "id": "tetra",
    "url": "/concepts/tetra.html"
  },
  {
    "label": "tetruss-app",
    "id": "tetruss-app",
    "url": "/concepts/tetruss-app.html"
  },
  {
    "label": "Tex",
    "id": "tex",
    "url": "/concepts/tex.html"
  },
  {
    "label": "texpr",
    "id": "texpr",
    "url": "/concepts/texpr.html"
  },
  {
    "label": "Text Executive Programming Language",
    "id": "text-executive-programming-language",
    "url": "/concepts/text-executive-programming-language.html"
  },
  {
    "label": "Textadept",
    "id": "textadept-editor",
    "url": "/concepts/textadept-editor.html"
  },
  {
    "label": "TextFrame",
    "id": "textframe",
    "url": "/concepts/textframe.html"
  },
  {
    "label": "texti",
    "id": "texti",
    "url": "/concepts/texti.html"
  },
  {
    "label": "Textile",
    "id": "textile",
    "url": "/concepts/textile.html"
  },
  {
    "label": "TextMate",
    "id": "textmate-editor",
    "url": "/concepts/textmate-editor.html"
  },
  {
    "label": "Texy!",
    "id": "texy",
    "url": "/concepts/texy.html"
  },
  {
    "label": "TFL",
    "id": "tfl",
    "url": "/concepts/tfl.html"
  },
  {
    "label": "The Message System",
    "id": "the-message-system",
    "url": "/concepts/the-message-system.html"
  },
  {
    "label": "THEOS",
    "id": "theos-multi-user-basic",
    "url": "/concepts/theos-multi-user-basic.html"
  },
  {
    "label": "ThinBasic",
    "id": "thinbasic",
    "url": "/concepts/thinbasic.html"
  },
  {
    "label": "ThingLab",
    "id": "thinglab",
    "url": "/concepts/thinglab.html"
  },
  {
    "label": "THINK C",
    "id": "think-c",
    "url": "/concepts/think-c.html"
  },
  {
    "label": "thorn",
    "id": "thorn",
    "url": "/concepts/thorn.html"
  },
  {
    "label": "THREADED LISTS",
    "id": "threaded-lists",
    "url": "/concepts/threaded-lists.html"
  },
  {
    "label": "Thrift",
    "id": "thrift",
    "url": "/concepts/thrift.html"
  },
  {
    "label": "tht",
    "id": "tht",
    "url": "/concepts/tht.html"
  },
  {
    "label": "Thue",
    "id": "thue-programming-language",
    "url": "/concepts/thue-programming-language.html"
  },
  {
    "label": "thune",
    "id": "thune",
    "url": "/concepts/thune.html"
  },
  {
    "label": "Thymeleaf",
    "id": "thymeleaf",
    "url": "/concepts/thymeleaf.html"
  },
  {
    "label": "TI-89 series",
    "id": "ti-89-basic",
    "url": "/concepts/ti-89-basic.html"
  },
  {
    "label": "TI Program",
    "id": "ti-basic-assembly",
    "url": "/concepts/ti-basic-assembly.html"
  },
  {
    "label": "TI-BASIC",
    "id": "ti-basic",
    "url": "/concepts/ti-basic.html"
  },
  {
    "label": "Tibbo BASIC",
    "id": "tibbo-basic",
    "url": "/concepts/tibbo-basic.html"
  },
  {
    "label": "tibet",
    "id": "tibet",
    "url": "/concepts/tibet.html"
  },
  {
    "label": "Tick C",
    "id": "tick-c",
    "url": "/concepts/tick-c.html"
  },
  {
    "label": "TICS",
    "id": "tics",
    "url": "/concepts/tics.html"
  },
  {
    "label": "TiDB",
    "id": "tidb",
    "url": "/concepts/tidb.html"
  },
  {
    "label": "tiddler",
    "id": "tiddler",
    "url": "/concepts/tiddler.html"
  },
  {
    "label": "TiddlyWiki",
    "id": "tiddlywiki",
    "url": "/concepts/tiddlywiki.html"
  },
  {
    "label": "tidyverse",
    "id": "tidyverse",
    "url": "/concepts/tidyverse.html"
  },
  {
    "label": "Tagged Image File Format",
    "id": "tiff-format",
    "url": "/concepts/tiff-format.html"
  },
  {
    "label": "Tiger-BASIC",
    "id": "tiger-basic",
    "url": "/concepts/tiger-basic.html"
  },
  {
    "label": "Tiki Wiki Markup",
    "id": "tikiwiki",
    "url": "/concepts/tikiwiki.html"
  },
  {
    "label": "tiledb",
    "id": "tiledb",
    "url": "/concepts/tiledb.html"
  },
  {
    "label": "tilton",
    "id": "tilton",
    "url": "/concepts/tilton.html"
  },
  {
    "label": "Timber",
    "id": "timber-programming-language",
    "url": "/concepts/timber-programming-language.html"
  },
  {
    "label": "Timed CSP",
    "id": "timed-csp",
    "url": "/concepts/timed-csp.html"
  },
  {
    "label": "Timpani",
    "id": "timpani",
    "url": "/concepts/timpani.html"
  },
  {
    "label": "Tinkertoy",
    "id": "tinkertoy",
    "url": "/concepts/tinkertoy.html"
  },
  {
    "label": "Tiny BASIC",
    "id": "tiny-basic",
    "url": "/concepts/tiny-basic.html"
  },
  {
    "label": "Tiny C Compiler",
    "id": "tinyc-compiler",
    "url": "/concepts/tinyc-compiler.html"
  },
  {
    "label": "tinygo-compiler",
    "id": "tinygo-compiler",
    "url": "/concepts/tinygo-compiler.html"
  },
  {
    "label": "TIScript",
    "id": "tiscript",
    "url": "/concepts/tiscript.html"
  },
  {
    "label": "titan",
    "id": "titan",
    "url": "/concepts/titan.html"
  },
  {
    "label": "Titanium",
    "id": "titanium",
    "url": "/concepts/titanium.html"
  },
  {
    "label": "Timeless Instruction Set (TL ISA)",
    "id": "tl-isa",
    "url": "/concepts/tl-isa.html"
  },
  {
    "label": "Typed Lua",
    "id": "tl",
    "url": "/concepts/tl.html"
  },
  {
    "label": "TLA",
    "id": "tla",
    "url": "/concepts/tla.html"
  },
  {
    "label": "Tag Line Commands",
    "id": "tlc",
    "url": "/concepts/tlc.html"
  },
  {
    "label": "tldr",
    "id": "tldr",
    "url": "/concepts/tldr.html"
  },
  {
    "label": "TLS",
    "id": "tls",
    "url": "/concepts/tls.html"
  },
  {
    "label": "TMG",
    "id": "tmg",
    "url": "/concepts/tmg.html"
  },
  {
    "label": "TextMate Language",
    "id": "tmlanguage",
    "url": "/concepts/tmlanguage.html"
  },
  {
    "label": "TMTP",
    "id": "tmtp",
    "url": "/concepts/tmtp.html"
  },
  {
    "label": "toadskin",
    "id": "toadskin",
    "url": "/concepts/toadskin.html"
  },
  {
    "label": "Todotxt",
    "id": "todotxt",
    "url": "/concepts/todotxt.html"
  },
  {
    "label": "ToffeeScript",
    "id": "toffeescript",
    "url": "/concepts/toffeescript.html"
  },
  {
    "label": "Toi",
    "id": "toi",
    "url": "/concepts/toi.html"
  },
  {
    "label": "toki sona",
    "id": "toki-sona",
    "url": "/concepts/toki-sona.html"
  },
  {
    "label": "TOM object-oriented",
    "id": "tom-oopl",
    "url": "/concepts/tom-oopl.html"
  },
  {
    "label": "TOM",
    "id": "tom",
    "url": "/concepts/tom.html"
  },
  {
    "label": "TOMAL",
    "id": "tomal",
    "url": "/concepts/tomal.html"
  },
  {
    "label": "TOML",
    "id": "toml",
    "url": "/concepts/toml.html"
  },
  {
    "label": "TOOLBUS",
    "id": "toolbus",
    "url": "/concepts/toolbus.html"
  },
  {
    "label": "ToonTalk",
    "id": "toontalk",
    "url": "/concepts/toontalk.html"
  },
  {
    "label": "Topaz",
    "id": "topaz-lang",
    "url": "/concepts/topaz-lang.html"
  },
  {
    "label": "topaz",
    "id": "topaz",
    "url": "/concepts/topaz.html"
  },
  {
    "label": "topshell",
    "id": "topshell",
    "url": "/concepts/topshell.html"
  },
  {
    "label": "torchscript",
    "id": "torchscript",
    "url": "/concepts/torchscript.html"
  },
  {
    "label": "tornado",
    "id": "tornado",
    "url": "/concepts/tornado.html"
  },
  {
    "label": "Tosh",
    "id": "tosh",
    "url": "/concepts/tosh.html"
  },
  {
    "label": "Touch",
    "id": "touch",
    "url": "/concepts/touch.html"
  },
  {
    "label": "TouchDevelop",
    "id": "touchdevelop",
    "url": "/concepts/touchdevelop.html"
  },
  {
    "label": "Toy",
    "id": "toy-lang",
    "url": "/concepts/toy-lang.html"
  },
  {
    "label": "TPDL*",
    "id": "tpdl-star",
    "url": "/concepts/tpdl-star.html"
  },
  {
    "label": "TQL",
    "id": "tql",
    "url": "/concepts/tql.html"
  },
  {
    "label": "TRAC",
    "id": "trac",
    "url": "/concepts/trac.html"
  },
  {
    "label": "TRACE",
    "id": "trace",
    "url": "/concepts/trace.html"
  },
  {
    "label": "Trafola-H",
    "id": "trafola-h",
    "url": "/concepts/trafola-h.html"
  },
  {
    "label": "Traits",
    "id": "traits",
    "url": "/concepts/traits.html"
  },
  {
    "label": "TRAMP",
    "id": "tramp",
    "url": "/concepts/tramp.html"
  },
  {
    "label": "TRANQUIL",
    "id": "tranquil",
    "url": "/concepts/tranquil.html"
  },
  {
    "label": "Transact-SQL",
    "id": "transact-sql",
    "url": "/concepts/transact-sql.html"
  },
  {
    "label": "Transaction Language 1",
    "id": "transaction-language-1",
    "url": "/concepts/transaction-language-1.html"
  },
  {
    "label": "TRANSCODE",
    "id": "transcode",
    "url": "/concepts/transcode.html"
  },
  {
    "label": "Transforma",
    "id": "transforma",
    "url": "/concepts/transforma.html"
  },
  {
    "label": "TRANSLANG",
    "id": "translang",
    "url": "/concepts/translang.html"
  },
  {
    "label": "TAO",
    "id": "tree-annotation-operator",
    "url": "/concepts/tree-annotation-operator.html"
  },
  {
    "label": "Treelang",
    "id": "treelang",
    "url": "/concepts/treelang.html"
  },
  {
    "label": "Tree Notation",
    "id": "treenotation",
    "url": "/concepts/treenotation.html"
  },
  {
    "label": "TreeSheets",
    "id": "treesheets",
    "url": "/concepts/treesheets.html"
  },
  {
    "label": "TREET",
    "id": "treet",
    "url": "/concepts/treet.html"
  },
  {
    "label": "Trellis",
    "id": "trellis",
    "url": "/concepts/trellis.html"
  },
  {
    "label": "tremor-query",
    "id": "tremor-query",
    "url": "/concepts/tremor-query.html"
  },
  {
    "label": "Trex",
    "id": "trex",
    "url": "/concepts/trex.html"
  },
  {
    "label": "tridash",
    "id": "tridash",
    "url": "/concepts/tridash.html"
  },
  {
    "label": "TriG syntax",
    "id": "trig-syntax",
    "url": "/concepts/trig-syntax.html"
  },
  {
    "label": "TRIO",
    "id": "trio",
    "url": "/concepts/trio.html"
  },
  {
    "label": "TRIPLE",
    "id": "triple",
    "url": "/concepts/triple.html"
  },
  {
    "label": "triroff",
    "id": "triroff",
    "url": "/concepts/triroff.html"
  },
  {
    "label": "Triton",
    "id": "triton",
    "url": "/concepts/triton.html"
  },
  {
    "label": "Troff",
    "id": "troff",
    "url": "/concepts/troff.html"
  },
  {
    "label": "Lambda Diagrams",
    "id": "tromp-diagrams",
    "url": "/concepts/tromp-diagrams.html"
  },
  {
    "label": "TRS-80 Color Computer",
    "id": "trs-80-color-computer",
    "url": "/concepts/trs-80-color-computer.html"
  },
  {
    "label": "truck",
    "id": "truck",
    "url": "/concepts/truck.html"
  },
  {
    "label": "True BASIC",
    "id": "true-basic",
    "url": "/concepts/true-basic.html"
  },
  {
    "label": "Truth",
    "id": "truth",
    "url": "/concepts/truth.html"
  },
  {
    "label": "TS",
    "id": "ts",
    "url": "/concepts/ts.html"
  },
  {
    "label": "tsar",
    "id": "tsar",
    "url": "/concepts/tsar.html"
  },
  {
    "label": "TScript",
    "id": "tscript",
    "url": "/concepts/tscript.html"
  },
  {
    "label": "TSL",
    "id": "tsl",
    "url": "/concepts/tsl.html"
  },
  {
    "label": "TSQL2",
    "id": "tsql2",
    "url": "/concepts/tsql2.html"
  },
  {
    "label": "tsquery",
    "id": "tsquery",
    "url": "/concepts/tsquery.html"
  },
  {
    "label": "TSV",
    "id": "tsv",
    "url": "/concepts/tsv.html"
  },
  {
    "label": "Tree and Tabular Combined Notation",
    "id": "ttcn",
    "url": "/concepts/ttcn.html"
  },
  {
    "label": "TTM",
    "id": "ttm",
    "url": "/concepts/ttm.html"
  },
  {
    "label": "ttsneo",
    "id": "ttsneo",
    "url": "/concepts/ttsneo.html"
  },
  {
    "label": "Tuple space",
    "id": "tuple-space",
    "url": "/concepts/tuple-space.html"
  },
  {
    "label": "tuplemarkup",
    "id": "tuplemarkup",
    "url": "/concepts/tuplemarkup.html"
  },
  {
    "label": "Turbo Assembler",
    "id": "turbo-assembler",
    "url": "/concepts/turbo-assembler.html"
  },
  {
    "label": "Turbo-Basic XL",
    "id": "turbo-basic-xl",
    "url": "/concepts/turbo-basic-xl.html"
  },
  {
    "label": "Turbo Basic",
    "id": "turbo-basic",
    "url": "/concepts/turbo-basic.html"
  },
  {
    "label": "Turbo Pascal",
    "id": "turbo-pascal",
    "url": "/concepts/turbo-pascal.html"
  },
  {
    "label": "Turing Plus",
    "id": "turing-plus",
    "url": "/concepts/turing-plus.html"
  },
  {
    "label": "Turing",
    "id": "turing",
    "url": "/concepts/turing.html"
  },
  {
    "label": "turnstile-plus",
    "id": "turnstile-plus",
    "url": "/concepts/turnstile-plus.html"
  },
  {
    "label": "turnstile",
    "id": "turnstile",
    "url": "/concepts/turnstile.html"
  },
  {
    "label": "Turtle",
    "id": "turtle",
    "url": "/concepts/turtle.html"
  },
  {
    "label": "TUTOR",
    "id": "tutor",
    "url": "/concepts/tutor.html"
  },
  {
    "label": "Tutorial D",
    "id": "tutorial-d",
    "url": "/concepts/tutorial-d.html"
  },
  {
    "label": "Twelf",
    "id": "twelf",
    "url": "/concepts/twelf.html"
  },
  {
    "label": "Twig",
    "id": "twig",
    "url": "/concepts/twig.html"
  },
  {
    "label": "TWiki",
    "id": "twiki",
    "url": "/concepts/twiki.html"
  },
  {
    "label": "TWO-D",
    "id": "two-d",
    "url": "/concepts/two-d.html"
  },
  {
    "label": "twoducks",
    "id": "twoducks",
    "url": "/concepts/twoducks.html"
  },
  {
    "label": "TXL",
    "id": "txl",
    "url": "/concepts/txl.html"
  },
  {
    "label": "txr",
    "id": "txr",
    "url": "/concepts/txr.html"
  },
  {
    "label": "Txt2tags",
    "id": "txt2tags",
    "url": "/concepts/txt2tags.html"
  },
  {
    "label": "txtzyme",
    "id": "txtzyme",
    "url": "/concepts/txtzyme.html"
  },
  {
    "label": "Tyco",
    "id": "tyco",
    "url": "/concepts/tyco.html"
  },
  {
    "label": "Tymshare SuperBasic",
    "id": "tymshare-superbasic",
    "url": "/concepts/tymshare-superbasic.html"
  },
  {
    "label": "Tynker",
    "id": "tynker",
    "url": "/concepts/tynker.html"
  },
  {
    "label": "Type Language",
    "id": "type-language",
    "url": "/concepts/type-language.html"
  },
  {
    "label": "Typecast.js",
    "id": "typecastjs",
    "url": "/concepts/typecastjs.html"
  },
  {
    "label": "typecobol",
    "id": "typecobol",
    "url": "/concepts/typecobol.html"
  },
  {
    "label": "typedefs",
    "id": "typedefs",
    "url": "/concepts/typedefs.html"
  },
  {
    "label": "TypeScript",
    "id": "typescript",
    "url": "/concepts/typescript.html"
  },
  {
    "label": "Typographical Number Theory",
    "id": "typographical-number-theory",
    "url": "/concepts/typographical-number-theory.html"
  },
  {
    "label": "Typoscript",
    "id": "typoscript",
    "url": "/concepts/typoscript.html"
  },
  {
    "label": "Typst",
    "id": "typst",
    "url": "/concepts/typst.html"
  },
  {
    "label": "TyRuBa",
    "id": "tyruba",
    "url": "/concepts/tyruba.html"
  },
  {
    "label": "U-Datalog",
    "id": "u-datalog",
    "url": "/concepts/u-datalog.html"
  },
  {
    "label": "U",
    "id": "u",
    "url": "/concepts/u.html"
  },
  {
    "label": "UAN",
    "id": "uan",
    "url": "/concepts/uan.html"
  },
  {
    "label": "UBASIC",
    "id": "ubasic",
    "url": "/concepts/ubasic.html"
  },
  {
    "label": "Ubercode",
    "id": "ubercode",
    "url": "/concepts/ubercode.html"
  },
  {
    "label": "UberScript",
    "id": "uberscript",
    "url": "/concepts/uberscript.html"
  },
  {
    "label": "Ubik",
    "id": "ubik",
    "url": "/concepts/ubik.html"
  },
  {
    "label": "UBJSON",
    "id": "ubjson",
    "url": "/concepts/ubjson.html"
  },
  {
    "label": "UC",
    "id": "uc",
    "url": "/concepts/uc.html"
  },
  {
    "label": "UCG",
    "id": "ucg",
    "url": "/concepts/ucg.html"
  },
  {
    "label": "UCL",
    "id": "ucl",
    "url": "/concepts/ucl.html"
  },
  {
    "label": "UCSD Pascal",
    "id": "ucsd-pascal",
    "url": "/concepts/ucsd-pascal.html"
  },
  {
    "label": "UDP",
    "id": "udp",
    "url": "/concepts/udp.html"
  },
  {
    "label": "UFL",
    "id": "ufl",
    "url": "/concepts/ufl.html"
  },
  {
    "label": "UFO",
    "id": "ufo",
    "url": "/concepts/ufo.html"
  },
  {
    "label": "ugBASIC",
    "id": "ugbasic",
    "url": "/concepts/ugbasic.html"
  },
  {
    "label": "ugnis",
    "id": "ugnis",
    "url": "/concepts/ugnis.html"
  },
  {
    "label": "UIML",
    "id": "uiml",
    "url": "/concepts/uiml.html"
  },
  {
    "id": "uiua",
    "url": "/concepts/uiua.html"
  },
  {
    "label": "UJML",
    "id": "ujml",
    "url": "/concepts/ujml.html"
  },
  {
    "label": "ulisp",
    "id": "ulisp",
    "url": "/concepts/ulisp.html"
  },
  {
    "label": "ultralisp-pm",
    "id": "ultralisp-pm",
    "url": "/concepts/ultralisp-pm.html"
  },
  {
    "label": "Umka",
    "id": "umka",
    "url": "/concepts/umka.html"
  },
  {
    "label": "UML",
    "id": "uml",
    "url": "/concepts/uml.html"
  },
  {
    "label": "uml2-sp",
    "id": "uml2-sp",
    "url": "/concepts/uml2-sp.html"
  },
  {
    "label": "Umple",
    "id": "umple",
    "url": "/concepts/umple.html"
  },
  {
    "label": "UMTA",
    "id": "umta",
    "url": "/concepts/umta.html"
  },
  {
    "label": "UNCOL",
    "id": "uncol",
    "url": "/concepts/uncol.html"
  },
  {
    "label": "underlay",
    "id": "underlay",
    "url": "/concepts/underlay.html"
  },
  {
    "label": "Unicode",
    "id": "unicode-lang",
    "url": "/concepts/unicode-lang.html"
  },
  {
    "label": "Unicode",
    "id": "unicode",
    "url": "/concepts/unicode.html"
  },
  {
    "label": "unicon-adl",
    "id": "unicon-adl",
    "url": "/concepts/unicon-adl.html"
  },
  {
    "label": "Unicon",
    "id": "unicon",
    "url": "/concepts/unicon.html"
  },
  {
    "label": "UNICORN",
    "id": "unicorn",
    "url": "/concepts/unicorn.html"
  },
  {
    "label": "Uniface",
    "id": "uniface",
    "url": "/concepts/uniface.html"
  },
  {
    "label": "Unified Diff",
    "id": "unified-diff",
    "url": "/concepts/unified-diff.html"
  },
  {
    "label": "UPC",
    "id": "unified-parallel-c",
    "url": "/concepts/unified-parallel-c.html"
  },
  {
    "label": "UNISIM",
    "id": "unisim",
    "url": "/concepts/unisim.html"
  },
  {
    "label": "unison",
    "id": "unison",
    "url": "/concepts/unison.html"
  },
  {
    "label": "Unity",
    "id": "unity-engine",
    "url": "/concepts/unity-engine.html"
  },
  {
    "label": "UNITY",
    "id": "unity",
    "url": "/concepts/unity.html"
  },
  {
    "label": "Unity3D Asset",
    "id": "unity3d-asset",
    "url": "/concepts/unity3d-asset.html"
  },
  {
    "label": "UniVerse",
    "id": "universe",
    "url": "/concepts/universe.html"
  },
  {
    "label": "Unix",
    "id": "unix",
    "url": "/concepts/unix.html"
  },
  {
    "label": "UNLAMBDA",
    "id": "unlambda",
    "url": "/concepts/unlambda.html"
  },
  {
    "label": "unlws",
    "id": "unlws",
    "url": "/concepts/unlws.html"
  },
  {
    "label": "Uno",
    "id": "uno",
    "url": "/concepts/uno.html"
  },
  {
    "label": "UnQL",
    "id": "unql-lang",
    "url": "/concepts/unql-lang.html"
  },
  {
    "label": "UnQL",
    "id": "unql",
    "url": "/concepts/unql.html"
  },
  {
    "label": "UNRAVEL",
    "id": "unravel",
    "url": "/concepts/unravel.html"
  },
  {
    "label": "UnrealScript",
    "id": "unrealscript",
    "url": "/concepts/unrealscript.html"
  },
  {
    "label": "unseemly",
    "id": "unseemly",
    "url": "/concepts/unseemly.html"
  },
  {
    "label": "Up-arrow notation",
    "id": "up-arrow-notation",
    "url": "/concepts/up-arrow-notation.html"
  },
  {
    "label": "UPIC",
    "id": "upic",
    "url": "/concepts/upic.html"
  },
  {
    "label": "Urbiscript",
    "id": "urbiscript",
    "url": "/concepts/urbiscript.html"
  },
  {
    "label": "URL",
    "id": "url",
    "url": "/concepts/url.html"
  },
  {
    "label": "urn",
    "id": "urn",
    "url": "/concepts/urn.html"
  },
  {
    "label": "UrWeb",
    "id": "urweb",
    "url": "/concepts/urweb.html"
  },
  {
    "label": "USB",
    "id": "usb-standard",
    "url": "/concepts/usb-standard.html"
  },
  {
    "label": "uscript",
    "id": "uscript",
    "url": "/concepts/uscript.html"
  },
  {
    "label": "uscript2",
    "id": "uscript2",
    "url": "/concepts/uscript2.html"
  },
  {
    "label": "USD",
    "id": "usd",
    "url": "/concepts/usd.html"
  },
  {
    "label": "USSA",
    "id": "ussa",
    "url": "/concepts/ussa.html"
  },
  {
    "label": "UTC",
    "id": "utc-format",
    "url": "/concepts/utc-format.html"
  },
  {
    "label": "UTF-8",
    "id": "utf-8",
    "url": "/concepts/utf-8.html"
  },
  {
    "label": "Utopia 84",
    "id": "utopia-84",
    "url": "/concepts/utopia-84.html"
  },
  {
    "label": "Uniform eXchange Format",
    "id": "uxf",
    "url": "/concepts/uxf.html"
  },
  {
    "label": "V",
    "id": "v-golf",
    "url": "/concepts/v-golf.html"
  },
  {
    "label": "V-Promela",
    "id": "v-promela",
    "url": "/concepts/v-promela.html"
  },
  {
    "label": "V",
    "id": "v-visual-language",
    "url": "/concepts/v-visual-language.html"
  },
  {
    "label": "V",
    "id": "v",
    "url": "/concepts/v.html"
  },
  {
    "label": "v8",
    "id": "v8",
    "url": "/concepts/v8.html"
  },
  {
    "label": "v8torque",
    "id": "v8torque",
    "url": "/concepts/v8torque.html"
  },
  {
    "label": "VAL II",
    "id": "val-ii",
    "url": "/concepts/val-ii.html"
  },
  {
    "label": "VAL",
    "id": "val",
    "url": "/concepts/val.html"
  },
  {
    "label": "Vala",
    "id": "vala",
    "url": "/concepts/vala.html"
  },
  {
    "label": "Vale",
    "id": "vale-assembly",
    "url": "/concepts/vale-assembly.html"
  },
  {
    "label": "Vale",
    "id": "vale",
    "url": "/concepts/vale.html"
  },
  {
    "label": "VARLIST",
    "id": "varlist",
    "url": "/concepts/varlist.html"
  },
  {
    "label": "VBA",
    "id": "vba",
    "url": "/concepts/vba.html"
  },
  {
    "label": "VBScript",
    "id": "vbscript",
    "url": "/concepts/vbscript.html"
  },
  {
    "label": "vCard",
    "id": "vcard",
    "url": "/concepts/vcard.html"
  },
  {
    "label": "VCF",
    "id": "vcf-format",
    "url": "/concepts/vcf-format.html"
  },
  {
    "label": "Varnish Configuration Language",
    "id": "vcl",
    "url": "/concepts/vcl.html"
  },
  {
    "label": "Vcpkg",
    "id": "vcpkg-pm",
    "url": "/concepts/vcpkg-pm.html"
  },
  {
    "label": "Vienna Development Method Specification Language",
    "id": "vdm-sl",
    "url": "/concepts/vdm-sl.html"
  },
  {
    "label": "vdscript",
    "id": "vdscript",
    "url": "/concepts/vdscript.html"
  },
  {
    "label": "Vector PASCAL",
    "id": "vector-pascal",
    "url": "/concepts/vector-pascal.html"
  },
  {
    "label": "vega-editor-app",
    "id": "vega-editor-app",
    "url": "/concepts/vega-editor-app.html"
  },
  {
    "label": "Velato",
    "id": "velato",
    "url": "/concepts/velato.html"
  },
  {
    "label": "Vely",
    "id": "vely",
    "url": "/concepts/vely.html"
  },
  {
    "label": "VENUS",
    "id": "venus",
    "url": "/concepts/venus.html"
  },
  {
    "label": "verifpal",
    "id": "verifpal",
    "url": "/concepts/verifpal.html"
  },
  {
    "label": "Verilog",
    "id": "verilog",
    "url": "/concepts/verilog.html"
  },
  {
    "label": "verona",
    "id": "verona",
    "url": "/concepts/verona.html"
  },
  {
    "label": "Verse",
    "id": "verse",
    "url": "/concepts/verse.html"
  },
  {
    "label": "versioned-text-markup-language",
    "id": "versioned-text-markup-language",
    "url": "/concepts/versioned-text-markup-language.html"
  },
  {
    "label": "verve",
    "id": "verve",
    "url": "/concepts/verve.html"
  },
  {
    "label": "VEX",
    "id": "vex",
    "url": "/concepts/vex.html"
  },
  {
    "label": "Video Graphics Array",
    "id": "vga-standard",
    "url": "/concepts/vga-standard.html"
  },
  {
    "label": "VHDL-AMS",
    "id": "vhdl-ams",
    "url": "/concepts/vhdl-ams.html"
  },
  {
    "label": "VHDL",
    "id": "vhdl",
    "url": "/concepts/vhdl.html"
  },
  {
    "label": "vi",
    "id": "vi-editor",
    "url": "/concepts/vi-editor.html"
  },
  {
    "label": "video",
    "id": "video",
    "url": "/concepts/video.html"
  },
  {
    "label": "Vienna Definition Language",
    "id": "vienna-definition-language",
    "url": "/concepts/vienna-definition-language.html"
  },
  {
    "label": "Vienna Fortran",
    "id": "vienna-fortran",
    "url": "/concepts/vienna-fortran.html"
  },
  {
    "label": "Vigil",
    "id": "vigil",
    "url": "/concepts/vigil.html"
  },
  {
    "label": "Vilnius BASIC",
    "id": "vilnius-basic",
    "url": "/concepts/vilnius-basic.html"
  },
  {
    "label": "Vim",
    "id": "vim-editor",
    "url": "/concepts/vim-editor.html"
  },
  {
    "label": "Vim script",
    "id": "vim-script",
    "url": "/concepts/vim-script.html"
  },
  {
    "label": "Vim Scripts",
    "id": "vim-scripts-pm",
    "url": "/concepts/vim-scripts-pm.html"
  },
  {
    "label": "Vimwiki",
    "id": "vimwiki",
    "url": "/concepts/vimwiki.html"
  },
  {
    "label": "Violent ES",
    "id": "violent-es",
    "url": "/concepts/violent-es.html"
  },
  {
    "label": "VIPTRAN",
    "id": "viptran",
    "url": "/concepts/viptran.html"
  },
  {
    "label": "Virgil",
    "id": "virgil",
    "url": "/concepts/virgil.html"
  },
  {
    "label": "Viron",
    "id": "viron",
    "url": "/concepts/viron.html"
  },
  {
    "label": "Virt",
    "id": "virt",
    "url": "/concepts/virt.html"
  },
  {
    "label": "VisaVis",
    "id": "visavis",
    "url": "/concepts/visavis.html"
  },
  {
    "label": "visdown",
    "id": "visdown",
    "url": "/concepts/visdown.html"
  },
  {
    "label": "VisSim",
    "id": "vissim",
    "url": "/concepts/vissim.html"
  },
  {
    "label": "Visual Basic .NET",
    "id": "visual-basic.net",
    "url": "/concepts/visual-basic.net.html"
  },
  {
    "label": "Visual Basic",
    "id": "visual-basic",
    "url": "/concepts/visual-basic.html"
  },
  {
    "label": "Visual DataFlex",
    "id": "visual-dataflex",
    "url": "/concepts/visual-dataflex.html"
  },
  {
    "label": "Visual DialogScript",
    "id": "visual-dialogscript",
    "url": "/concepts/visual-dialogscript.html"
  },
  {
    "label": "Visual Eiffel",
    "id": "visual-eiffel",
    "url": "/concepts/visual-eiffel.html"
  },
  {
    "label": "Visual FoxPro",
    "id": "visual-foxpro",
    "url": "/concepts/visual-foxpro.html"
  },
  {
    "label": "Visual Logic",
    "id": "visual-logic",
    "url": "/concepts/visual-logic.html"
  },
  {
    "label": "Visual Objects",
    "id": "visual-objects",
    "url": "/concepts/visual-objects.html"
  },
  {
    "label": "Visual Occam",
    "id": "visual-occam",
    "url": "/concepts/visual-occam.html"
  },
  {
    "label": "Visual Paradigm",
    "id": "visual-paradigm-app",
    "url": "/concepts/visual-paradigm-app.html"
  },
  {
    "label": "Visual Prolog",
    "id": "visual-prolog",
    "url": "/concepts/visual-prolog.html"
  },
  {
    "label": "Visual Smalltalk Enterprise",
    "id": "visual-smalltalk-enterprise",
    "url": "/concepts/visual-smalltalk-enterprise.html"
  },
  {
    "label": "Visual Studio Code",
    "id": "visual-studio-code-editor",
    "url": "/concepts/visual-studio-code-editor.html"
  },
  {
    "label": "Visual Studio",
    "id": "visual-studio-editor",
    "url": "/concepts/visual-studio-editor.html"
  },
  {
    "label": "Visual Studio Marketplace",
    "id": "visual-studio-marketplace-pm",
    "url": "/concepts/visual-studio-marketplace-pm.html"
  },
  {
    "label": "Visual Test",
    "id": "visual-test",
    "url": "/concepts/visual-test.html"
  },
  {
    "label": "Visual",
    "id": "visual",
    "url": "/concepts/visual.html"
  },
  {
    "label": "VisualWorks",
    "id": "visualworks",
    "url": "/concepts/visualworks.html"
  },
  {
    "label": "VIVA",
    "id": "viva",
    "url": "/concepts/viva.html"
  },
  {
    "label": "vivaldi",
    "id": "vivaldi",
    "url": "/concepts/vivaldi.html"
  },
  {
    "label": "viz",
    "id": "viz",
    "url": "/concepts/viz.html"
  },
  {
    "label": "VlibTemplate",
    "id": "vlibtemplate",
    "url": "/concepts/vlibtemplate.html"
  },
  {
    "label": "VML",
    "id": "vml",
    "url": "/concepts/vml.html"
  },
  {
    "label": "Volt",
    "id": "volt",
    "url": "/concepts/volt.html"
  },
  {
    "label": "Vortex",
    "id": "vortex",
    "url": "/concepts/vortex.html"
  },
  {
    "label": "VoxML",
    "id": "voxml",
    "url": "/concepts/voxml.html"
  },
  {
    "label": "VPL",
    "id": "vpl",
    "url": "/concepts/vpl.html"
  },
  {
    "label": "VRML",
    "id": "vrml",
    "url": "/concepts/vrml.html"
  },
  {
    "label": "VSPL",
    "id": "vspl",
    "url": "/concepts/vspl.html"
  },
  {
    "label": "VSXu",
    "id": "vsxu",
    "url": "/concepts/vsxu.html"
  },
  {
    "label": "Velocity Template Language",
    "id": "vtl-lang",
    "url": "/concepts/vtl-lang.html"
  },
  {
    "label": "Very Tiny Language",
    "id": "vtl",
    "url": "/concepts/vtl.html"
  },
  {
    "label": "Visual Tool Markup Language",
    "id": "vtml",
    "url": "/concepts/vtml.html"
  },
  {
    "label": "Vue",
    "id": "vuejs",
    "url": "/concepts/vuejs.html"
  },
  {
    "label": "VULCAN",
    "id": "vulcan",
    "url": "/concepts/vulcan.html"
  },
  {
    "label": "Vvvv",
    "id": "vvvv",
    "url": "/concepts/vvvv.html"
  },
  {
    "label": "vyper",
    "id": "vyper",
    "url": "/concepts/vyper.html"
  },
  {
    "label": "Vyxal",
    "id": "vyxal",
    "url": "/concepts/vyxal.html"
  },
  {
    "label": "w",
    "id": "w",
    "url": "/concepts/w.html"
  },
  {
    "label": "wah",
    "id": "wah",
    "url": "/concepts/wah.html"
  },
  {
    "label": "walt",
    "id": "walt",
    "url": "/concepts/walt.html"
  },
  {
    "label": "Wart",
    "id": "wart",
    "url": "/concepts/wart.html"
  },
  {
    "label": "WebAssembly",
    "id": "wasm",
    "url": "/concepts/wasm.html"
  },
  {
    "label": "wasmer",
    "id": "wasmer",
    "url": "/concepts/wasmer.html"
  },
  {
    "label": "Wasp",
    "id": "wasp-lang",
    "url": "/concepts/wasp-lang.html"
  },
  {
    "label": "WebAssembly Text Format",
    "id": "wast",
    "url": "/concepts/wast.html"
  },
  {
    "label": "WATBOL",
    "id": "watbol",
    "url": "/concepts/watbol.html"
  },
  {
    "label": "Watcom",
    "id": "watcom",
    "url": "/concepts/watcom.html"
  },
  {
    "label": "Water",
    "id": "water",
    "url": "/concepts/water.html"
  },
  {
    "label": "WATFIV",
    "id": "watfiv",
    "url": "/concepts/watfiv.html"
  },
  {
    "label": "WATFOR",
    "id": "watfor",
    "url": "/concepts/watfor.html"
  },
  {
    "label": "wats",
    "id": "wats",
    "url": "/concepts/wats.html"
  },
  {
    "label": "Wavefront Material",
    "id": "wavefront-material",
    "url": "/concepts/wavefront-material.html"
  },
  {
    "label": "Wavefront Object",
    "id": "wavefront-object",
    "url": "/concepts/wavefront-object.html"
  },
  {
    "label": "WCL",
    "id": "wcl",
    "url": "/concepts/wcl.html"
  },
  {
    "label": "WCPS",
    "id": "wcps",
    "url": "/concepts/wcps.html"
  },
  {
    "label": "WDDX",
    "id": "wddx",
    "url": "/concepts/wddx.html"
  },
  {
    "label": "Wolfram Data Framework",
    "id": "wdf",
    "url": "/concepts/wdf.html"
  },
  {
    "label": "WDL",
    "id": "wdl",
    "url": "/concepts/wdl.html"
  },
  {
    "label": "WebIDL",
    "id": "web-idl",
    "url": "/concepts/web-idl.html"
  },
  {
    "label": "WebDNA",
    "id": "webdna",
    "url": "/concepts/webdna.html"
  },
  {
    "label": "WebGL",
    "id": "webgl",
    "url": "/concepts/webgl.html"
  },
  {
    "label": "WebKit",
    "id": "webkit",
    "url": "/concepts/webkit.html"
  },
  {
    "label": "WebL",
    "id": "webl",
    "url": "/concepts/webl.html"
  },
  {
    "label": "WebP",
    "id": "webp-format",
    "url": "/concepts/webp-format.html"
  },
  {
    "label": "webql",
    "id": "webql",
    "url": "/concepts/webql.html"
  },
  {
    "label": "WebStorm",
    "id": "webstorm-editor",
    "url": "/concepts/webstorm-editor.html"
  },
  {
    "label": "weebasic",
    "id": "weebasic",
    "url": "/concepts/weebasic.html"
  },
  {
    "label": "wescheme",
    "id": "wescheme",
    "url": "/concepts/wescheme.html"
  },
  {
    "label": "WebGPU Shading Language",
    "id": "wgsl",
    "url": "/concepts/wgsl.html"
  },
  {
    "label": "whack",
    "id": "whack",
    "url": "/concepts/whack.html"
  },
  {
    "label": "whalecalf",
    "id": "whalecalf",
    "url": "/concepts/whalecalf.html"
  },
  {
    "label": "Whiley",
    "id": "whiley",
    "url": "/concepts/whiley.html"
  },
  {
    "label": "WHIRL",
    "id": "whirl",
    "url": "/concepts/whirl.html"
  },
  {
    "label": "Whirlwind",
    "id": "whirlwind",
    "url": "/concepts/whirlwind.html"
  },
  {
    "label": "Whitespace",
    "id": "whitespace",
    "url": "/concepts/whitespace.html"
  },
  {
    "label": "WHOIS",
    "id": "whois-protocol",
    "url": "/concepts/whois-protocol.html"
  },
  {
    "label": "Wikitax",
    "id": "wikitax",
    "url": "/concepts/wikitax.html"
  },
  {
    "label": "Winbatch",
    "id": "winbatch",
    "url": "/concepts/winbatch.html"
  },
  {
    "label": "WinDev",
    "id": "windev",
    "url": "/concepts/windev.html"
  },
  {
    "label": "Windows Registry Entries",
    "id": "windows-registry-entries",
    "url": "/concepts/windows-registry-entries.html"
  },
  {
    "label": "Wing",
    "id": "wing",
    "url": "/concepts/wing.html"
  },
  {
    "label": "WinWrap Basic",
    "id": "winwrap-basic",
    "url": "/concepts/winwrap-basic.html"
  },
  {
    "label": "winxed",
    "id": "winxed",
    "url": "/concepts/winxed.html"
  },
  {
    "label": "WML",
    "id": "wireless-markup-language",
    "url": "/concepts/wireless-markup-language.html"
  },
  {
    "label": "Wirth syntax notation",
    "id": "wirth-syntax-notation",
    "url": "/concepts/wirth-syntax-notation.html"
  },
  {
    "label": "wisp",
    "id": "wisp",
    "url": "/concepts/wisp.html"
  },
  {
    "label": "Wiswesser line notation",
    "id": "wiswesser-line-notation",
    "url": "/concepts/wiswesser-line-notation.html"
  },
  {
    "label": "wizml",
    "id": "wizml",
    "url": "/concepts/wizml.html"
  },
  {
    "label": "WIZOR",
    "id": "wizor",
    "url": "/concepts/wizor.html"
  },
  {
    "label": "WLambda",
    "id": "wlambda",
    "url": "/concepts/wlambda.html"
  },
  {
    "label": "Wlanguage",
    "id": "wlanguage",
    "url": "/concepts/wlanguage.html"
  },
  {
    "label": "WML",
    "id": "wml",
    "url": "/concepts/wml.html"
  },
  {
    "label": "WMLScript",
    "id": "wmlscript",
    "url": "/concepts/wmlscript.html"
  },
  {
    "label": "woe",
    "id": "woe",
    "url": "/concepts/woe.html"
  },
  {
    "label": "WOL",
    "id": "wol",
    "url": "/concepts/wol.html"
  },
  {
    "label": "Wolfram Language",
    "id": "wolfram",
    "url": "/concepts/wolfram.html"
  },
  {
    "label": "Wolontis-Bell Interpreter",
    "id": "wolontis-bell-interpreter",
    "url": "/concepts/wolontis-bell-interpreter.html"
  },
  {
    "label": "Wonkey",
    "id": "wonkey",
    "url": "/concepts/wonkey.html"
  },
  {
    "label": "woofjs",
    "id": "woofjs",
    "url": "/concepts/woofjs.html"
  },
  {
    "label": "WordPress",
    "id": "wordpress",
    "url": "/concepts/wordpress.html"
  },
  {
    "label": "WFL",
    "id": "work-flow-language",
    "url": "/concepts/work-flow-language.html"
  },
  {
    "label": "Workfl",
    "id": "workfl",
    "url": "/concepts/workfl.html"
  },
  {
    "label": "World of Warcraft Addon Data",
    "id": "world-of-warcraft-addon-data",
    "url": "/concepts/world-of-warcraft-addon-data.html"
  },
  {
    "label": "world",
    "id": "world",
    "url": "/concepts/world.html"
  },
  {
    "label": "Worst",
    "id": "worst",
    "url": "/concepts/worst.html"
  },
  {
    "label": "Wren",
    "id": "wren",
    "url": "/concepts/wren.html"
  },
  {
    "label": "WRITEACOURSE",
    "id": "writeacourse",
    "url": "/concepts/writeacourse.html"
  },
  {
    "label": "WSDL",
    "id": "wsdl",
    "url": "/concepts/wsdl.html"
  },
  {
    "label": "WSFN",
    "id": "wsfn-programming-language",
    "url": "/concepts/wsfn-programming-language.html"
  },
  {
    "label": "Wu",
    "id": "wu",
    "url": "/concepts/wu.html"
  },
  {
    "label": "WxBasic",
    "id": "wxbasic",
    "url": "/concepts/wxbasic.html"
  },
  {
    "label": "WYLBUR",
    "id": "wylbur",
    "url": "/concepts/wylbur.html"
  },
  {
    "label": "Wyvern",
    "id": "wyvern",
    "url": "/concepts/wyvern.html"
  },
  {
    "label": "X-BASIC",
    "id": "x-basic",
    "url": "/concepts/x-basic.html"
  },
  {
    "label": "X BitMap",
    "id": "x-bitmap-format",
    "url": "/concepts/x-bitmap-format.html"
  },
  {
    "label": "X BitMap",
    "id": "x-bitmap",
    "url": "/concepts/x-bitmap.html"
  },
  {
    "label": "X Font Directory Index",
    "id": "x-font-directory-index",
    "url": "/concepts/x-font-directory-index.html"
  },
  {
    "label": "[x]it!",
    "id": "x-it",
    "url": "/concepts/x-it.html"
  },
  {
    "label": "X-KLAIM",
    "id": "x-klaim",
    "url": "/concepts/x-klaim.html"
  },
  {
    "label": "X PixMap",
    "id": "x-pixmap",
    "url": "/concepts/x-pixmap.html"
  },
  {
    "label": "X10",
    "id": "x10",
    "url": "/concepts/x10.html"
  },
  {
    "label": "X11-Basic",
    "id": "x11-basic",
    "url": "/concepts/x11-basic.html"
  },
  {
    "label": "x86-64",
    "id": "x86-64-isa",
    "url": "/concepts/x86-64-isa.html"
  },
  {
    "label": "x86 Assembly",
    "id": "x86-assembly",
    "url": "/concepts/x86-assembly.html"
  },
  {
    "label": "X86",
    "id": "x86-isa",
    "url": "/concepts/x86-isa.html"
  },
  {
    "label": "xADL",
    "id": "xadl",
    "url": "/concepts/xadl.html"
  },
  {
    "label": "XAML",
    "id": "xaml",
    "url": "/concepts/xaml.html"
  },
  {
    "label": "xBase",
    "id": "xbase",
    "url": "/concepts/xbase.html"
  },
  {
    "label": "XBase++",
    "id": "xbasepp",
    "url": "/concepts/xbasepp.html"
  },
  {
    "label": "Xbasic",
    "id": "xbasic",
    "url": "/concepts/xbasic.html"
  },
  {
    "label": "XBEL",
    "id": "xbel",
    "url": "/concepts/xbel.html"
  },
  {
    "label": "XML Binding Language",
    "id": "xbl",
    "url": "/concepts/xbl.html"
  },
  {
    "label": "XBLite",
    "id": "xblite",
    "url": "/concepts/xblite.html"
  },
  {
    "label": "XBRL",
    "id": "xbrl",
    "url": "/concepts/xbrl.html"
  },
  {
    "label": "XC",
    "id": "xc",
    "url": "/concepts/xc.html"
  },
  {
    "label": "xCard",
    "id": "xcard",
    "url": "/concepts/xcard.html"
  },
  {
    "label": "XCAS",
    "id": "xcas",
    "url": "/concepts/xcas.html"
  },
  {
    "label": "XCompose",
    "id": "xcompose",
    "url": "/concepts/xcompose.html"
  },
  {
    "label": "XCore Architecture",
    "id": "xcore",
    "url": "/concepts/xcore.html"
  },
  {
    "label": "XCY",
    "id": "xcy",
    "url": "/concepts/xcy.html"
  },
  {
    "label": "XDR Schema",
    "id": "xdr",
    "url": "/concepts/xdr.html"
  },
  {
    "label": "xduce",
    "id": "xduce",
    "url": "/concepts/xduce.html"
  },
  {
    "label": "XE",
    "id": "xe",
    "url": "/concepts/xe.html"
  },
  {
    "label": "XeTeX",
    "id": "xetex",
    "url": "/concepts/xetex.html"
  },
  {
    "label": "Xgboost",
    "id": "xgboost-model",
    "url": "/concepts/xgboost-model.html"
  },
  {
    "label": "XGBoost",
    "id": "xgboost",
    "url": "/concepts/xgboost.html"
  },
  {
    "label": "XGMML",
    "id": "xgmml",
    "url": "/concepts/xgmml.html"
  },
  {
    "label": "XHTML",
    "id": "xhtml",
    "url": "/concepts/xhtml.html"
  },
  {
    "label": "Xidoc",
    "id": "xidoc",
    "url": "/concepts/xidoc.html"
  },
  {
    "label": "XL",
    "id": "xl-lang",
    "url": "/concepts/xl-lang.html"
  },
  {
    "label": "xl",
    "id": "xl",
    "url": "/concepts/xl.html"
  },
  {
    "label": "xlwings-editor",
    "id": "xlwings-editor",
    "url": "/concepts/xlwings-editor.html"
  },
  {
    "label": "XML Metadata Interchange",
    "id": "xmi",
    "url": "/concepts/xmi.html"
  },
  {
    "label": "Xmind Format",
    "id": "xmind",
    "url": "/concepts/xmind.html"
  },
  {
    "label": "XML-GL",
    "id": "xml-gl",
    "url": "/concepts/xml-gl.html"
  },
  {
    "label": "XML Query Language",
    "id": "xml-ql",
    "url": "/concepts/xml-ql.html"
  },
  {
    "label": "The Algebra",
    "id": "xml-query-algebra",
    "url": "/concepts/xml-query-algebra.html"
  },
  {
    "label": "XML",
    "id": "xml",
    "url": "/concepts/xml.html"
  },
  {
    "label": "xmpp-protocol",
    "id": "xmpp-protocol",
    "url": "/concepts/xmpp-protocol.html"
  },
  {
    "label": "XMTC",
    "id": "xmtc",
    "url": "/concepts/xmtc.html"
  },
  {
    "label": "Xoc",
    "id": "xoc-compiler",
    "url": "/concepts/xoc-compiler.html"
  },
  {
    "label": "xodio",
    "id": "xodio",
    "url": "/concepts/xodio.html"
  },
  {
    "label": "Xojo",
    "id": "xojo",
    "url": "/concepts/xojo.html"
  },
  {
    "label": "XOTcl",
    "id": "xotcl",
    "url": "/concepts/xotcl.html"
  },
  {
    "label": "XPages",
    "id": "xpages",
    "url": "/concepts/xpages.html"
  },
  {
    "label": "XPath",
    "id": "xpath",
    "url": "/concepts/xpath.html"
  },
  {
    "label": "XPL",
    "id": "xpl",
    "url": "/concepts/xpl.html"
  },
  {
    "label": "XPL0",
    "id": "xpl0",
    "url": "/concepts/xpl0.html"
  },
  {
    "label": "X PixMap",
    "id": "xpm-format",
    "url": "/concepts/xpm-format.html"
  },
  {
    "label": "XPOP",
    "id": "xpop",
    "url": "/concepts/xpop.html"
  },
  {
    "label": "XProc",
    "id": "xproc",
    "url": "/concepts/xproc.html"
  },
  {
    "label": "XProfan",
    "id": "xprofan",
    "url": "/concepts/xprofan.html"
  },
  {
    "label": "XQL",
    "id": "xql-lang",
    "url": "/concepts/xql-lang.html"
  },
  {
    "label": "XQL",
    "id": "xql",
    "url": "/concepts/xql.html"
  },
  {
    "label": "XQuery",
    "id": "xquery",
    "url": "/concepts/xquery.html"
  },
  {
    "label": "xs",
    "id": "xs-lang",
    "url": "/concepts/xs-lang.html"
  },
  {
    "label": "XS",
    "id": "xs",
    "url": "/concepts/xs.html"
  },
  {
    "label": "XSD",
    "id": "xsd",
    "url": "/concepts/xsd.html"
  },
  {
    "label": "xsharp",
    "id": "xsharp",
    "url": "/concepts/xsharp.html"
  },
  {
    "label": "XSIM",
    "id": "xsim",
    "url": "/concepts/xsim.html"
  },
  {
    "label": "XSLT",
    "id": "xslt",
    "url": "/concepts/xslt.html"
  },
  {
    "label": "xsv-app",
    "id": "xsv-app",
    "url": "/concepts/xsv-app.html"
  },
  {
    "label": "xt3d",
    "id": "xt3d",
    "url": "/concepts/xt3d.html"
  },
  {
    "label": "xTAO Modeling Language",
    "id": "xtao",
    "url": "/concepts/xtao.html"
  },
  {
    "label": "Ecstasy",
    "id": "xtclang",
    "url": "/concepts/xtclang.html"
  },
  {
    "label": "Xtend",
    "id": "xtend",
    "url": "/concepts/xtend.html"
  },
  {
    "label": "Xtext",
    "id": "xtext",
    "url": "/concepts/xtext.html"
  },
  {
    "label": "XTRAN",
    "id": "xtran",
    "url": "/concepts/xtran.html"
  },
  {
    "label": "XUML",
    "id": "xuml",
    "url": "/concepts/xuml.html"
  },
  {
    "label": "Xupdate",
    "id": "xupdate",
    "url": "/concepts/xupdate.html"
  },
  {
    "label": "xxl",
    "id": "xxl",
    "url": "/concepts/xxl.html"
  },
  {
    "label": "y-lang",
    "id": "y-lang",
    "url": "/concepts/y-lang.html"
  },
  {
    "label": "Y",
    "id": "y",
    "url": "/concepts/y.html"
  },
  {
    "label": "Yabasic",
    "id": "yabasic",
    "url": "/concepts/yabasic.html"
  },
  {
    "label": "Yacas",
    "id": "yacas",
    "url": "/concepts/yacas.html"
  },
  {
    "label": "Yacc",
    "id": "yacc",
    "url": "/concepts/yacc.html"
  },
  {
    "label": "Yakou Lang",
    "id": "yakou-lang",
    "url": "/concepts/yakou-lang.html"
  },
  {
    "label": "YAML",
    "id": "yaml",
    "url": "/concepts/yaml.html"
  },
  {
    "label": "YAMP",
    "id": "yamp",
    "url": "/concepts/yamp.html"
  },
  {
    "label": "YANG",
    "id": "yang",
    "url": "/concepts/yang.html"
  },
  {
    "label": "YAP",
    "id": "yap-prolog",
    "url": "/concepts/yap-prolog.html"
  },
  {
    "label": "YARA",
    "id": "yara",
    "url": "/concepts/yara.html"
  },
  {
    "label": "YARV",
    "id": "yarv",
    "url": "/concepts/yarv.html"
  },
  {
    "label": "Yet Another Scripting Language",
    "id": "yasl",
    "url": "/concepts/yasl.html"
  },
  {
    "label": "YASnippet",
    "id": "yasnippet",
    "url": "/concepts/yasnippet.html"
  },
  {
    "label": "YAWL",
    "id": "yawl",
    "url": "/concepts/yawl.html"
  },
  {
    "label": "ycp",
    "id": "ycp",
    "url": "/concepts/ycp.html"
  },
  {
    "label": "Yedalog",
    "id": "yedalog",
    "url": "/concepts/yedalog.html"
  },
  {
    "label": "YESS",
    "id": "yess",
    "url": "/concepts/yess.html"
  },
  {
    "label": "yeti",
    "id": "yeti",
    "url": "/concepts/yeti.html"
  },
  {
    "label": "Yes It Is",
    "id": "yii",
    "url": "/concepts/yii.html"
  },
  {
    "label": "yinyang",
    "id": "yinyang",
    "url": "/concepts/yinyang.html"
  },
  {
    "label": "yoga",
    "id": "yoga",
    "url": "/concepts/yoga.html"
  },
  {
    "label": "Yoix",
    "id": "yoix",
    "url": "/concepts/yoix.html"
  },
  {
    "label": "YoptaScript",
    "id": "yoptascript",
    "url": "/concepts/yoptascript.html"
  },
  {
    "label": "Yorick",
    "id": "yorick",
    "url": "/concepts/yorick.html"
  },
  {
    "label": "YugabyteDB",
    "id": "yugabytedb",
    "url": "/concepts/yugabytedb.html"
  },
  {
    "label": "Yum",
    "id": "yum-pm",
    "url": "/concepts/yum-pm.html"
  },
  {
    "label": "Z",
    "id": "z-expressions",
    "url": "/concepts/z-expressions.html"
  },
  {
    "label": "Z-flat",
    "id": "z-flat",
    "url": "/concepts/z-flat.html"
  },
  {
    "label": "Z-machine",
    "id": "z-machine",
    "url": "/concepts/z-machine.html"
  },
  {
    "label": "Z notation",
    "id": "z-notation",
    "url": "/concepts/z-notation.html"
  },
  {
    "label": "Z shell",
    "id": "z-shell",
    "url": "/concepts/z-shell.html"
  },
  {
    "label": "Z",
    "id": "z",
    "url": "/concepts/z.html"
  },
  {
    "label": "z2",
    "id": "z2",
    "url": "/concepts/z2.html"
  },
  {
    "label": "z80",
    "id": "z80",
    "url": "/concepts/z80.html"
  },
  {
    "label": "ZBasic",
    "id": "zbasic",
    "url": "/concepts/zbasic.html"
  },
  {
    "label": "ZCCS",
    "id": "zccs",
    "url": "/concepts/zccs.html"
  },
  {
    "label": "Zed",
    "id": "zed",
    "url": "/concepts/zed.html"
  },
  {
    "label": "Zeek",
    "id": "zeek",
    "url": "/concepts/zeek.html"
  },
  {
    "label": "ZENO",
    "id": "zeno",
    "url": "/concepts/zeno.html"
  },
  {
    "label": "zenscript",
    "id": "zenscript",
    "url": "/concepts/zenscript.html"
  },
  {
    "label": "Zephir",
    "id": "zephir",
    "url": "/concepts/zephir.html"
  },
  {
    "label": "zephyr-asdl",
    "id": "zephyr-asdl",
    "url": "/concepts/zephyr-asdl.html"
  },
  {
    "label": "Zeta",
    "id": "zeta",
    "url": "/concepts/zeta.html"
  },
  {
    "label": "ZGRASS",
    "id": "zgrass",
    "url": "/concepts/zgrass.html"
  },
  {
    "label": "Zig",
    "id": "zig",
    "url": "/concepts/zig.html"
  },
  {
    "label": "ZigZag",
    "id": "zigzag",
    "url": "/concepts/zigzag.html"
  },
  {
    "label": "Zork Implementation Language",
    "id": "zil",
    "url": "/concepts/zil.html"
  },
  {
    "label": "ZIM Format",
    "id": "zim-format",
    "url": "/concepts/zim-format.html"
  },
  {
    "label": "Zimbu",
    "id": "zimbu",
    "url": "/concepts/zimbu.html"
  },
  {
    "label": "Zimpl",
    "id": "zimpl",
    "url": "/concepts/zimpl.html"
  },
  {
    "label": "Zip file format",
    "id": "zip-format",
    "url": "/concepts/zip-format.html"
  },
  {
    "label": "zish",
    "id": "zish",
    "url": "/concepts/zish.html"
  },
  {
    "label": "zl",
    "id": "zl",
    "url": "/concepts/zl.html"
  },
  {
    "label": "zlang",
    "id": "zlang",
    "url": "/concepts/zlang.html"
  },
  {
    "label": "Zoem",
    "id": "zoem",
    "url": "/concepts/zoem.html"
  },
  {
    "label": "zolang",
    "id": "zolang",
    "url": "/concepts/zolang.html"
  },
  {
    "label": "DNS Zone",
    "id": "zone",
    "url": "/concepts/zone.html"
  },
  {
    "label": "Zonnon",
    "id": "zonnon",
    "url": "/concepts/zonnon.html"
  },
  {
    "label": "Zope",
    "id": "zope",
    "url": "/concepts/zope.html"
  },
  {
    "label": "ZOPL",
    "id": "zopl",
    "url": "/concepts/zopl.html"
  },
  {
    "label": "Zot",
    "id": "zot",
    "url": "/concepts/zot.html"
  },
  {
    "label": "ZPL",
    "id": "zpl",
    "url": "/concepts/zpl.html"
  },
  {
    "label": "Z++",
    "id": "zpp",
    "url": "/concepts/zpp.html"
  },
  {
    "label": "Zuo",
    "id": "zuo",
    "url": "/concepts/zuo.html"
  },
  {
    "label": "zz",
    "id": "zz",
    "url": "/concepts/zz.html"
  }
]

class Timer {
  constructor() {
    this._tickTime = Date.now() - (Utils.isNodeJs() ? 1000 * process.uptime() : 0)
    this._firstTickTime = this._tickTime
  }
  tick(msg) {
    const elapsed = Date.now() - this._tickTime
    if (msg) console.log(`${elapsed}ms ${msg}`)
    this._tickTime = Date.now()
    return elapsed
  }
  getTotalElapsedTime() {
    return Date.now() - this._firstTickTime
  }
}
class Utils {
  static getFileExtension(filepath = "") {
    const match = filepath.match(/\.([^\.]+)$/)
    return (match && match[1]) || ""
  }
  static ensureFolderEndsInSlash(folder) {
    return folder.replace(/\/$/, "") + "/"
  }
  static runCommand(instance, command = "", param = undefined) {
    const run = name => {
      console.log(`Running ${name}:`)
      instance[name](param)
    }
    if (instance[command + "Command"]) return run(command + "Command")
    // Get commands from both the child and parent classes
    const classes = [Object.getPrototypeOf(instance), Object.getPrototypeOf(Object.getPrototypeOf(instance))]
    const allCommands = classes.map(classInstance => Object.getOwnPropertyNames(classInstance).filter(word => word.endsWith("Command"))).flat()
    allCommands.sort()
    const commandAsNumber = parseInt(command) - 1
    if (command.match(/^\d+$/) && allCommands[commandAsNumber]) return run(allCommands[commandAsNumber])
    console.log(`\n❌ No command provided. Available commands:\n\n` + allCommands.map((name, index) => `${index + 1}. ${name.replace("Command", "")}`).join("\n") + "\n")
  }
  static removeReturnChars(str = "") {
    return str.replace(/\r/g, "")
  }
  static isAbsoluteUrl(url) {
    return url.startsWith("https://") || url.startsWith("http://")
  }
  static removeEmptyLines(str = "") {
    return str.replace(/\n\n+/g, "\n")
  }
  static shiftRight(str = "", numSpaces = 1) {
    let spaces = " ".repeat(numSpaces)
    return str.replace(/\n/g, `\n${spaces}`)
  }
  static getLinks(str = "") {
    const _re = new RegExp("(^|[ \t\r\n])((ftp|http|https):(([A-Za-z0-9$_.+!*(),;/?:@&~=-])|%[A-Fa-f0-9]{2}){2,}(#([a-zA-Z0-9][a-zA-Z0-9$_.+!*(),;/?:@&~=%-]*))?([A-Za-z0-9$_+!*();/?:~-]))", "g")
    return str.match(_re) || []
  }
  // Only allow text content and inline styling. Don't allow HTML tags or any nested scroll tags or escape characters.
  static escapeScrollAndHtml(content = "") {
    return content.replace(/</g, "&lt;").replace(/\n/g, "").replace(/\r/g, "").replace(/\\/g, "")
  }
  static colorize(message, colorNameOrString = "red") {
    // ANSI: https://en.wikipedia.org/wiki/ANSI_escape_code
    const colors = { red: "\x1b[31m", green: "\x1b[32m", yellow: "\x1b[33m" }
    const color = colors[colorNameOrString] || colorNameOrString
    const reset = "\x1b[0m"
    return `${color}${message}${reset}`
  }
  static ensureDelimiterNotFound(strings, delimiter) {
    const hit = strings.find(word => word.includes(delimiter))
    if (hit) throw `Delimiter "${delimiter}" found in hit`
  }
  // https://github.com/rigoneri/indefinite-article.js/blob/master/indefinite-article.js
  static getIndefiniteArticle(phrase) {
    // Getting the first word
    const match = /\w+/.exec(phrase)
    let word
    if (match) word = match[0]
    else return "an"
    var l_word = word.toLowerCase()
    // Specific start of words that should be preceded by 'an'
    var alt_cases = ["honest", "hour", "hono"]
    for (var i in alt_cases) {
      if (l_word.indexOf(alt_cases[i]) == 0) return "an"
    }
    // Single letter word which should be preceded by 'an'
    if (l_word.length == 1) {
      if ("aedhilmnorsx".indexOf(l_word) >= 0) return "an"
      else return "a"
    }
    // Capital words which should likely be preceded by 'an'
    if (word.match(/(?!FJO|[HLMNS]Y.|RY[EO]|SQU|(F[LR]?|[HL]|MN?|N|RH?|S[CHKLMNPTVW]?|X(YL)?)[AEIOU])[FHLMNRSX][A-Z]/)) {
      return "an"
    }
    // Special cases where a word that begins with a vowel should be preceded by 'a'
    const regexes = [/^e[uw]/, /^onc?e\b/, /^uni([^nmd]|mo)/, /^u[bcfhjkqrst][aeiou]/]
    for (var i in regexes) {
      if (l_word.match(regexes[i])) return "a"
    }
    // Special capital words (UK, UN)
    if (word.match(/^U[NK][AIEO]/)) {
      return "a"
    } else if (word == word.toUpperCase()) {
      if ("aedhilmnorsx".indexOf(l_word[0]) >= 0) return "an"
      else return "a"
    }
    // Basic method of words that begin with a vowel being preceded by 'an'
    if ("aeiou".indexOf(l_word[0]) >= 0) return "an"
    // Instances where y follwed by specific letters is preceded by 'an'
    if (l_word.match(/^y(b[lor]|cl[ea]|fere|gg|p[ios]|rou|tt)/)) return "an"
    return "a"
  }
  static htmlEscaped(content = "") {
    return content.replace(/</g, "&lt;")
  }
  static isValidEmail(email = "") {
    return email.toLowerCase().match(/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/)
  }
  static capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }
  // generate a random alpha numeric hash:
  static getRandomCharacters(length) {
    const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    let result = ""
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * characters.length))
    }
    return result
  }
  static isNodeJs() {
    return typeof exports !== "undefined"
  }
  static findProjectRoot(startingDirName, projectName) {
    const fs = require("fs")
    const getProjectName = dirName => {
      if (!dirName) throw new Error(`dirName undefined when attempting to findProjectRoot for project "${projectName}" starting in "${startingDirName}"`)
      const parts = dirName.split("/")
      const filename = parts.join("/") + "/" + "package.json"
      if (fs.existsSync(filename) && JSON.parse(fs.readFileSync(filename, "utf8")).name === projectName) return parts.join("/") + "/"
      parts.pop()
      return parts
    }
    let result = getProjectName(startingDirName)
    while (typeof result !== "string" && result.length > 0) {
      result = getProjectName(result.join("/"))
    }
    if (result.length === 0) throw new Error(`Project root "${projectName}" in folder ${startingDirName} not found.`)
    return result
  }
  static titleToPermalink(str) {
    return str
      .replace(/[\/\_\:\\\[\]]/g, "-")
      .replace(/π/g, "pi")
      .replace(/`/g, "tick")
      .replace(/\$/g, "dollar-sign")
      .replace(/\*$/g, "-star")
      .replace(/^\*/g, "star-")
      .replace(/\*/g, "-star-")
      .replace(/\'+$/g, "q")
      .replace(/^@/g, "at-")
      .replace(/@$/g, "-at")
      .replace(/@/g, "-at-")
      .replace(/[\'\"\,\ū]/g, "")
      .replace(/^\#/g, "sharp-")
      .replace(/\#$/g, "-sharp")
      .replace(/\#/g, "-sharp-")
      .replace(/[\(\)]/g, "")
      .replace(/\+\+$/g, "pp")
      .replace(/\+$/g, "p")
      .replace(/^\!/g, "bang-")
      .replace(/\!$/g, "-bang")
      .replace(/\!/g, "-bang-")
      .replace(/\&/g, "-n-")
      .replace(/[\+ ]/g, "-")
      .replace(/[^a-zA-Z0-9\-\.]/g, "")
      .toLowerCase()
  }
  static escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
  }
  static sum(arr) {
    return arr.reduce((curr, next) => curr + next, 0)
  }
  static makeVector(length, fill = 0) {
    return new Array(length).fill(fill)
  }
  static makeMatrix(cols, rows, fill = 0) {
    const matrix = []
    while (rows) {
      matrix.push(Utils.makeVector(cols, fill))
      rows--
    }
    return matrix
  }
  static removeNonAscii(str) {
    // https://stackoverflow.com/questions/20856197/remove-non-ascii-character-in-string
    return str.replace(/[^\x00-\x7F]/g, "")
  }
  static getMethodFromDotPath(context, str) {
    const methodParts = str.split(".")
    while (methodParts.length > 1) {
      const methodName = methodParts.shift()
      if (!context[methodName]) throw new Error(`${methodName} is not a method on ${context}`)
      context = context[methodName]()
    }
    const final = methodParts.shift()
    return [context, final]
  }
  static requireAbsOrRelative(filePath, contextFilePath) {
    if (!filePath.startsWith(".")) return require(filePath)
    const path = require("path")
    const folder = this.getPathWithoutFileName(contextFilePath)
    const file = path.resolve(folder + "/" + filePath)
    return require(file)
  }
  // Removes last ".*" from this string
  static removeFileExtension(filename) {
    return filename ? filename.replace(/\.[^\.]+$/, "") : ""
  }
  static getFileName(path) {
    const normalizedPath = path.replace(/\\/g, "/")
    const parts = normalizedPath.split("/")
    return parts.pop()
  }
  static getPathWithoutFileName(path) {
    const normalizedPath = path.replace(/\\/g, "/")
    const parts = normalizedPath.split("/")
    parts.pop()
    return parts.join("/")
  }
  static shuffleInPlace(arr, seed = Date.now()) {
    // https://stackoverflow.com/questions/6274339/how-can-i-shuffle-an-array
    const randFn = Utils._getPseudoRandom0to1FloatGenerator(seed)
    for (let index = arr.length - 1; index > 0; index--) {
      const tempIndex = Math.floor(randFn() * (index + 1))
      ;[arr[index], arr[tempIndex]] = [arr[tempIndex], arr[index]]
    }
    return arr
  }
  // Only allows a-zA-Z0-9-_  (And optionally .)
  static _permalink(str, reg) {
    return str.length ? str.toLowerCase().replace(reg, "").replace(/ /g, "-") : ""
  }
  static isValueEmpty(value) {
    return value === undefined || value === "" || (typeof value === "number" && isNaN(value)) || (value instanceof Date && isNaN(value))
  }
  static stringToPermalink(str) {
    return this._permalink(str, /[^a-z0-9- _\.]/gi)
  }
  static getAvailablePermalink(permalink, doesFileExistSyncFn) {
    const extension = this.getFileExtension(permalink)
    permalink = this.removeFileExtension(permalink)
    const originalPermalink = permalink
    let num = 2
    let suffix = ""
    let filename = `${originalPermalink}${suffix}.${extension}`
    while (doesFileExistSyncFn(filename)) {
      filename = `${originalPermalink}${suffix}.${extension}`
      suffix = "-" + num
      num++
    }
    return filename
  }
  static getNextOrPrevious(arr, item) {
    const length = arr.length
    const index = arr.indexOf(item)
    if (length === 1) return undefined
    if (index === length - 1) return arr[index - 1]
    return arr[index + 1]
  }
  static toggle(currentValue, values) {
    const index = values.indexOf(currentValue)
    return index === -1 || index + 1 === values.length ? values[0] : values[index + 1]
  }
  static getClassNameFromFilePath(filepath) {
    return this.removeFileExtension(this.getFileName(filepath))
  }
  static joinArraysOn(joinOn, arrays, columns) {
    const rows = {}
    let index = 0
    if (!columns) columns = arrays.map(arr => Object.keys(arr[0]))
    arrays.forEach((arr, index) => {
      const cols = columns[index]
      arr.forEach(row => {
        const key = joinOn ? row[joinOn] : index++
        if (!rows[key]) rows[key] = {}
        const obj = rows[key]
        cols.forEach(col => (obj[col] = row[col]))
      })
    })
    return Object.values(rows)
  }
  static getParentFolder(path) {
    if (path.endsWith("/")) path = this._removeLastSlash(path)
    return path.replace(/\/[^\/]*$/, "") + "/"
  }
  static _removeLastSlash(path) {
    return path.replace(/\/$/, "")
  }
  static _listToEnglishText(list, limit = 5) {
    const len = list.length
    if (!len) return ""
    if (len === 1) return `'${list[0]}'`
    const clone = list.slice(0, limit).map(item => `'${item}'`)
    const last = clone.pop()
    if (len <= limit) return clone.join(", ") + ` and ${last}`
    return clone.join(", ") + ` and ${len - limit} more`
  }
  // todo: refactor so instead of str input takes an array of cells(strings) and scans each indepndently.
  static _chooseDelimiter(str) {
    const del = " ,|\t;^%$!#@~*&+-=_:?.{}[]()<>/".split("").find(idea => !str.includes(idea))
    if (!del) throw new Error("Could not find a delimiter")
    return del
  }
  static flatten(arr) {
    if (arr.flat) return arr.flat()
    return arr.reduce((acc, val) => acc.concat(val), [])
  }
  static escapeBackTicks(str) {
    return str.replace(/\`/g, "\\`").replace(/\$\{/g, "\\${")
  }
  static ucfirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }
  // Adapted from: https://github.com/dcporter/didyoumean.js/blob/master/didYouMean-1.2.1.js
  static didYouMean(str = "", options = [], caseSensitive = false, threshold = 0.4, thresholdAbsolute = 20) {
    if (!caseSensitive) str = str.toLowerCase()
    // Calculate the initial value (the threshold) if present.
    const thresholdRelative = threshold * str.length
    let maximumEditDistanceToBeBestMatch
    if (thresholdRelative !== null && thresholdAbsolute !== null) maximumEditDistanceToBeBestMatch = Math.min(thresholdRelative, thresholdAbsolute)
    else if (thresholdRelative !== null) maximumEditDistanceToBeBestMatch = thresholdRelative
    else if (thresholdAbsolute !== null) maximumEditDistanceToBeBestMatch = thresholdAbsolute
    // Get the edit distance to each option. If the closest one is less than 40% (by default) of str's length, then return it.
    let closestMatch
    const len = options.length
    for (let optionIndex = 0; optionIndex < len; optionIndex++) {
      const candidate = options[optionIndex]
      if (!candidate) continue
      const editDistance = Utils._getEditDistance(str, caseSensitive ? candidate : candidate.toLowerCase(), maximumEditDistanceToBeBestMatch)
      if (editDistance < maximumEditDistanceToBeBestMatch) {
        maximumEditDistanceToBeBestMatch = editDistance
        closestMatch = candidate
      }
    }
    return closestMatch
  }
  // Adapted from: https://github.com/dcporter/didyoumean.js/blob/master/didYouMean-1.2.1.js
  static _getEditDistance(stringA, stringB, maxInt) {
    // Handle null or undefined max.
    maxInt = maxInt || maxInt === 0 ? maxInt : Utils.MAX_INT
    const aLength = stringA.length
    const bLength = stringB.length
    // Fast path - no A or B.
    if (aLength === 0) return Math.min(maxInt + 1, bLength)
    if (bLength === 0) return Math.min(maxInt + 1, aLength)
    // Fast path - length diff larger than max.
    if (Math.abs(aLength - bLength) > maxInt) return maxInt + 1
    // Slow path.
    const matrix = []
    // Set up the first row ([0, 1, 2, 3, etc]).
    for (let bIndex = 0; bIndex <= bLength; bIndex++) {
      matrix[bIndex] = [bIndex]
    }
    // Set up the first column (same).
    for (let aIndex = 0; aIndex <= aLength; aIndex++) {
      matrix[0][aIndex] = aIndex
    }
    let colMin
    let minJ
    let maxJ
    // Loop over the rest of the columns.
    for (let bIndex = 1; bIndex <= bLength; bIndex++) {
      colMin = Utils.MAX_INT
      minJ = 1
      if (bIndex > maxInt) minJ = bIndex - maxInt
      maxJ = bLength + 1
      if (maxJ > maxInt + bIndex) maxJ = maxInt + bIndex
      // Loop over the rest of the rows.
      for (let aIndex = 1; aIndex <= aLength; aIndex++) {
        // If j is out of bounds, just put a large value in the slot.
        if (aIndex < minJ || aIndex > maxJ) matrix[bIndex][aIndex] = maxInt + 1
        // Otherwise do the normal Levenshtein thing.
        else {
          // If the characters are the same, there's no change in edit distance.
          if (stringB.charAt(bIndex - 1) === stringA.charAt(aIndex - 1)) matrix[bIndex][aIndex] = matrix[bIndex - 1][aIndex - 1]
          // Otherwise, see if we're substituting, inserting or deleting.
          else
            matrix[bIndex][aIndex] = Math.min(
              matrix[bIndex - 1][aIndex - 1] + 1, // Substitute
              Math.min(
                matrix[bIndex][aIndex - 1] + 1, // Insert
                matrix[bIndex - 1][aIndex] + 1
              )
            ) // Delete
        }
        // Either way, update colMin.
        if (matrix[bIndex][aIndex] < colMin) colMin = matrix[bIndex][aIndex]
      }
      // If this column's minimum is greater than the allowed maximum, there's no point
      // in going on with life.
      if (colMin > maxInt) return maxInt + 1
    }
    // If we made it this far without running into the max, then return the final matrix value.
    return matrix[bLength][aLength]
  }
  static getLineIndexAtCharacterPosition(str, index) {
    const lines = str.split("\n")
    const len = lines.length
    let position = 0
    for (let lineNumber = 0; lineNumber < len; lineNumber++) {
      position += lines[lineNumber].length
      if (position >= index) return lineNumber
    }
  }
  static resolvePath(filePath, programFilepath) {
    // For use in Node.js only
    if (!filePath.startsWith(".")) return filePath
    const path = require("path")
    const folder = this.getPathWithoutFileName(programFilepath)
    return path.resolve(folder + "/" + filePath)
  }
  static resolveProperty(obj, path, separator = ".") {
    const properties = Array.isArray(path) ? path : path.split(separator)
    return properties.reduce((prev, curr) => prev && prev[curr], obj)
  }
  static appendCodeAndReturnValueOnWindow(code, name) {
    const script = document.createElement("script")
    script.innerHTML = code
    document.head.appendChild(script)
    return window[name]
  }
  static formatStr(str, catchAllCellDelimiter = " ", parameterMap) {
    return str.replace(/{([^\}]+)}/g, (match, path) => {
      const val = parameterMap[path]
      if (!val) return ""
      return Array.isArray(val) ? val.join(catchAllCellDelimiter) : val
    })
  }
  static stripHtml(text) {
    return text && text.replace ? text.replace(/<(?:.|\n)*?>/gm, "") : text
  }
  static getUniqueWordsArray(allWords) {
    const words = allWords.replace(/\n/g, " ").split(" ")
    const index = {}
    words.forEach(word => {
      if (!index[word]) index[word] = 0
      index[word]++
    })
    return Object.keys(index).map(key => {
      return {
        word: key,
        count: index[key]
      }
    })
  }
  static getRandomString(length = 30, letters = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".split(""), seed = Date.now()) {
    let str = ""
    const randFn = Utils._getPseudoRandom0to1FloatGenerator(seed)
    while (length) {
      str += letters[Math.round(Math.min(randFn() * letters.length, letters.length - 1))]
      length--
    }
    return str
  }
  // todo: add seed!
  static makeRandomTree(lines = 1000, seed = Date.now()) {
    let str = ""
    let letters = " 123abc".split("")
    const randFn = Utils._getPseudoRandom0to1FloatGenerator(seed)
    while (lines) {
      let indent = " ".repeat(Math.round(randFn() * 6))
      let bit = indent
      let rand = Math.floor(randFn() * 30)
      while (rand) {
        bit += letters[Math.round(Math.min(randFn() * letters.length, letters.length - 1))]
        rand--
      }
      bit += "\n"
      str += bit
      lines--
    }
    return str
  }
  // adapted from https://gist.github.com/blixt/f17b47c62508be59987b
  // 1993 Park-Miller LCG
  static _getPseudoRandom0to1FloatGenerator(seed) {
    return function () {
      seed = Math.imul(48271, seed) | 0 % 2147483647
      return (seed & 2147483647) / 2147483648
    }
  }
  static sampleWithoutReplacement(population = [], quantity, seed) {
    const prng = this._getPseudoRandom0to1FloatGenerator(seed)
    const sampled = {}
    const populationSize = population.length
    if (quantity >= populationSize) return population.slice(0)
    const picked = []
    while (picked.length < quantity) {
      const index = Math.floor(prng() * populationSize)
      if (sampled[index]) continue
      sampled[index] = true
      picked.push(population[index])
    }
    return picked
  }
  static arrayToMap(arr) {
    const map = {}
    arr.forEach(val => (map[val] = true))
    return map
  }
  static _replaceNonAlphaNumericCharactersWithCharCodes(str) {
    return str
      .replace(/[^a-zA-Z0-9]/g, sub => {
        return "_" + sub.charCodeAt(0).toString()
      })
      .replace(/^([0-9])/, "number$1")
  }
  static mapValues(object, fn) {
    const result = {}
    Object.keys(object).forEach(key => {
      result[key] = fn(key)
    })
    return result
  }
  static javascriptTableWithHeaderRowToObjects(dataTable) {
    dataTable = dataTable.slice()
    const header = dataTable.shift()
    return dataTable.map(row => {
      const obj = {}
      header.forEach((colName, index) => (obj[colName] = row[index]))
      return obj
    })
  }
  static interweave(arrayOfArrays) {
    const lineCount = Math.max(...arrayOfArrays.map(arr => arr.length))
    const totalArrays = arrayOfArrays.length
    const result = []
    arrayOfArrays.forEach((lineArray, arrayIndex) => {
      for (let lineIndex = 0; lineIndex < lineCount; lineIndex++) {
        result[lineIndex * totalArrays + arrayIndex] = lineArray[lineIndex]
      }
    })
    return result
  }
  static makeSortByFn(accessorOrAccessors) {
    const arrayOfFns = Array.isArray(accessorOrAccessors) ? accessorOrAccessors : [accessorOrAccessors]
    return (objectA, objectB) => {
      const nodeAFirst = -1
      const nodeBFirst = 1
      const accessor = arrayOfFns[0] // todo: handle accessors
      const av = accessor(objectA)
      const bv = accessor(objectB)
      let result = av < bv ? nodeAFirst : av > bv ? nodeBFirst : 0
      if (av === undefined && bv !== undefined) result = nodeAFirst
      else if (bv === undefined && av !== undefined) result = nodeBFirst
      return result
    }
  }
  static _makeGraphSortFunctionFromGraph(idAccessor, graph) {
    return (nodeA, nodeB) => {
      const nodeAFirst = -1
      const nodeBFirst = 1
      const nodeAUniqueId = idAccessor(nodeA)
      const nodeBUniqueId = idAccessor(nodeB)
      const nodeAExtendsNodeB = graph[nodeAUniqueId].has(nodeBUniqueId)
      const nodeBExtendsNodeA = graph[nodeBUniqueId].has(nodeAUniqueId)
      if (nodeAExtendsNodeB) return nodeBFirst
      else if (nodeBExtendsNodeA) return nodeAFirst
      const nodeAExtendsSomething = graph[nodeAUniqueId].size > 1
      const nodeBExtendsSomething = graph[nodeBUniqueId].size > 1
      if (!nodeAExtendsSomething && nodeBExtendsSomething) return nodeAFirst
      else if (!nodeBExtendsSomething && nodeAExtendsSomething) return nodeBFirst
      if (nodeAUniqueId > nodeBUniqueId) return nodeBFirst
      else if (nodeAUniqueId < nodeBUniqueId) return nodeAFirst
      return 0
    }
  }
  static removeAll(str, needle) {
    return str.split(needle).join("")
  }
  static _makeGraphSortFunction(idAccessor, extendsIdAccessor) {
    return (nodeA, nodeB) => {
      // -1 === a before b
      const nodeAUniqueId = idAccessor(nodeA)
      const nodeAExtends = extendsIdAccessor(nodeA)
      const nodeBUniqueId = idAccessor(nodeB)
      const nodeBExtends = extendsIdAccessor(nodeB)
      const nodeAExtendsNodeB = nodeAExtends === nodeBUniqueId
      const nodeBExtendsNodeA = nodeBExtends === nodeAUniqueId
      const nodeAFirst = -1
      const nodeBFirst = 1
      if (!nodeAExtends && !nodeBExtends) {
        // If neither extends, sort by firstWord
        if (nodeAUniqueId > nodeBUniqueId) return nodeBFirst
        else if (nodeAUniqueId < nodeBUniqueId) return nodeAFirst
        return 0
      }
      // If only one extends, the other comes first
      else if (!nodeAExtends) return nodeAFirst
      else if (!nodeBExtends) return nodeBFirst
      // If A extends B, B should come first
      if (nodeAExtendsNodeB) return nodeBFirst
      else if (nodeBExtendsNodeA) return nodeAFirst
      // Sort by what they extend
      if (nodeAExtends > nodeBExtends) return nodeBFirst
      else if (nodeAExtends < nodeBExtends) return nodeAFirst
      // Finally sort by firstWord
      if (nodeAUniqueId > nodeBUniqueId) return nodeBFirst
      else if (nodeAUniqueId < nodeBUniqueId) return nodeAFirst
      // Should never hit this, unless we have a duplicate line.
      return 0
    }
  }
}
Utils.Timer = Timer
//http://stackoverflow.com/questions/37684/how-to-replace-plain-urls-with-links#21925491
Utils.linkify = (text, target = "_blank") => {
  let replacedText
  let replacePattern1
  let replacePattern2
  let replacePattern3
  //URLs starting with http://, https://, or ftp://
  replacePattern1 = /(\b(https?|ftp):\/\/[-A-Z\(\)0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+\(\)&@#\/%=~_|])/gim
  replacedText = text.replace(replacePattern1, `<a href="$1" target="${target}">$1</a>`)
  //URLs starting with "www." (without // before it, or it'd re-link the ones done above).
  replacePattern2 = /(^|[^\/])(www\.[\S]+(\b|$))/gim
  replacedText = replacedText.replace(replacePattern2, `$1<a href="http://$2" target="${target}">$2</a>`)
  //Change email addresses to mailto:: links.
  replacePattern3 = /(([a-zA-Z0-9\-\_\.])+@[a-zA-Z\_]+?(\.[a-zA-Z]{2,6})+)/gim
  replacedText = replacedText.replace(replacePattern3, '<a href="mailto:$1">$1</a>')
  return replacedText
}
// todo: switch algo to: http://indiegamr.com/generate-repeatable-random-numbers-in-js/?
Utils.makeSemiRandomFn = (seed = Date.now()) => {
  return () => {
    const semiRand = Math.sin(seed++) * 10000
    return semiRand - Math.floor(semiRand)
  }
}
Utils.randomUniformInt = (min, max, seed = Date.now()) => {
  return Math.floor(Utils.randomUniformFloat(min, max, seed))
}
Utils.randomUniformFloat = (min, max, seed = Date.now()) => {
  const randFn = Utils.makeSemiRandomFn(seed)
  return min + (max - min) * randFn()
}
Utils.getRange = (startIndex, endIndexExclusive, increment = 1) => {
  const range = []
  for (let index = startIndex; index < endIndexExclusive; index = index + increment) {
    range.push(index)
  }
  return range
}
Utils.MAX_INT = Math.pow(2, 32) - 1
window.Utils = Utils
;

let _jtreeLatestTime = 0
let _jtreeMinTimeIncrement = 0.000000000001
class AbstractNode {
  _getProcessTimeInMilliseconds() {
    // We add this loop to restore monotonically increasing .now():
    // https://developer.mozilla.org/en-US/docs/Web/API/Performance/now
    let time = performance.now()
    while (time <= _jtreeLatestTime) {
      if (time === time + _jtreeMinTimeIncrement)
        // Some browsers have different return values for perf.now()
        _jtreeMinTimeIncrement = 10 * _jtreeMinTimeIncrement
      time += _jtreeMinTimeIncrement
    }
    _jtreeLatestTime = time
    return time
  }
}
var FileFormat
;(function (FileFormat) {
  FileFormat["csv"] = "csv"
  FileFormat["tsv"] = "tsv"
  FileFormat["tree"] = "tree"
})(FileFormat || (FileFormat = {}))
class AbstractTreeEvent {
  constructor(targetNode) {
    this.targetNode = targetNode
  }
}
class ChildAddedTreeEvent extends AbstractTreeEvent {}
class ChildRemovedTreeEvent extends AbstractTreeEvent {}
class DescendantChangedTreeEvent extends AbstractTreeEvent {}
class LineChangedTreeEvent extends AbstractTreeEvent {}
class TreeWord {
  constructor(node, cellIndex) {
    this._node = node
    this._cellIndex = cellIndex
  }
  replace(newWord) {
    this._node.setWord(this._cellIndex, newWord)
  }
  get word() {
    return this._node.getWord(this._cellIndex)
  }
}
const TreeEvents = { ChildAddedTreeEvent, ChildRemovedTreeEvent, DescendantChangedTreeEvent, LineChangedTreeEvent }
var WhereOperators
;(function (WhereOperators) {
  WhereOperators["equal"] = "="
  WhereOperators["notEqual"] = "!="
  WhereOperators["lessThan"] = "<"
  WhereOperators["lessThanOrEqual"] = "<="
  WhereOperators["greaterThan"] = ">"
  WhereOperators["greaterThanOrEqual"] = ">="
  WhereOperators["includes"] = "includes"
  WhereOperators["doesNotInclude"] = "doesNotInclude"
  WhereOperators["in"] = "in"
  WhereOperators["notIn"] = "notIn"
  WhereOperators["empty"] = "empty"
  WhereOperators["notEmpty"] = "notEmpty"
})(WhereOperators || (WhereOperators = {}))
var TreeNotationConstants
;(function (TreeNotationConstants) {
  TreeNotationConstants["extends"] = "extends"
})(TreeNotationConstants || (TreeNotationConstants = {}))
class ParserCombinator {
  constructor(catchAllParser, firstWordMap = {}, regexTests = undefined) {
    this._catchAllParser = catchAllParser
    this._firstWordMap = new Map(Object.entries(firstWordMap))
    this._regexTests = regexTests
  }
  getFirstWordOptions() {
    return Array.from(this._getFirstWordMap().keys())
  }
  // todo: remove
  _getFirstWordMap() {
    return this._firstWordMap
  }
  // todo: remove
  _getFirstWordMapAsObject() {
    let obj = {}
    const map = this._getFirstWordMap()
    for (let [key, val] of map.entries()) {
      obj[key] = val
    }
    return obj
  }
  _getParser(line, contextNode, wordBreakSymbol = " ") {
    return this._getFirstWordMap().get(this._getFirstWord(line, wordBreakSymbol)) || this._getParserFromRegexTests(line) || this._getCatchAllParser(contextNode)
  }
  _getCatchAllParser(contextNode) {
    if (this._catchAllParser) return this._catchAllParser
    const parent = contextNode.parent
    if (parent) return parent._getParser()._getCatchAllParser(parent)
    return contextNode.constructor
  }
  _getParserFromRegexTests(line) {
    if (!this._regexTests) return undefined
    const hit = this._regexTests.find(test => test.regex.test(line))
    if (hit) return hit.parser
    return undefined
  }
  _getFirstWord(line, wordBreakSymbol) {
    const firstBreak = line.indexOf(wordBreakSymbol)
    return line.substr(0, firstBreak > -1 ? firstBreak : undefined)
  }
}
class TreeNode extends AbstractNode {
  constructor(children, line, parent) {
    super()
    // BEGIN MUTABLE METHODS BELOw
    this._nodeCreationTime = this._getProcessTimeInMilliseconds()
    this._parent = parent
    this._setLine(line)
    this._setChildren(children)
  }
  execute() {}
  async loadRequirements(context) {
    // todo: remove
    await Promise.all(this.map(node => node.loadRequirements(context)))
  }
  getErrors() {
    return []
  }
  get lineCellTypes() {
    // todo: make this any a constant
    return "undefinedCellType ".repeat(this.words.length).trim()
  }
  isNodeJs() {
    return typeof exports !== "undefined"
  }
  isBrowser() {
    return !this.isNodeJs()
  }
  getOlderSiblings() {
    if (this.isRoot()) return []
    return this.parent.slice(0, this.getIndex())
  }
  _getClosestOlderSibling() {
    const olderSiblings = this.getOlderSiblings()
    return olderSiblings[olderSiblings.length - 1]
  }
  getYoungerSiblings() {
    if (this.isRoot()) return []
    return this.parent.slice(this.getIndex() + 1)
  }
  getSiblings() {
    if (this.isRoot()) return []
    return this.parent.filter(node => node !== this)
  }
  _getUid() {
    if (!this._uid) this._uid = TreeNode._makeUniqueId()
    return this._uid
  }
  // todo: rename getMother? grandMother et cetera?
  get parent() {
    return this._parent
  }
  getIndentLevel(relativeTo) {
    return this._getIndentLevel(relativeTo)
  }
  get indentation() {
    const indentLevel = this._getIndentLevel() - 1
    if (indentLevel < 0) return ""
    return this.edgeSymbol.repeat(indentLevel)
  }
  _getTopDownArray(arr) {
    this.forEach(child => {
      arr.push(child)
      child._getTopDownArray(arr)
    })
  }
  get topDownArray() {
    const arr = []
    this._getTopDownArray(arr)
    return arr
  }
  *getTopDownArrayIterator() {
    for (let child of this.getChildren()) {
      yield child
      yield* child.getTopDownArrayIterator()
    }
  }
  nodeAtLine(lineNumber) {
    let index = 0
    for (let node of this.getTopDownArrayIterator()) {
      if (lineNumber === index) return node
      index++
    }
  }
  get numberOfLines() {
    let lineCount = 0
    for (let node of this.getTopDownArrayIterator()) {
      lineCount++
    }
    return lineCount
  }
  _getMaxUnitsOnALine() {
    let max = 0
    for (let node of this.getTopDownArrayIterator()) {
      const count = node.words.length + node.getIndentLevel()
      if (count > max) max = count
    }
    return max
  }
  get numberOfWords() {
    let wordCount = 0
    for (let node of this.getTopDownArrayIterator()) {
      wordCount += node.words.length
    }
    return wordCount
  }
  get lineNumber() {
    return this._getLineNumberRelativeTo()
  }
  _getLineNumber(target = this) {
    if (this._cachedLineNumber) return this._cachedLineNumber
    let lineNumber = 1
    for (let node of this.root.getTopDownArrayIterator()) {
      if (node === target) return lineNumber
      lineNumber++
    }
    return lineNumber
  }
  isBlankLine() {
    return !this.length && !this.getLine()
  }
  hasDuplicateFirstWords() {
    return this.length ? new Set(this.getFirstWords()).size !== this.length : false
  }
  isEmpty() {
    return !this.length && !this.content
  }
  _getLineNumberRelativeTo(relativeTo) {
    if (this.isRoot(relativeTo)) return 0
    const start = relativeTo || this.root
    return start._getLineNumber(this)
  }
  isRoot(relativeTo) {
    return relativeTo === this || !this.parent
  }
  get root() {
    return this._getRootNode()
  }
  _getRootNode(relativeTo) {
    if (this.isRoot(relativeTo)) return this
    return this.parent._getRootNode(relativeTo)
  }
  toString(indentCount = 0, language = this) {
    if (this.isRoot()) return this._childrenToString(indentCount, language)
    return language.edgeSymbol.repeat(indentCount) + this.getLine(language) + (this.length ? language.nodeBreakSymbol + this._childrenToString(indentCount + 1, language) : "")
  }
  get asString() {
    return this.toString()
  }
  printLinesFrom(start, quantity) {
    return this._printLinesFrom(start, quantity, false)
  }
  printLinesWithLineNumbersFrom(start, quantity) {
    return this._printLinesFrom(start, quantity, true)
  }
  _printLinesFrom(start, quantity, printLineNumbers) {
    // todo: use iterator for better perf?
    const end = start + quantity
    this.toString()
      .split("\n")
      .slice(start, end)
      .forEach((line, index) => {
        if (printLineNumbers) console.log(`${start + index} ${line}`)
        else console.log(line)
      })
    return this
  }
  getWord(index) {
    const words = this._getWords(0)
    if (index < 0) index = words.length + index
    return words[index]
  }
  get list() {
    return this.getWordsFrom(1)
  }
  _toHtml(indentCount) {
    const path = this.getPathVector().join(" ")
    const classes = {
      nodeLine: "nodeLine",
      edgeSymbol: "edgeSymbol",
      nodeBreakSymbol: "nodeBreakSymbol",
      nodeChildren: "nodeChildren"
    }
    const edge = this.edgeSymbol.repeat(indentCount)
    // Set up the firstWord part of the node
    const edgeHtml = `<span class="${classes.nodeLine}" data-pathVector="${path}"><span class="${classes.edgeSymbol}">${edge}</span>`
    const lineHtml = this._getLineHtml()
    const childrenHtml = this.length ? `<span class="${classes.nodeBreakSymbol}">${this.nodeBreakSymbol}</span>` + `<span class="${classes.nodeChildren}">${this._childrenToHtml(indentCount + 1)}</span>` : ""
    return `${edgeHtml}${lineHtml}${childrenHtml}</span>`
  }
  _getWords(startFrom) {
    if (!this._words) this._words = this._getLine().split(this.wordBreakSymbol)
    return startFrom ? this._words.slice(startFrom) : this._words
  }
  get words() {
    return this._getWords(0)
  }
  doesExtend(parserId) {
    return false
  }
  require(moduleName, filePath) {
    if (!this.isNodeJs()) return window[moduleName]
    return require(filePath || moduleName)
  }
  getWordsFrom(startFrom) {
    return this._getWords(startFrom)
  }
  getFirstAncestor() {
    const parent = this.parent
    return parent.isRoot() ? this : parent.getFirstAncestor()
  }
  isLoaded() {
    return true
  }
  getRunTimePhaseErrors() {
    if (!this._runTimePhaseErrors) this._runTimePhaseErrors = {}
    return this._runTimePhaseErrors
  }
  setRunTimePhaseError(phase, errorObject) {
    if (errorObject === undefined) delete this.getRunTimePhaseErrors()[phase]
    else this.getRunTimePhaseErrors()[phase] = errorObject
    return this
  }
  _getJavascriptPrototypeChainUpTo(stopAtClassName = "TreeNode") {
    // todo: cross browser test this
    let constructor = this.constructor
    const chain = []
    while (constructor.name !== stopAtClassName) {
      chain.unshift(constructor.name)
      constructor = constructor.__proto__
    }
    chain.unshift(stopAtClassName)
    return chain
  }
  _getProjectRootDir() {
    return this.isRoot() ? "" : this.root._getProjectRootDir()
  }
  // Concat 2 trees amd return a new true, but replace any nodes
  // in this tree that start with the same node from the first tree with
  // that patched version. Does not recurse.
  patch(two) {
    const copy = this.clone()
    two.forEach(node => {
      const hit = copy.getNode(node.getWord(0))
      if (hit) hit.destroy()
    })
    copy.concat(two)
    return copy
  }
  getSparsity() {
    const nodes = this.getChildren()
    const fields = this._getUnionNames()
    let count = 0
    this.getChildren().forEach(node => {
      fields.forEach(field => {
        if (node.has(field)) count++
      })
    })
    return 1 - count / (nodes.length * fields.length)
  }
  // todo: rename. what is the proper term from set/cat theory?
  getBiDirectionalMaps(propertyNameOrFn, propertyNameOrFn2 = node => node.getWord(0)) {
    const oneToTwo = {}
    const twoToOne = {}
    const is1Str = typeof propertyNameOrFn === "string"
    const is2Str = typeof propertyNameOrFn2 === "string"
    const children = this.getChildren()
    this.forEach((node, index) => {
      const value1 = is1Str ? node.get(propertyNameOrFn) : propertyNameOrFn(node, index, children)
      const value2 = is2Str ? node.get(propertyNameOrFn2) : propertyNameOrFn2(node, index, children)
      if (value1 !== undefined) {
        if (!oneToTwo[value1]) oneToTwo[value1] = []
        oneToTwo[value1].push(value2)
      }
      if (value2 !== undefined) {
        if (!twoToOne[value2]) twoToOne[value2] = []
        twoToOne[value2].push(value1)
      }
    })
    return [oneToTwo, twoToOne]
  }
  _getWordIndexCharacterStartPosition(wordIndex) {
    const xiLength = this.edgeSymbol.length
    const numIndents = this._getIndentLevel() - 1
    const indentPosition = xiLength * numIndents
    if (wordIndex < 1) return xiLength * (numIndents + wordIndex)
    return indentPosition + this.words.slice(0, wordIndex).join(this.wordBreakSymbol).length + this.wordBreakSymbol.length
  }
  getNodeInScopeAtCharIndex(charIndex) {
    if (this.isRoot()) return this
    let wordIndex = this.getWordIndexAtCharacterIndex(charIndex)
    if (wordIndex > 0) return this
    let node = this
    while (wordIndex < 1) {
      node = node.parent
      wordIndex++
    }
    return node
  }
  getWordProperties(wordIndex) {
    const start = this._getWordIndexCharacterStartPosition(wordIndex)
    const word = wordIndex < 0 ? "" : this.getWord(wordIndex)
    return {
      startCharIndex: start,
      endCharIndex: start + word.length,
      word: word
    }
  }
  fill(fill = "") {
    this.topDownArray.forEach(line => {
      line.words.forEach((word, index) => line.setWord(index, fill))
    })
    return this
  }
  getAllWordBoundaryCoordinates() {
    const coordinates = []
    let lineIndex = 0
    for (let node of this.getTopDownArrayIterator()) {
      node.getWordBoundaryCharIndices().forEach((charIndex, wordIndex) => {
        coordinates.push({
          lineIndex: lineIndex,
          charIndex: charIndex,
          wordIndex: wordIndex
        })
      })
      lineIndex++
    }
    return coordinates
  }
  getWordBoundaryCharIndices() {
    let indentLevel = this._getIndentLevel()
    const wordBreakSymbolLength = this.wordBreakSymbol.length
    let elapsed = indentLevel
    return this.words.map((word, wordIndex) => {
      const boundary = elapsed
      elapsed += word.length + wordBreakSymbolLength
      return boundary
    })
  }
  getWordIndexAtCharacterIndex(charIndex) {
    // todo: is this correct thinking for handling root?
    if (this.isRoot()) return 0
    const numberOfIndents = this._getIndentLevel(undefined) - 1
    // todo: probably want to rewrite this in a performant way.
    const spots = []
    while (spots.length < numberOfIndents) {
      spots.push(-(numberOfIndents - spots.length))
    }
    this.words.forEach((word, wordIndex) => {
      word.split("").forEach(letter => {
        spots.push(wordIndex)
      })
      spots.push(wordIndex)
    })
    return spots[charIndex]
  }
  // Note: This currently does not return any errors resulting from "required" or "single"
  getAllErrors(lineStartsAt = 1) {
    const errors = []
    for (let node of this.topDownArray) {
      node._cachedLineNumber = lineStartsAt // todo: cleanup
      const errs = node.getErrors()
      errs.forEach(err => errors.push(err))
      // delete node._cachedLineNumber
      lineStartsAt++
    }
    return errors
  }
  *getAllErrorsIterator() {
    let line = 1
    for (let node of this.getTopDownArrayIterator()) {
      node._cachedLineNumber = line
      const errs = node.getErrors()
      // delete node._cachedLineNumber
      if (errs.length) yield errs
      line++
    }
  }
  get firstWord() {
    return this.words[0]
  }
  get content() {
    const words = this.getWordsFrom(1)
    return words.length ? words.join(this.wordBreakSymbol) : undefined
  }
  get contentWithChildren() {
    // todo: deprecate
    const content = this.content
    return (content ? content : "") + (this.length ? this.nodeBreakSymbol + this._childrenToString() : "")
  }
  getFirstNode() {
    return this.nodeAt(0)
  }
  getStack() {
    return this._getStack()
  }
  _getStack(relativeTo) {
    if (this.isRoot(relativeTo)) return []
    const parent = this.parent
    if (parent.isRoot(relativeTo)) return [this]
    else return parent._getStack(relativeTo).concat([this])
  }
  getStackString() {
    return this._getStack()
      .map((node, index) => this.edgeSymbol.repeat(index) + node.getLine())
      .join(this.nodeBreakSymbol)
  }
  getLine(language) {
    if (!this._words && !language) return this._getLine() // todo: how does this interact with "language" param?
    return this.words.join((language || this).wordBreakSymbol)
  }
  getColumnNames() {
    return this._getUnionNames()
  }
  getOneHot(column) {
    const clone = this.clone()
    const cols = Array.from(new Set(clone.getColumn(column)))
    clone.forEach(node => {
      const val = node.get(column)
      node.delete(column)
      cols.forEach(col => {
        node.set(column + "_" + col, val === col ? "1" : "0")
      })
    })
    return clone
  }
  // todo: return array? getPathArray?
  _getFirstWordPath(relativeTo) {
    if (this.isRoot(relativeTo)) return ""
    else if (this.parent.isRoot(relativeTo)) return this.firstWord
    return this.parent._getFirstWordPath(relativeTo) + this.edgeSymbol + this.firstWord
  }
  getFirstWordPathRelativeTo(relativeTo) {
    return this._getFirstWordPath(relativeTo)
  }
  getFirstWordPath() {
    return this._getFirstWordPath()
  }
  getPathVector() {
    return this._getPathVector()
  }
  getPathVectorRelativeTo(relativeTo) {
    return this._getPathVector(relativeTo)
  }
  _getPathVector(relativeTo) {
    if (this.isRoot(relativeTo)) return []
    const path = this.parent._getPathVector(relativeTo)
    path.push(this.getIndex())
    return path
  }
  getIndex() {
    return this.parent._indexOfNode(this)
  }
  isTerminal() {
    return !this.length
  }
  _getLineHtml() {
    return this.words.map((word, index) => `<span class="word${index}">${Utils.stripHtml(word)}</span>`).join(`<span class="zIncrement">${this.wordBreakSymbol}</span>`)
  }
  _getXmlContent(indentCount) {
    if (this.content !== undefined) return this.contentWithChildren
    return this.length ? `${indentCount === -1 ? "" : "\n"}${this._childrenToXml(indentCount > -1 ? indentCount + 2 : -1)}${" ".repeat(indentCount)}` : ""
  }
  _toXml(indentCount) {
    const indent = " ".repeat(indentCount)
    const tag = this.firstWord
    return `${indent}<${tag}>${this._getXmlContent(indentCount)}</${tag}>${indentCount === -1 ? "" : "\n"}`
  }
  _toObjectTuple() {
    const content = this.content
    const length = this.length
    const hasChildrenNoContent = content === undefined && length
    const hasContentAndHasChildren = content !== undefined && length
    // If the node has a content and a subtree return it as a string, as
    // Javascript object values can't be both a leaf and a tree.
    const tupleValue = hasChildrenNoContent ? this.toObject() : hasContentAndHasChildren ? this.contentWithChildren : content
    return [this.firstWord, tupleValue]
  }
  _indexOfNode(needleNode) {
    let result = -1
    this.find((node, index) => {
      if (node === needleNode) {
        result = index
        return true
      }
    })
    return result
  }
  getMaxLineWidth() {
    let maxWidth = 0
    for (let node of this.getTopDownArrayIterator()) {
      const lineWidth = node.getLine().length
      if (lineWidth > maxWidth) maxWidth = lineWidth
    }
    return maxWidth
  }
  toTreeNode() {
    return new TreeNode(this.toString())
  }
  _rightPad(newWidth, padCharacter) {
    const line = this.getLine()
    this.setLine(line + padCharacter.repeat(newWidth - line.length))
    return this
  }
  rightPad(padCharacter = " ") {
    const newWidth = this.getMaxLineWidth()
    this.topDownArray.forEach(node => node._rightPad(newWidth, padCharacter))
    return this
  }
  lengthen(numberOfLines) {
    let linesToAdd = numberOfLines - this.numberOfLines
    while (linesToAdd > 0) {
      this.appendLine("")
      linesToAdd--
    }
    return this
  }
  toSideBySide(treesOrStrings, delimiter = " ") {
    treesOrStrings = treesOrStrings.map(tree => (tree instanceof TreeNode ? tree : new TreeNode(tree)))
    const clone = this.toTreeNode()
    const nodeBreakSymbol = "\n"
    let next
    while ((next = treesOrStrings.shift())) {
      clone.lengthen(next.numberOfLines)
      clone.rightPad()
      next
        .toString()
        .split(nodeBreakSymbol)
        .forEach((line, index) => {
          const node = clone.nodeAtLine(index)
          node.setLine(node.getLine() + delimiter + line)
        })
    }
    return clone
  }
  toComparison(treeNode) {
    const nodeBreakSymbol = "\n"
    const lines = treeNode.toString().split(nodeBreakSymbol)
    return new TreeNode(
      this.toString()
        .split(nodeBreakSymbol)
        .map((line, index) => (lines[index] === line ? "" : "x"))
        .join(nodeBreakSymbol)
    )
  }
  toBraid(treesOrStrings) {
    treesOrStrings.unshift(this)
    const nodeDelimiter = this.nodeBreakSymbol
    return new TreeNode(
      Utils.interweave(treesOrStrings.map(tree => tree.toString().split(nodeDelimiter)))
        .map(line => (line === undefined ? "" : line))
        .join(nodeDelimiter)
    )
  }
  getSlice(startIndexInclusive, stopIndexExclusive) {
    return new TreeNode(
      this.slice(startIndexInclusive, stopIndexExclusive)
        .map(child => child.toString())
        .join("\n")
    )
  }
  _hasColumns(columns) {
    const words = this.words
    return columns.every((searchTerm, index) => searchTerm === words[index])
  }
  hasWord(index, word) {
    return this.getWord(index) === word
  }
  getNodeByColumns(...columns) {
    return this.topDownArray.find(node => node._hasColumns(columns))
  }
  getNodeByColumn(index, name) {
    return this.find(node => node.getWord(index) === name)
  }
  _getNodesByColumn(index, name) {
    return this.filter(node => node.getWord(index) === name)
  }
  // todo: preserve subclasses!
  select(columnNames) {
    columnNames = Array.isArray(columnNames) ? columnNames : [columnNames]
    const result = new TreeNode()
    this.forEach(node => {
      const tree = result.appendLine(node.getLine())
      columnNames.forEach(name => {
        const valueNode = node.getNode(name)
        if (valueNode) tree.appendNode(valueNode)
      })
    })
    return result
  }
  selectionToString() {
    return this.getSelectedNodes()
      .map(node => node.toString())
      .join("\n")
  }
  getSelectedNodes() {
    return this.topDownArray.filter(node => node.isSelected())
  }
  clearSelection() {
    this.getSelectedNodes().forEach(node => node.unselectNode())
  }
  // Note: this is for debugging select chains
  print(message = "") {
    if (message) console.log(message)
    console.log(this.toString())
    return this
  }
  // todo: preserve subclasses!
  // todo: preserve links back to parent so you could edit as normal?
  where(columnName, operator, fixedValue) {
    const isArray = Array.isArray(fixedValue)
    const valueType = isArray ? typeof fixedValue[0] : typeof fixedValue
    let parser
    if (valueType === "number") parser = parseFloat
    const fn = node => {
      const cell = node.get(columnName)
      const typedCell = parser ? parser(cell) : cell
      if (operator === WhereOperators.equal) return fixedValue === typedCell
      else if (operator === WhereOperators.notEqual) return fixedValue !== typedCell
      else if (operator === WhereOperators.includes) return typedCell !== undefined && typedCell.includes(fixedValue)
      else if (operator === WhereOperators.doesNotInclude) return typedCell === undefined || !typedCell.includes(fixedValue)
      else if (operator === WhereOperators.greaterThan) return typedCell > fixedValue
      else if (operator === WhereOperators.lessThan) return typedCell < fixedValue
      else if (operator === WhereOperators.greaterThanOrEqual) return typedCell >= fixedValue
      else if (operator === WhereOperators.lessThanOrEqual) return typedCell <= fixedValue
      else if (operator === WhereOperators.empty) return !node.has(columnName)
      else if (operator === WhereOperators.notEmpty) return node.has(columnName) || (cell !== "" && cell !== undefined)
      else if (operator === WhereOperators.in && isArray) return fixedValue.includes(typedCell)
      else if (operator === WhereOperators.notIn && isArray) return !fixedValue.includes(typedCell)
    }
    const result = new TreeNode()
    this.filter(fn).forEach(node => {
      result.appendNode(node)
    })
    return result
  }
  with(firstWord) {
    return this.filter(node => node.has(firstWord))
  }
  without(firstWord) {
    return this.filter(node => !node.has(firstWord))
  }
  first(quantity = 1) {
    return this.limit(quantity, 0)
  }
  last(quantity = 1) {
    return this.limit(quantity, this.length - quantity)
  }
  // todo: preserve subclasses!
  limit(quantity, offset = 0) {
    const result = new TreeNode()
    this.getChildren()
      .slice(offset, quantity + offset)
      .forEach(node => {
        result.appendNode(node)
      })
    return result
  }
  getChildrenFirstArray() {
    const arr = []
    this._getChildrenFirstArray(arr)
    return arr
  }
  _getChildrenFirstArray(arr) {
    this.forEach(child => {
      child._getChildrenFirstArray(arr)
      arr.push(child)
    })
  }
  _getIndentLevel(relativeTo) {
    return this._getStack(relativeTo).length
  }
  getParentFirstArray() {
    const levels = this._getLevels()
    const arr = []
    Object.values(levels).forEach(level => {
      level.forEach(item => arr.push(item))
    })
    return arr
  }
  _getLevels() {
    const levels = {}
    this.topDownArray.forEach(node => {
      const level = node._getIndentLevel()
      if (!levels[level]) levels[level] = []
      levels[level].push(node)
    })
    return levels
  }
  _getChildrenArray() {
    if (!this._children) this._children = []
    return this._children
  }
  getLines() {
    return this.map(node => node.getLine())
  }
  getChildren() {
    return this._getChildrenArray().slice(0)
  }
  get length() {
    return this._getChildrenArray().length
  }
  _nodeAt(index) {
    if (index < 0) index = this.length + index
    return this._getChildrenArray()[index]
  }
  nodeAt(indexOrIndexArray) {
    if (typeof indexOrIndexArray === "number") return this._nodeAt(indexOrIndexArray)
    if (indexOrIndexArray.length === 1) return this._nodeAt(indexOrIndexArray[0])
    const first = indexOrIndexArray[0]
    const node = this._nodeAt(first)
    if (!node) return undefined
    return node.nodeAt(indexOrIndexArray.slice(1))
  }
  // Flatten a tree node into an object like {twitter:"pldb", "twitter.followers":123}.
  // Assumes you have a nested key/value list with no multiline strings.
  toFlatObject(delimiter = ".") {
    let newObject = {}
    const { edgeSymbolRegex } = this
    this.forEach((child, index) => {
      newObject[child.getWord(0)] = child.content
      child.topDownArray.forEach(node => {
        const newColumnName = node.getFirstWordPathRelativeTo(this).replace(edgeSymbolRegex, delimiter)
        const value = node.content
        newObject[newColumnName] = value
      })
    })
    return newObject
  }
  _toObject() {
    const obj = {}
    this.forEach(node => {
      const tuple = node._toObjectTuple()
      obj[tuple[0]] = tuple[1]
    })
    return obj
  }
  get asHtml() {
    return this._childrenToHtml(0)
  }
  _toHtmlCubeLine(indents = 0, lineIndex = 0, planeIndex = 0) {
    const getLine = (cellIndex, word = "") =>
      `<span class="htmlCubeSpan" style="top: calc(var(--topIncrement) * ${planeIndex} + var(--rowHeight) * ${lineIndex}); left:calc(var(--leftIncrement) * ${planeIndex} + var(--cellWidth) * ${cellIndex});">${word}</span>`
    let cells = []
    this.words.forEach((word, index) => (word ? cells.push(getLine(index + indents, word)) : ""))
    return cells.join("")
  }
  get asHtmlCube() {
    return this.map((plane, planeIndex) => plane.topDownArray.map((line, lineIndex) => line._toHtmlCubeLine(line.getIndentLevel() - 2, lineIndex, planeIndex)).join("")).join("")
  }
  _getHtmlJoinByCharacter() {
    return `<span class="nodeBreakSymbol">${this.nodeBreakSymbol}</span>`
  }
  _childrenToHtml(indentCount) {
    const joinBy = this._getHtmlJoinByCharacter()
    return this.map(node => node._toHtml(indentCount)).join(joinBy)
  }
  _childrenToString(indentCount, language = this) {
    return this.map(node => node.toString(indentCount, language)).join(language.nodeBreakSymbol)
  }
  childrenToString(indentCount = 0) {
    return this._childrenToString(indentCount)
  }
  // todo: implement
  _getChildJoinCharacter() {
    return "\n"
  }
  format() {
    this.forEach(child => child.format())
    return this
  }
  compile() {
    return this.map(child => child.compile()).join(this._getChildJoinCharacter())
  }
  get asXml() {
    return this._childrenToXml(0)
  }
  toDisk(path) {
    if (!this.isNodeJs()) throw new Error("This method only works in Node.js")
    const format = TreeNode._getFileFormat(path)
    const formats = {
      tree: tree => tree.toString(),
      csv: tree => tree.asCsv,
      tsv: tree => tree.asTsv
    }
    this.require("fs").writeFileSync(path, formats[format](this), "utf8")
    return this
  }
  _lineToYaml(indentLevel, listTag = "") {
    let prefix = " ".repeat(indentLevel)
    if (listTag && indentLevel > 1) prefix = " ".repeat(indentLevel - 2) + listTag + " "
    return prefix + `${this.firstWord}:` + (this.content ? " " + this.content : "")
  }
  _isYamlList() {
    return this.hasDuplicateFirstWords()
  }
  get asYaml() {
    return `%YAML 1.2
---\n${this._childrenToYaml(0).join("\n")}`
  }
  _childrenToYaml(indentLevel) {
    if (this._isYamlList()) return this._childrenToYamlList(indentLevel)
    else return this._childrenToYamlAssociativeArray(indentLevel)
  }
  // if your code-to-be-yaml has a list of associative arrays of type N and you don't
  // want the type N to print
  _collapseYamlLine() {
    return false
  }
  _toYamlListElement(indentLevel) {
    const children = this._childrenToYaml(indentLevel + 1)
    if (this._collapseYamlLine()) {
      if (indentLevel > 1) return children.join("\n").replace(" ".repeat(indentLevel), " ".repeat(indentLevel - 2) + "- ")
      return children.join("\n")
    } else {
      children.unshift(this._lineToYaml(indentLevel, "-"))
      return children.join("\n")
    }
  }
  _childrenToYamlList(indentLevel) {
    return this.map(node => node._toYamlListElement(indentLevel + 2))
  }
  _toYamlAssociativeArrayElement(indentLevel) {
    const children = this._childrenToYaml(indentLevel + 1)
    children.unshift(this._lineToYaml(indentLevel))
    return children.join("\n")
  }
  _childrenToYamlAssociativeArray(indentLevel) {
    return this.map(node => node._toYamlAssociativeArrayElement(indentLevel))
  }
  get asJsonSubset() {
    return JSON.stringify(this.toObject(), null, " ")
  }
  _toObjectForSerialization() {
    return this.length
      ? {
          cells: this.words,
          children: this.map(child => child._toObjectForSerialization())
        }
      : {
          cells: this.words
        }
  }
  get asJson() {
    return JSON.stringify({ children: this.map(child => child._toObjectForSerialization()) }, null, " ")
  }
  get asGrid() {
    const WordBreakSymbol = this.wordBreakSymbol
    return this.toString()
      .split(this.nodeBreakSymbol)
      .map(line => line.split(WordBreakSymbol))
  }
  get asGridJson() {
    return JSON.stringify(this.asGrid, null, 2)
  }
  findNodes(firstWordPath) {
    // todo: can easily speed this up
    const map = {}
    if (!Array.isArray(firstWordPath)) firstWordPath = [firstWordPath]
    firstWordPath.forEach(path => (map[path] = true))
    return this.topDownArray.filter(node => {
      if (map[node._getFirstWordPath(this)]) return true
      return false
    })
  }
  evalTemplateString(str) {
    const that = this
    return str.replace(/{([^\}]+)}/g, (match, path) => that.get(path) || "")
  }
  emitLogMessage(message) {
    console.log(message)
  }
  getColumn(path) {
    return this.map(node => node.get(path))
  }
  getFiltered(fn) {
    const clone = this.clone()
    clone
      .filter((node, index) => !fn(node, index))
      .forEach(node => {
        node.destroy()
      })
    return clone
  }
  getNode(firstWordPath) {
    return this._getNodeByPath(firstWordPath)
  }
  getFrom(prefix) {
    const hit = this.filter(node => node.getLine().startsWith(prefix))[0]
    if (hit) return hit.getLine().substr((prefix + this.wordBreakSymbol).length)
  }
  get(firstWordPath) {
    const node = this._getNodeByPath(firstWordPath)
    return node === undefined ? undefined : node.content
  }
  getOneOf(keys) {
    for (let i = 0; i < keys.length; i++) {
      const value = this.get(keys[i])
      if (value) return value
    }
    return ""
  }
  // move to treenode
  pick(fields) {
    const newTree = new TreeNode(this.toString()) // todo: why not clone?
    const map = Utils.arrayToMap(fields)
    newTree.nodeAt(0).forEach(node => {
      if (!map[node.getWord(0)]) node.destroy()
    })
    return newTree
  }
  getNodesByGlobPath(query) {
    return this._getNodesByGlobPath(query)
  }
  _getNodesByGlobPath(globPath) {
    const edgeSymbol = this.edgeSymbol
    if (!globPath.includes(edgeSymbol)) {
      if (globPath === "*") return this.getChildren()
      return this.filter(node => node.firstWord === globPath)
    }
    const parts = globPath.split(edgeSymbol)
    const current = parts.shift()
    const rest = parts.join(edgeSymbol)
    const matchingNodes = current === "*" ? this.getChildren() : this.filter(child => child.firstWord === current)
    return [].concat.apply(
      [],
      matchingNodes.map(node => node._getNodesByGlobPath(rest))
    )
  }
  _getNodeByPath(firstWordPath) {
    const edgeSymbol = this.edgeSymbol
    if (!firstWordPath.includes(edgeSymbol)) {
      const index = this.indexOfLast(firstWordPath)
      return index === -1 ? undefined : this._nodeAt(index)
    }
    const parts = firstWordPath.split(edgeSymbol)
    const current = parts.shift()
    const currentNode = this._getChildrenArray()[this._getIndex()[current]]
    return currentNode ? currentNode._getNodeByPath(parts.join(edgeSymbol)) : undefined
  }
  get next() {
    if (this.isRoot()) return this
    const index = this.getIndex()
    const parent = this.parent
    const length = parent.length
    const next = index + 1
    return next === length ? parent._getChildrenArray()[0] : parent._getChildrenArray()[next]
  }
  get previous() {
    if (this.isRoot()) return this
    const index = this.getIndex()
    const parent = this.parent
    const length = parent.length
    const prev = index - 1
    return prev === -1 ? parent._getChildrenArray()[length - 1] : parent._getChildrenArray()[prev]
  }
  _getUnionNames() {
    if (!this.length) return []
    const obj = {}
    this.forEach(node => {
      if (!node.length) return undefined
      node.forEach(node => {
        obj[node.firstWord] = 1
      })
    })
    return Object.keys(obj)
  }
  getAncestorNodesByInheritanceViaExtendsKeyword(key) {
    const ancestorNodes = this._getAncestorNodes(
      (node, id) => node._getNodesByColumn(0, id),
      node => node.get(key),
      this
    )
    ancestorNodes.push(this)
    return ancestorNodes
  }
  // Note: as you can probably tell by the name of this method, I don't recommend using this as it will likely be replaced by something better.
  getAncestorNodesByInheritanceViaColumnIndices(thisColumnNumber, extendsColumnNumber) {
    const ancestorNodes = this._getAncestorNodes(
      (node, id) => node._getNodesByColumn(thisColumnNumber, id),
      node => node.getWord(extendsColumnNumber),
      this
    )
    ancestorNodes.push(this)
    return ancestorNodes
  }
  _getAncestorNodes(getPotentialParentNodesByIdFn, getParentIdFn, cannotContainNode) {
    const parentId = getParentIdFn(this)
    if (!parentId) return []
    const potentialParentNodes = getPotentialParentNodesByIdFn(this.parent, parentId)
    if (!potentialParentNodes.length) throw new Error(`"${this.getLine()} tried to extend "${parentId}" but "${parentId}" not found.`)
    if (potentialParentNodes.length > 1) throw new Error(`Invalid inheritance family tree. Multiple unique ids found for "${parentId}"`)
    const parentNode = potentialParentNodes[0]
    // todo: detect loops
    if (parentNode === cannotContainNode) throw new Error(`Loop detected between '${this.getLine()}' and '${parentNode.getLine()}'`)
    const ancestorNodes = parentNode._getAncestorNodes(getPotentialParentNodesByIdFn, getParentIdFn, cannotContainNode)
    ancestorNodes.push(parentNode)
    return ancestorNodes
  }
  pathVectorToFirstWordPath(pathVector) {
    const path = pathVector.slice() // copy array
    const names = []
    let node = this
    while (path.length) {
      if (!node) return names
      names.push(node.nodeAt(path[0]).firstWord)
      node = node.nodeAt(path.shift())
    }
    return names
  }
  toStringWithLineNumbers() {
    return this.toString()
      .split("\n")
      .map((line, index) => `${index + 1} ${line}`)
      .join("\n")
  }
  get asCsv() {
    return this.toDelimited(",")
  }
  _getTypes(header) {
    const matrix = this._getMatrix(header)
    const types = header.map(i => "int")
    matrix.forEach(row => {
      row.forEach((value, index) => {
        const type = types[index]
        if (type === "string") return 1
        if (value === undefined || value === "") return 1
        if (type === "float") {
          if (value.match(/^\-?[0-9]*\.?[0-9]*$/)) return 1
          types[index] = "string"
        }
        if (value.match(/^\-?[0-9]+$/)) return 1
        types[index] = "string"
      })
    })
    return types
  }
  toDataTable(header = this._getUnionNames()) {
    const types = this._getTypes(header)
    const parsers = {
      string: str => str,
      float: parseFloat,
      int: parseInt
    }
    const cellFn = (cellValue, rowIndex, columnIndex) => (rowIndex ? parsers[types[columnIndex]](cellValue) : cellValue)
    const arrays = this._toArrays(header, cellFn)
    arrays.rows.unshift(arrays.header)
    return arrays.rows
  }
  toDelimited(delimiter, header = this._getUnionNames(), escapeSpecialChars = true) {
    const regex = new RegExp(`(\\n|\\"|\\${delimiter})`)
    const cellFn = (str, row, column) => (!str.toString().match(regex) ? str : `"` + str.replace(/\"/g, `""`) + `"`)
    return this._toDelimited(delimiter, header, escapeSpecialChars ? cellFn : str => str)
  }
  _getMatrix(columns) {
    const matrix = []
    this.forEach(child => {
      const row = []
      columns.forEach(col => {
        row.push(child.get(col))
      })
      matrix.push(row)
    })
    return matrix
  }
  _toArrays(columnNames, cellFn) {
    const skipHeaderRow = 1
    const header = columnNames.map((columnName, index) => cellFn(columnName, 0, index))
    const rows = this.map((node, rowNumber) =>
      columnNames.map((columnName, columnIndex) => {
        const childNode = node.getNode(columnName)
        const content = childNode ? childNode.contentWithChildren : ""
        return cellFn(content, rowNumber + skipHeaderRow, columnIndex)
      })
    )
    return {
      rows,
      header
    }
  }
  _toDelimited(delimiter, header, cellFn) {
    const data = this._toArrays(header, cellFn)
    return data.header.join(delimiter) + "\n" + data.rows.map(row => row.join(delimiter)).join("\n")
  }
  get asTable() {
    // Output a table for printing
    return this._toTable(100, false)
  }
  toFormattedTable(maxCharactersPerColumn, alignRight = false) {
    return this._toTable(maxCharactersPerColumn, alignRight)
  }
  _toTable(maxCharactersPerColumn, alignRight = false) {
    const header = this._getUnionNames()
    // Set initial column widths
    const widths = header.map(col => (col.length > maxCharactersPerColumn ? maxCharactersPerColumn : col.length))
    // Expand column widths if needed
    this.forEach(node => {
      if (!node.length) return true
      header.forEach((col, index) => {
        const cellValue = node.get(col)
        if (!cellValue) return true
        const length = cellValue.toString().length
        if (length > widths[index]) widths[index] = length > maxCharactersPerColumn ? maxCharactersPerColumn : length
      })
    })
    const cellFn = (cellText, row, col) => {
      const width = widths[col]
      // Strip newlines in fixedWidth output
      const cellValue = cellText.toString().replace(/\n/g, "\\n")
      const cellLength = cellValue.length
      if (cellLength > width) return cellValue.substr(0, width) + "..."
      const padding = " ".repeat(width - cellLength)
      return alignRight ? padding + cellValue : cellValue + padding
    }
    return this._toDelimited(" ", header, cellFn)
  }
  get asSsv() {
    return this.toDelimited(" ")
  }
  get asOutline() {
    return this._toOutline(node => node.getLine())
  }
  toMappedOutline(nodeFn) {
    return this._toOutline(nodeFn)
  }
  // Adapted from: https://github.com/notatestuser/treeify.js
  _toOutline(nodeFn) {
    const growBranch = (outlineTreeNode, last, lastStates, nodeFn, callback) => {
      let lastStatesCopy = lastStates.slice(0)
      const node = outlineTreeNode.node
      if (lastStatesCopy.push([outlineTreeNode, last]) && lastStates.length > 0) {
        let line = ""
        // firstWordd on the "was last element" states of whatever we're nested within,
        // we need to append either blankness or a branch to our line
        lastStates.forEach((lastState, idx) => {
          if (idx > 0) line += lastState[1] ? " " : "│"
        })
        // the prefix varies firstWordd on whether the key contains something to show and
        // whether we're dealing with the last element in this collection
        // the extra "-" just makes things stand out more.
        line += (last ? "└" : "├") + nodeFn(node)
        callback(line)
      }
      if (!node) return
      const length = node.length
      let index = 0
      node.forEach(node => {
        let lastKey = ++index === length
        growBranch({ node: node }, lastKey, lastStatesCopy, nodeFn, callback)
      })
    }
    let output = ""
    growBranch({ node: this }, false, [], nodeFn, line => (output += line + "\n"))
    return output
  }
  copyTo(node, index) {
    return node._insertLineAndChildren(this.getLine(), this.childrenToString(), index)
  }
  // Note: Splits using a positive lookahead
  // this.split("foo").join("\n") === this.toString()
  split(firstWord) {
    const constructor = this.constructor
    const NodeBreakSymbol = this.nodeBreakSymbol
    const WordBreakSymbol = this.wordBreakSymbol
    // todo: cleanup. the escaping is wierd.
    return this.toString()
      .split(new RegExp(`\\${NodeBreakSymbol}(?=${firstWord}(?:${WordBreakSymbol}|\\${NodeBreakSymbol}))`, "g"))
      .map(str => new constructor(str))
  }
  get asMarkdownTable() {
    return this.toMarkdownTableAdvanced(this._getUnionNames(), val => val)
  }
  toMarkdownTableAdvanced(columns, formatFn) {
    const matrix = this._getMatrix(columns)
    const empty = columns.map(col => "-")
    matrix.unshift(empty)
    matrix.unshift(columns)
    const lines = matrix.map((row, rowIndex) => {
      const formattedValues = row.map((val, colIndex) => formatFn(val, rowIndex, colIndex))
      return `|${formattedValues.join("|")}|`
    })
    return lines.join("\n")
  }
  get asTsv() {
    return this.toDelimited("\t")
  }
  get nodeBreakSymbol() {
    return "\n"
  }
  get wordBreakSymbol() {
    return " "
  }
  get edgeSymbolRegex() {
    return new RegExp(this.edgeSymbol, "g")
  }
  get nodeBreakSymbolRegex() {
    return new RegExp(this.nodeBreakSymbol, "g")
  }
  get edgeSymbol() {
    return " "
  }
  _textToContentAndChildrenTuple(text) {
    const lines = text.split(this.nodeBreakSymbolRegex)
    const firstLine = lines.shift()
    const children = !lines.length
      ? undefined
      : lines
          .map(line => (line.substr(0, 1) === this.edgeSymbol ? line : this.edgeSymbol + line))
          .map(line => line.substr(1))
          .join(this.nodeBreakSymbol)
    return [firstLine, children]
  }
  _getLine() {
    return this._line
  }
  _setLine(line = "") {
    this._line = line
    if (this._words) delete this._words
    return this
  }
  _clearChildren() {
    this._deleteByIndexes(Utils.getRange(0, this.length))
    delete this._children
    return this
  }
  _setChildren(content, circularCheckArray) {
    this._clearChildren()
    if (!content) return this
    // set from string
    if (typeof content === "string") {
      this._appendChildrenFromString(content)
      return this
    }
    // set from tree object
    if (content instanceof TreeNode) {
      content.forEach(node => this._insertLineAndChildren(node.getLine(), node.childrenToString()))
      return this
    }
    // If we set from object, create an array of inserted objects to avoid circular loops
    if (!circularCheckArray) circularCheckArray = [content]
    return this._setFromObject(content, circularCheckArray)
  }
  _setFromObject(content, circularCheckArray) {
    for (let firstWord in content) {
      if (!content.hasOwnProperty(firstWord)) continue
      // Branch the circularCheckArray, as we only have same branch circular arrays
      this._appendFromJavascriptObjectTuple(firstWord, content[firstWord], circularCheckArray.slice(0))
    }
    return this
  }
  // todo: refactor the below.
  _appendFromJavascriptObjectTuple(firstWord, content, circularCheckArray) {
    const type = typeof content
    let line
    let children
    if (content === null) line = firstWord + " " + null
    else if (content === undefined) line = firstWord
    else if (type === "string") {
      const tuple = this._textToContentAndChildrenTuple(content)
      line = firstWord + " " + tuple[0]
      children = tuple[1]
    } else if (type === "function") line = firstWord + " " + content.toString()
    else if (type !== "object") line = firstWord + " " + content
    else if (content instanceof Date) line = firstWord + " " + content.getTime().toString()
    else if (content instanceof TreeNode) {
      line = firstWord
      children = new TreeNode(content.childrenToString(), content.getLine())
    } else if (circularCheckArray.indexOf(content) === -1) {
      circularCheckArray.push(content)
      line = firstWord
      const length = content instanceof Array ? content.length : Object.keys(content).length
      if (length) children = new TreeNode()._setChildren(content, circularCheckArray)
    } else {
      // iirc this is return early from circular
      return
    }
    this._insertLineAndChildren(line, children)
  }
  _insertLineAndChildren(line, children, index = this.length) {
    const parser = this._getParser()._getParser(line, this)
    const newNode = new parser(children, line, this)
    const adjustedIndex = index < 0 ? this.length + index : index
    this._getChildrenArray().splice(adjustedIndex, 0, newNode)
    if (this._index) this._makeIndex(adjustedIndex)
    this.clearQuickCache()
    return newNode
  }
  _appendChildrenFromString(str) {
    const lines = str.split(this.nodeBreakSymbolRegex)
    const parentStack = []
    let currentIndentCount = -1
    let lastNode = this
    lines.forEach(line => {
      const indentCount = this._getIndentCount(line)
      if (indentCount > currentIndentCount) {
        currentIndentCount++
        parentStack.push(lastNode)
      } else if (indentCount < currentIndentCount) {
        // pop things off stack
        while (indentCount < currentIndentCount) {
          parentStack.pop()
          currentIndentCount--
        }
      }
      const lineContent = line.substr(currentIndentCount)
      const parent = parentStack[parentStack.length - 1]
      const parser = parent._getParser()._getParser(lineContent, parent)
      lastNode = new parser(undefined, lineContent, parent)
      parent._getChildrenArray().push(lastNode)
    })
  }
  _getIndex() {
    // StringMap<int> {firstWord: index}
    // When there are multiple tails with the same firstWord, _index stores the last content.
    // todo: change the above behavior: when a collision occurs, create an array.
    return this._index || this._makeIndex()
  }
  getContentsArray() {
    return this.map(node => node.content)
  }
  getChildrenByParser(parser) {
    return this.filter(child => child instanceof parser)
  }
  getAncestorByParser(parser) {
    if (this instanceof parser) return this
    if (this.isRoot()) return undefined
    const parent = this.parent
    return parent instanceof parser ? parent : parent.getAncestorByParser(parser)
  }
  getNodeByParser(parser) {
    return this.find(child => child instanceof parser)
  }
  indexOfLast(firstWord) {
    const result = this._getIndex()[firstWord]
    return result === undefined ? -1 : result
  }
  // todo: renmae to indexOfFirst?
  indexOf(firstWord) {
    if (!this.has(firstWord)) return -1
    const length = this.length
    const nodes = this._getChildrenArray()
    for (let index = 0; index < length; index++) {
      if (nodes[index].firstWord === firstWord) return index
    }
  }
  // todo: rename this. it is a particular type of object.
  toObject() {
    return this._toObject()
  }
  getFirstWords() {
    return this.map(node => node.firstWord)
  }
  _makeIndex(startAt = 0) {
    if (!this._index || !startAt) this._index = {}
    const nodes = this._getChildrenArray()
    const newIndex = this._index
    const length = nodes.length
    for (let index = startAt; index < length; index++) {
      newIndex[nodes[index].firstWord] = index
    }
    return newIndex
  }
  _childrenToXml(indentCount) {
    return this.map(node => node._toXml(indentCount)).join("")
  }
  _getIndentCount(str) {
    let level = 0
    const edgeChar = this.edgeSymbol
    while (str[level] === edgeChar) {
      level++
    }
    return level
  }
  clone(children = this.childrenToString(), line = this.getLine()) {
    return new this.constructor(children, line)
  }
  hasFirstWord(firstWord) {
    return this._hasFirstWord(firstWord)
  }
  has(firstWordPath) {
    const edgeSymbol = this.edgeSymbol
    if (!firstWordPath.includes(edgeSymbol)) return this.hasFirstWord(firstWordPath)
    const parts = firstWordPath.split(edgeSymbol)
    const next = this.getNode(parts.shift())
    if (!next) return false
    return next.has(parts.join(edgeSymbol))
  }
  hasNode(node) {
    const needle = node.toString()
    return this.getChildren().some(node => node.toString() === needle)
  }
  _hasFirstWord(firstWord) {
    return this._getIndex()[firstWord] !== undefined
  }
  map(fn) {
    return this.getChildren().map(fn)
  }
  filter(fn = item => item) {
    return this.getChildren().filter(fn)
  }
  find(fn) {
    return this.getChildren().find(fn)
  }
  findLast(fn) {
    return this.getChildren().reverse().find(fn)
  }
  every(fn) {
    let index = 0
    for (let node of this.getTopDownArrayIterator()) {
      if (!fn(node, index)) return false
      index++
    }
    return true
  }
  forEach(fn) {
    this.getChildren().forEach(fn)
    return this
  }
  // Recurse if predicate passes
  deepVisit(predicate) {
    this.forEach(node => {
      if (predicate(node) !== false) node.deepVisit(predicate)
    })
  }
  get quickCache() {
    if (!this._quickCache) this._quickCache = {}
    return this._quickCache
  }
  getCustomIndex(key) {
    if (!this.quickCache.customIndexes) this.quickCache.customIndexes = {}
    const customIndexes = this.quickCache.customIndexes
    if (customIndexes[key]) return customIndexes[key]
    const customIndex = {}
    customIndexes[key] = customIndex
    this.filter(file => file.has(key)).forEach(file => {
      const value = file.get(key)
      if (!customIndex[value]) customIndex[value] = []
      customIndex[value].push(file)
    })
    return customIndex
  }
  clearQuickCache() {
    delete this._quickCache
  }
  // todo: protected?
  _clearIndex() {
    delete this._index
    this.clearQuickCache()
  }
  slice(start, end) {
    return this.getChildren().slice(start, end)
  }
  // todo: make 0 and 1 a param
  getInheritanceTree() {
    const paths = {}
    const result = new TreeNode()
    this.forEach(node => {
      const key = node.getWord(0)
      const parentKey = node.getWord(1)
      const parentPath = paths[parentKey]
      paths[key] = parentPath ? [parentPath, key].join(" ") : key
      result.touchNode(paths[key])
    })
    return result
  }
  _getGrandParent() {
    return this.isRoot() || this.parent.isRoot() ? undefined : this.parent.parent
  }
  _getParser() {
    if (!TreeNode._parserCombinators.has(this.constructor)) TreeNode._parserCombinators.set(this.constructor, this.createParserCombinator())
    return TreeNode._parserCombinators.get(this.constructor)
  }
  createParserCombinator() {
    return new ParserCombinator(this.constructor)
  }
  static _makeUniqueId() {
    if (this._uniqueId === undefined) this._uniqueId = 0
    this._uniqueId++
    return this._uniqueId
  }
  static _getFileFormat(path) {
    const format = path.split(".").pop()
    return FileFormat[format] ? format : FileFormat.tree
  }
  getLineModifiedTime() {
    return this._lineModifiedTime || this._nodeCreationTime
  }
  getChildArrayModifiedTime() {
    return this._childArrayModifiedTime || this._nodeCreationTime
  }
  _setChildArrayMofifiedTime(value) {
    this._childArrayModifiedTime = value
    return this
  }
  getLineOrChildrenModifiedTime() {
    return Math.max(
      this.getLineModifiedTime(),
      this.getChildArrayModifiedTime(),
      Math.max.apply(
        null,
        this.map(child => child.getLineOrChildrenModifiedTime())
      )
    )
  }
  _setVirtualParentTree(tree) {
    this._virtualParentTree = tree
    return this
  }
  _getVirtualParentTreeNode() {
    return this._virtualParentTree
  }
  _setVirtualAncestorNodesByInheritanceViaColumnIndicesAndThenExpand(nodes, thisIdColumnNumber, extendsIdColumnNumber) {
    const map = {}
    for (let node of nodes) {
      const nodeId = node.getWord(thisIdColumnNumber)
      if (map[nodeId]) throw new Error(`Tried to define a node with id "${nodeId}" but one is already defined.`)
      map[nodeId] = {
        nodeId: nodeId,
        node: node,
        parentId: node.getWord(extendsIdColumnNumber)
      }
    }
    // Add parent Nodes
    Object.values(map).forEach(nodeInfo => {
      const parentId = nodeInfo.parentId
      const parentNode = map[parentId]
      if (parentId && !parentNode) throw new Error(`Node "${nodeInfo.nodeId}" tried to extend "${parentId}" but "${parentId}" not found.`)
      if (parentId) nodeInfo.node._setVirtualParentTree(parentNode.node)
    })
    nodes.forEach(node => node._expandFromVirtualParentTree())
    return this
  }
  _expandFromVirtualParentTree() {
    if (this._isVirtualExpanded) return this
    this._isExpanding = true
    let parentNode = this._getVirtualParentTreeNode()
    if (parentNode) {
      if (parentNode._isExpanding) throw new Error(`Loop detected: '${this.getLine()}' is the ancestor of one of its ancestors.`)
      parentNode._expandFromVirtualParentTree()
      const clone = this.clone()
      this._setChildren(parentNode.childrenToString())
      this.extend(clone)
    }
    this._isExpanding = false
    this._isVirtualExpanded = true
  }
  // todo: solve issue related to whether extend should overwrite or append.
  _expandChildren(thisIdColumnNumber, extendsIdColumnNumber, childrenThatNeedExpanding = this.getChildren()) {
    return this._setVirtualAncestorNodesByInheritanceViaColumnIndicesAndThenExpand(childrenThatNeedExpanding, thisIdColumnNumber, extendsIdColumnNumber)
  }
  // todo: add more testing.
  // todo: solve issue with where extend should overwrite or append
  // todo: should take a grammar? to decide whether to overwrite or append.
  // todo: this is slow.
  extend(nodeOrStr) {
    const node = nodeOrStr instanceof TreeNode ? nodeOrStr : new TreeNode(nodeOrStr)
    const usedFirstWords = new Set()
    node.forEach(sourceNode => {
      const firstWord = sourceNode.firstWord
      let targetNode
      const isAnArrayNotMap = usedFirstWords.has(firstWord)
      if (!this.has(firstWord)) {
        usedFirstWords.add(firstWord)
        this.appendLineAndChildren(sourceNode.getLine(), sourceNode.childrenToString())
        return true
      }
      if (isAnArrayNotMap) targetNode = this.appendLine(sourceNode.getLine())
      else {
        targetNode = this.touchNode(firstWord).setContent(sourceNode.content)
        usedFirstWords.add(firstWord)
      }
      if (sourceNode.length) targetNode.extend(sourceNode)
    })
    return this
  }
  lastNode() {
    return this.getChildren()[this.length - 1]
  }
  expandLastFromTopMatter() {
    const clone = this.clone()
    const map = new Map()
    const lastNode = clone.lastNode()
    lastNode.getOlderSiblings().forEach(node => map.set(node.getWord(0), node))
    lastNode.topDownArray.forEach(node => {
      const replacement = map.get(node.getWord(0))
      if (!replacement) return
      node.replaceNode(str => replacement.toString())
    })
    return lastNode
  }
  macroExpand(macroDefinitionWord, macroUsageWord) {
    const clone = this.clone()
    const defs = clone.findNodes(macroDefinitionWord)
    const allUses = clone.findNodes(macroUsageWord)
    const wordBreakSymbol = clone.wordBreakSymbol
    defs.forEach(def => {
      const macroName = def.getWord(1)
      const uses = allUses.filter(node => node.hasWord(1, macroName))
      const params = def.getWordsFrom(2)
      const replaceFn = str => {
        const paramValues = str.split(wordBreakSymbol).slice(2)
        let newTree = def.childrenToString()
        params.forEach((param, index) => {
          newTree = newTree.replace(new RegExp(param, "g"), paramValues[index])
        })
        return newTree
      }
      uses.forEach(node => {
        node.replaceNode(replaceFn)
      })
      def.destroy()
    })
    return clone
  }
  setChildren(children) {
    return this._setChildren(children)
  }
  _updateLineModifiedTimeAndTriggerEvent() {
    this._lineModifiedTime = this._getProcessTimeInMilliseconds()
  }
  insertWord(index, word) {
    const wi = this.wordBreakSymbol
    const words = this._getLine().split(wi)
    words.splice(index, 0, word)
    this.setLine(words.join(wi))
    return this
  }
  deleteDuplicates() {
    const set = new Set()
    this.topDownArray.forEach(node => {
      const str = node.toString()
      if (set.has(str)) node.destroy()
      else set.add(str)
    })
    return this
  }
  setWord(index, word) {
    const wi = this.wordBreakSymbol
    const words = this._getLine().split(wi)
    words[index] = word
    this.setLine(words.join(wi))
    return this
  }
  deleteChildren() {
    return this._clearChildren()
  }
  setContent(content) {
    if (content === this.content) return this
    const newArray = [this.firstWord]
    if (content !== undefined) {
      content = content.toString()
      if (content.match(this.nodeBreakSymbol)) return this.setContentWithChildren(content)
      newArray.push(content)
    }
    this._setLine(newArray.join(this.wordBreakSymbol))
    this._updateLineModifiedTimeAndTriggerEvent()
    return this
  }
  prependSibling(line, children) {
    return this.parent.insertLineAndChildren(line, children, this.getIndex())
  }
  appendSibling(line, children) {
    return this.parent.insertLineAndChildren(line, children, this.getIndex() + 1)
  }
  setContentWithChildren(text) {
    // todo: deprecate
    if (!text.includes(this.nodeBreakSymbol)) {
      this._clearChildren()
      return this.setContent(text)
    }
    const lines = text.split(this.nodeBreakSymbolRegex)
    const firstLine = lines.shift()
    this.setContent(firstLine)
    // tood: cleanup.
    const remainingString = lines.join(this.nodeBreakSymbol)
    const children = new TreeNode(remainingString)
    if (!remainingString) children.appendLine("")
    this.setChildren(children)
    return this
  }
  setFirstWord(firstWord) {
    return this.setWord(0, firstWord)
  }
  setLine(line) {
    if (line === this.getLine()) return this
    // todo: clear parent TMTimes
    this.parent._clearIndex()
    this._setLine(line)
    this._updateLineModifiedTimeAndTriggerEvent()
    return this
  }
  duplicate() {
    return this.parent._insertLineAndChildren(this.getLine(), this.childrenToString(), this.getIndex() + 1)
  }
  trim() {
    // todo: could do this so only the trimmed rows are deleted.
    this.setChildren(this.childrenToString().trim())
    return this
  }
  destroy() {
    this.parent._deleteNode(this)
  }
  set(firstWordPath, text) {
    return this.touchNode(firstWordPath).setContentWithChildren(text)
  }
  setFromText(text) {
    if (this.toString() === text) return this
    const tuple = this._textToContentAndChildrenTuple(text)
    this.setLine(tuple[0])
    return this._setChildren(tuple[1])
  }
  setPropertyIfMissing(prop, value) {
    if (this.has(prop)) return true
    return this.touchNode(prop).setContent(value)
  }
  setProperties(propMap) {
    const props = Object.keys(propMap)
    const values = Object.values(propMap)
    // todo: is there a built in tree method to do this?
    props.forEach((prop, index) => {
      const value = values[index]
      if (!value) return true
      if (this.get(prop) === value) return true
      this.touchNode(prop).setContent(value)
    })
    return this
  }
  // todo: throw error if line contains a \n
  appendLine(line) {
    return this._insertLineAndChildren(line)
  }
  appendUniqueLine(line) {
    if (!this.hasLine(line)) return this.appendLine(line)
    return this.findLine(line)
  }
  appendLineAndChildren(line, children) {
    return this._insertLineAndChildren(line, children)
  }
  getNodesByRegex(regex) {
    const matches = []
    regex = regex instanceof RegExp ? [regex] : regex
    this._getNodesByLineRegex(matches, regex)
    return matches
  }
  // todo: remove?
  getNodesByLinePrefixes(columns) {
    const matches = []
    this._getNodesByLineRegex(
      matches,
      columns.map(str => new RegExp("^" + str))
    )
    return matches
  }
  nodesThatStartWith(prefix) {
    return this.filter(node => node.getLine().startsWith(prefix))
  }
  _getNodesByLineRegex(matches, regs) {
    const rgs = regs.slice(0)
    const reg = rgs.shift()
    const candidates = this.filter(child => child.getLine().match(reg))
    if (!rgs.length) return candidates.forEach(cand => matches.push(cand))
    candidates.forEach(cand => cand._getNodesByLineRegex(matches, rgs))
  }
  concat(node) {
    if (typeof node === "string") node = new TreeNode(node)
    return node.map(node => this._insertLineAndChildren(node.getLine(), node.childrenToString()))
  }
  _deleteByIndexes(indexesToDelete) {
    if (!indexesToDelete.length) return this
    this._clearIndex()
    // note: assumes indexesToDelete is in ascending order
    const deletedNodes = indexesToDelete.reverse().map(index => this._getChildrenArray().splice(index, 1)[0])
    this._setChildArrayMofifiedTime(this._getProcessTimeInMilliseconds())
    return this
  }
  _deleteNode(node) {
    const index = this._indexOfNode(node)
    return index > -1 ? this._deleteByIndexes([index]) : 0
  }
  reverse() {
    this._clearIndex()
    this._getChildrenArray().reverse()
    return this
  }
  shift() {
    if (!this.length) return null
    const node = this._getChildrenArray().shift()
    return node.copyTo(new this.constructor(), 0)
  }
  sort(fn) {
    this._getChildrenArray().sort(fn)
    this._clearIndex()
    return this
  }
  invert() {
    this.forEach(node => node.words.reverse())
    return this
  }
  _rename(oldFirstWord, newFirstWord) {
    const index = this.indexOf(oldFirstWord)
    if (index === -1) return this
    const node = this._getChildrenArray()[index]
    node.setFirstWord(newFirstWord)
    this._clearIndex()
    return this
  }
  // Does not recurse.
  remap(map) {
    this.forEach(node => {
      const firstWord = node.firstWord
      if (map[firstWord] !== undefined) node.setFirstWord(map[firstWord])
    })
    return this
  }
  rename(oldFirstWord, newFirstWord) {
    this._rename(oldFirstWord, newFirstWord)
    return this
  }
  renameAll(oldName, newName) {
    this.findNodes(oldName).forEach(node => node.setFirstWord(newName))
    return this
  }
  _deleteAllChildNodesWithFirstWord(firstWord) {
    if (!this.has(firstWord)) return this
    const allNodes = this._getChildrenArray()
    const indexesToDelete = []
    allNodes.forEach((node, index) => {
      if (node.firstWord === firstWord) indexesToDelete.push(index)
    })
    return this._deleteByIndexes(indexesToDelete)
  }
  delete(path = "") {
    const edgeSymbol = this.edgeSymbol
    if (!path.includes(edgeSymbol)) return this._deleteAllChildNodesWithFirstWord(path)
    const parts = path.split(edgeSymbol)
    const nextFirstWord = parts.pop()
    const targetNode = this.getNode(parts.join(edgeSymbol))
    return targetNode ? targetNode._deleteAllChildNodesWithFirstWord(nextFirstWord) : 0
  }
  deleteColumn(firstWord = "") {
    this.forEach(node => node.delete(firstWord))
    return this
  }
  _getNonMaps() {
    const results = this.topDownArray.filter(node => node.hasDuplicateFirstWords())
    if (this.hasDuplicateFirstWords()) results.unshift(this)
    return results
  }
  replaceNode(fn) {
    const parent = this.parent
    const index = this.getIndex()
    const newNodes = new TreeNode(fn(this.toString()))
    const returnedNodes = []
    newNodes.forEach((child, childIndex) => {
      const newNode = parent.insertLineAndChildren(child.getLine(), child.childrenToString(), index + childIndex)
      returnedNodes.push(newNode)
    })
    this.destroy()
    return returnedNodes
  }
  insertLineAndChildren(line, children, index) {
    return this._insertLineAndChildren(line, children, index)
  }
  insertLine(line, index) {
    return this._insertLineAndChildren(line, undefined, index)
  }
  prependLine(line) {
    return this.insertLine(line, 0)
  }
  pushContentAndChildren(content, children) {
    let index = this.length
    while (this.has(index.toString())) {
      index++
    }
    const line = index.toString() + (content === undefined ? "" : this.wordBreakSymbol + content)
    return this.appendLineAndChildren(line, children)
  }
  deleteBlanks() {
    this.getChildren()
      .filter(node => node.isBlankLine())
      .forEach(node => node.destroy())
    return this
  }
  // todo: add "globalReplace" method? Which runs a global regex or string replace on the Tree doc as a string?
  firstWordSort(firstWordOrder) {
    return this._firstWordSort(firstWordOrder)
  }
  deleteWordAt(wordIndex) {
    const words = this.words
    words.splice(wordIndex, 1)
    return this.setWords(words)
  }
  trigger(event) {
    if (this._listeners && this._listeners.has(event.constructor)) {
      const listeners = this._listeners.get(event.constructor)
      const listenersToRemove = []
      for (let index = 0; index < listeners.length; index++) {
        const listener = listeners[index]
        if (listener(event) === true) listenersToRemove.push(index)
      }
      listenersToRemove.reverse().forEach(index => listenersToRemove.splice(index, 1))
    }
  }
  triggerAncestors(event) {
    if (this.isRoot()) return
    const parent = this.parent
    parent.trigger(event)
    parent.triggerAncestors(event)
  }
  onLineChanged(eventHandler) {
    return this._addEventListener(LineChangedTreeEvent, eventHandler)
  }
  onDescendantChanged(eventHandler) {
    return this._addEventListener(DescendantChangedTreeEvent, eventHandler)
  }
  onChildAdded(eventHandler) {
    return this._addEventListener(ChildAddedTreeEvent, eventHandler)
  }
  onChildRemoved(eventHandler) {
    return this._addEventListener(ChildRemovedTreeEvent, eventHandler)
  }
  _addEventListener(eventClass, eventHandler) {
    if (!this._listeners) this._listeners = new Map()
    if (!this._listeners.has(eventClass)) this._listeners.set(eventClass, [])
    this._listeners.get(eventClass).push(eventHandler)
    return this
  }
  setWords(words) {
    return this.setLine(words.join(this.wordBreakSymbol))
  }
  setWordsFrom(index, words) {
    this.setWords(this.words.slice(0, index).concat(words))
    return this
  }
  appendWord(word) {
    const words = this.words
    words.push(word)
    return this.setWords(words)
  }
  _firstWordSort(firstWordOrder, secondarySortFn) {
    const nodeAFirst = -1
    const nodeBFirst = 1
    const map = {}
    firstWordOrder.forEach((word, index) => {
      map[word] = index
    })
    this.sort((nodeA, nodeB) => {
      const valA = map[nodeA.firstWord]
      const valB = map[nodeB.firstWord]
      if (valA > valB) return nodeBFirst
      if (valA < valB) return nodeAFirst
      return secondarySortFn ? secondarySortFn(nodeA, nodeB) : 0
    })
    return this
  }
  _touchNode(firstWordPathArray) {
    let contextNode = this
    firstWordPathArray.forEach(firstWord => {
      contextNode = contextNode.getNode(firstWord) || contextNode.appendLine(firstWord)
    })
    return contextNode
  }
  _touchNodeByString(str) {
    str = str.replace(this.nodeBreakSymbolRegex, "") // todo: do we want to do this sanitization?
    return this._touchNode(str.split(this.wordBreakSymbol))
  }
  touchNode(str) {
    return this._touchNodeByString(str)
  }
  appendNode(node) {
    return this.appendLineAndChildren(node.getLine(), node.childrenToString())
  }
  hasLine(line) {
    return this.getChildren().some(node => node.getLine() === line)
  }
  findLine(line) {
    return this.getChildren().find(node => node.getLine() === line)
  }
  getNodesByLine(line) {
    return this.filter(node => node.getLine() === line)
  }
  toggleLine(line) {
    const lines = this.getNodesByLine(line)
    if (lines.length) {
      lines.map(line => line.destroy())
      return this
    }
    return this.appendLine(line)
  }
  // todo: remove?
  sortByColumns(indexOrIndices) {
    const indices = indexOrIndices instanceof Array ? indexOrIndices : [indexOrIndices]
    const length = indices.length
    this.sort((nodeA, nodeB) => {
      const wordsA = nodeA.words
      const wordsB = nodeB.words
      for (let index = 0; index < length; index++) {
        const col = indices[index]
        const av = wordsA[col]
        const bv = wordsB[col]
        if (av === undefined) return -1
        if (bv === undefined) return 1
        if (av > bv) return 1
        else if (av < bv) return -1
      }
      return 0
    })
    return this
  }
  getWordsAsSet() {
    return new Set(this.getWordsFrom(1))
  }
  appendWordIfMissing(word) {
    if (this.getWordsAsSet().has(word)) return this
    return this.appendWord(word)
  }
  // todo: check to ensure identical objects
  addObjectsAsDelimited(arrayOfObjects, delimiter = Utils._chooseDelimiter(new TreeNode(arrayOfObjects).toString())) {
    const header = Object.keys(arrayOfObjects[0])
      .join(delimiter)
      .replace(/[\n\r]/g, "")
    const rows = arrayOfObjects.map(item =>
      Object.values(item)
        .join(delimiter)
        .replace(/[\n\r]/g, "")
    )
    return this.addUniqueRowsToNestedDelimited(header, rows)
  }
  setChildrenAsDelimited(tree, delimiter = Utils._chooseDelimiter(tree.toString())) {
    tree = tree instanceof TreeNode ? tree : new TreeNode(tree)
    return this.setChildren(tree.toDelimited(delimiter))
  }
  convertChildrenToDelimited(delimiter = Utils._chooseDelimiter(this.childrenToString())) {
    // todo: handle newlines!!!
    return this.setChildren(this.toDelimited(delimiter))
  }
  addUniqueRowsToNestedDelimited(header, rowsAsStrings) {
    if (!this.length) this.appendLine(header)
    // todo: this looks brittle
    rowsAsStrings.forEach(row => {
      if (!this.toString().includes(row)) this.appendLine(row)
    })
    return this
  }
  shiftLeft() {
    const grandParent = this._getGrandParent()
    if (!grandParent) return this
    const parentIndex = this.parent.getIndex()
    const newNode = grandParent.insertLineAndChildren(this.getLine(), this.length ? this.childrenToString() : undefined, parentIndex + 1)
    this.destroy()
    return newNode
  }
  pasteText(text) {
    const parent = this.parent
    const index = this.getIndex()
    const newNodes = new TreeNode(text)
    const firstNode = newNodes.nodeAt(0)
    if (firstNode) {
      this.setLine(firstNode.getLine())
      if (firstNode.length) this.setChildren(firstNode.childrenToString())
    } else {
      this.setLine("")
    }
    newNodes.forEach((child, childIndex) => {
      if (!childIndex)
        // skip first
        return true
      parent.insertLineAndChildren(child.getLine(), child.childrenToString(), index + childIndex)
    })
    return this
  }
  templateToString(obj) {
    // todo: compile/cache for perf?
    const tree = this.clone()
    tree.topDownArray.forEach(node => {
      const line = node.getLine().replace(/{([^\}]+)}/g, (match, path) => {
        const replacement = obj[path]
        if (replacement === undefined) throw new Error(`In string template no match found on line "${node.getLine()}"`)
        return replacement
      })
      node.pasteText(line)
    })
    return tree.toString()
  }
  shiftRight() {
    const olderSibling = this._getClosestOlderSibling()
    if (!olderSibling) return this
    const newNode = olderSibling.appendLineAndChildren(this.getLine(), this.length ? this.childrenToString() : undefined)
    this.destroy()
    return newNode
  }
  shiftYoungerSibsRight() {
    const nodes = this.getYoungerSiblings()
    nodes.forEach(node => node.shiftRight())
    return this
  }
  sortBy(nameOrNames) {
    const names = nameOrNames instanceof Array ? nameOrNames : [nameOrNames]
    const length = names.length
    this.sort((nodeA, nodeB) => {
      if (!nodeB.length && !nodeA.length) return 0
      else if (!nodeA.length) return -1
      else if (!nodeB.length) return 1
      for (let index = 0; index < length; index++) {
        const firstWord = names[index]
        const av = nodeA.get(firstWord)
        const bv = nodeB.get(firstWord)
        if (av > bv) return 1
        else if (av < bv) return -1
      }
      return 0
    })
    return this
  }
  selectNode() {
    this._selected = true
  }
  unselectNode() {
    delete this._selected
  }
  isSelected() {
    return !!this._selected
  }
  async saveVersion() {
    const newVersion = this.toString()
    const topUndoVersion = this._getTopUndoVersion()
    if (newVersion === topUndoVersion) return undefined
    this._recordChange(newVersion)
    this._setSavedVersion(this.toString())
    return this
  }
  hasUnsavedChanges() {
    return this.toString() !== this._getSavedVersion()
  }
  async redo() {
    const undoStack = this._getUndoStack()
    const redoStack = this._getRedoStack()
    if (!redoStack.length) return undefined
    undoStack.push(redoStack.pop())
    return this._reloadFromUndoTop()
  }
  async undo() {
    const undoStack = this._getUndoStack()
    const redoStack = this._getRedoStack()
    if (undoStack.length === 1) return undefined
    redoStack.push(undoStack.pop())
    return this._reloadFromUndoTop()
  }
  _getSavedVersion() {
    return this._savedVersion
  }
  _setSavedVersion(str) {
    this._savedVersion = str
    return this
  }
  _clearRedoStack() {
    const redoStack = this._getRedoStack()
    redoStack.splice(0, redoStack.length)
  }
  getChangeHistory() {
    return this._getUndoStack().slice(0)
  }
  _getUndoStack() {
    if (!this._undoStack) this._undoStack = []
    return this._undoStack
  }
  _getRedoStack() {
    if (!this._redoStack) this._redoStack = []
    return this._redoStack
  }
  _getTopUndoVersion() {
    const undoStack = this._getUndoStack()
    return undoStack[undoStack.length - 1]
  }
  async _reloadFromUndoTop() {
    this.setChildren(this._getTopUndoVersion())
  }
  _recordChange(newVersion) {
    this._clearRedoStack()
    this._getUndoStack().push(newVersion) // todo: use diffs?
  }
  static fromCsv(str) {
    return this.fromDelimited(str, ",", '"')
  }
  // todo: jeez i think we can come up with a better name than "JsonSubset"
  static fromJsonSubset(str) {
    return new TreeNode(JSON.parse(str))
  }
  static serializedTreeNodeToTree(treeNode) {
    const language = new TreeNode()
    const cellDelimiter = language.wordBreakSymbol
    const nodeDelimiter = language.nodeBreakSymbol
    const line = treeNode.cells ? treeNode.cells.join(cellDelimiter) : undefined
    const tree = new TreeNode(undefined, line)
    if (treeNode.children)
      treeNode.children.forEach(child => {
        tree.appendNode(this.serializedTreeNodeToTree(child))
      })
    return tree
  }
  static fromJson(str) {
    return this.serializedTreeNodeToTree(JSON.parse(str))
  }
  static fromGridJson(str) {
    const lines = JSON.parse(str)
    const language = new TreeNode()
    const cellDelimiter = language.wordBreakSymbol
    const nodeDelimiter = language.nodeBreakSymbol
    return new TreeNode(lines.map(line => line.join(cellDelimiter)).join(nodeDelimiter))
  }
  static fromSsv(str) {
    return this.fromDelimited(str, " ", '"')
  }
  static fromTsv(str) {
    return this.fromDelimited(str, "\t", '"')
  }
  static fromDelimited(str, delimiter, quoteChar = '"') {
    str = str.replace(/\r/g, "") // remove windows newlines if present
    const rows = this._getEscapedRows(str, delimiter, quoteChar)
    return this._rowsToTreeNode(rows, delimiter, true)
  }
  static _getEscapedRows(str, delimiter, quoteChar) {
    return str.includes(quoteChar) ? this._strToRows(str, delimiter, quoteChar) : str.split("\n").map(line => line.split(delimiter))
  }
  static fromDelimitedNoHeaders(str, delimiter, quoteChar) {
    str = str.replace(/\r/g, "") // remove windows newlines if present
    const rows = this._getEscapedRows(str, delimiter, quoteChar)
    return this._rowsToTreeNode(rows, delimiter, false)
  }
  static _strToRows(str, delimiter, quoteChar, newLineChar = "\n") {
    const rows = [[]]
    const newLine = "\n"
    const length = str.length
    let currentCell = ""
    let inQuote = str.substr(0, 1) === quoteChar
    let currentPosition = inQuote ? 1 : 0
    let nextChar
    let isLastChar
    let currentRow = 0
    let char
    let isNextCharAQuote
    while (currentPosition < length) {
      char = str[currentPosition]
      isLastChar = currentPosition + 1 === length
      nextChar = str[currentPosition + 1]
      isNextCharAQuote = nextChar === quoteChar
      if (inQuote) {
        if (char !== quoteChar) currentCell += char
        else if (isNextCharAQuote) {
          // Both the current and next char are ", so the " is escaped
          currentCell += nextChar
          currentPosition++ // Jump 2
        } else {
          // If the current char is a " and the next char is not, it's the end of the quotes
          inQuote = false
          if (isLastChar) rows[currentRow].push(currentCell)
        }
      } else {
        if (char === delimiter) {
          rows[currentRow].push(currentCell)
          currentCell = ""
          if (isNextCharAQuote) {
            inQuote = true
            currentPosition++ // Jump 2
          }
        } else if (char === newLine) {
          rows[currentRow].push(currentCell)
          currentCell = ""
          currentRow++
          if (nextChar) rows[currentRow] = []
          if (isNextCharAQuote) {
            inQuote = true
            currentPosition++ // Jump 2
          }
        } else if (isLastChar) rows[currentRow].push(currentCell + char)
        else currentCell += char
      }
      currentPosition++
    }
    return rows
  }
  static multiply(nodeA, nodeB) {
    const productNode = nodeA.clone()
    productNode.forEach((node, index) => {
      node.setChildren(node.length ? this.multiply(node, nodeB) : nodeB.clone())
    })
    return productNode
  }
  // Given an array return a tree
  static _rowsToTreeNode(rows, delimiter, hasHeaders) {
    const numberOfColumns = rows[0].length
    const treeNode = new TreeNode()
    const names = this._getHeader(rows, hasHeaders)
    const rowCount = rows.length
    for (let rowIndex = hasHeaders ? 1 : 0; rowIndex < rowCount; rowIndex++) {
      let row = rows[rowIndex]
      // If the row contains too many columns, shift the extra columns onto the last one.
      // This allows you to not have to escape delimiter characters in the final column.
      if (row.length > numberOfColumns) {
        row[numberOfColumns - 1] = row.slice(numberOfColumns - 1).join(delimiter)
        row = row.slice(0, numberOfColumns)
      } else if (row.length < numberOfColumns) {
        // If the row is missing columns add empty columns until it is full.
        // This allows you to make including delimiters for empty ending columns in each row optional.
        while (row.length < numberOfColumns) {
          row.push("")
        }
      }
      const obj = {}
      row.forEach((cellValue, index) => {
        obj[names[index]] = cellValue
      })
      treeNode.pushContentAndChildren(undefined, obj)
    }
    return treeNode
  }
  static _initializeXmlParser() {
    if (this._xmlParser) return
    const windowObj = window
    if (typeof windowObj.DOMParser !== "undefined") this._xmlParser = xmlStr => new windowObj.DOMParser().parseFromString(xmlStr, "text/xml")
    else if (typeof windowObj.ActiveXObject !== "undefined" && new windowObj.ActiveXObject("Microsoft.XMLDOM")) {
      this._xmlParser = xmlStr => {
        const xmlDoc = new windowObj.ActiveXObject("Microsoft.XMLDOM")
        xmlDoc.async = "false"
        xmlDoc.loadXML(xmlStr)
        return xmlDoc
      }
    } else throw new Error("No XML parser found")
  }
  static fromXml(str) {
    this._initializeXmlParser()
    const xml = this._xmlParser(str)
    try {
      return this._treeNodeFromXml(xml).getNode("children")
    } catch (err) {
      return this._treeNodeFromXml(this._parseXml2(str)).getNode("children")
    }
  }
  static _zipObject(keys, values) {
    const obj = {}
    keys.forEach((key, index) => (obj[key] = values[index]))
    return obj
  }
  static fromShape(shapeArr, rootNode = new TreeNode()) {
    const part = shapeArr.shift()
    if (part !== undefined) {
      for (let index = 0; index < part; index++) {
        rootNode.appendLine(index.toString())
      }
    }
    if (shapeArr.length) rootNode.forEach(node => TreeNode.fromShape(shapeArr.slice(0), node))
    return rootNode
  }
  static fromDataTable(table) {
    const header = table.shift()
    return new TreeNode(table.map(row => this._zipObject(header, row)))
  }
  static _parseXml2(str) {
    const el = document.createElement("div")
    el.innerHTML = str
    return el
  }
  // todo: cleanup typings
  static _treeNodeFromXml(xml) {
    const result = new TreeNode()
    const children = new TreeNode()
    // Set attributes
    if (xml.attributes) {
      for (let index = 0; index < xml.attributes.length; index++) {
        result.set(xml.attributes[index].name, xml.attributes[index].value)
      }
    }
    if (xml.data) children.pushContentAndChildren(xml.data)
    // Set content
    if (xml.childNodes && xml.childNodes.length > 0) {
      for (let index = 0; index < xml.childNodes.length; index++) {
        const child = xml.childNodes[index]
        if (child.tagName && child.tagName.match(/parsererror/i)) throw new Error("Parse Error")
        if (child.childNodes.length > 0 && child.tagName) children.appendLineAndChildren(child.tagName, this._treeNodeFromXml(child))
        else if (child.tagName) children.appendLine(child.tagName)
        else if (child.data) {
          const data = child.data.trim()
          if (data) children.pushContentAndChildren(data)
        }
      }
    }
    if (children.length > 0) result.touchNode("children").setChildren(children)
    return result
  }
  static _getHeader(rows, hasHeaders) {
    const numberOfColumns = rows[0].length
    const headerRow = hasHeaders ? rows[0] : []
    const WordBreakSymbol = " "
    const ziRegex = new RegExp(WordBreakSymbol, "g")
    if (hasHeaders) {
      // Strip any WordBreakSymbols from column names in the header row.
      // This makes the mapping not quite 1 to 1 if there are any WordBreakSymbols in names.
      for (let index = 0; index < numberOfColumns; index++) {
        headerRow[index] = headerRow[index].replace(ziRegex, "")
      }
    } else {
      // If str has no headers, create them as 0,1,2,3
      for (let index = 0; index < numberOfColumns; index++) {
        headerRow.push(index.toString())
      }
    }
    return headerRow
  }
  static nest(str, xValue) {
    const NodeBreakSymbol = "\n"
    const WordBreakSymbol = " "
    const indent = NodeBreakSymbol + WordBreakSymbol.repeat(xValue)
    return str ? indent + str.replace(/\n/g, indent) : ""
  }
  static fromDisk(path) {
    const format = this._getFileFormat(path)
    const content = require("fs").readFileSync(path, "utf8")
    const methods = {
      tree: content => new TreeNode(content),
      csv: content => this.fromCsv(content),
      tsv: content => this.fromTsv(content)
    }
    return methods[format](content)
  }
  static fromFolder(folderPath, filepathPredicate = filepath => filepath !== ".DS_Store") {
    const path = require("path")
    const fs = require("fs")
    const tree = new TreeNode()
    const files = fs
      .readdirSync(folderPath)
      .map(filename => path.join(folderPath, filename))
      .filter(filepath => !fs.statSync(filepath).isDirectory() && filepathPredicate(filepath))
      .forEach(filePath => tree.appendLineAndChildren(filePath, fs.readFileSync(filePath, "utf8")))
    return tree
  }
}
TreeNode._parserCombinators = new Map()
TreeNode.ParserCombinator = ParserCombinator
TreeNode.iris = `sepal_length,sepal_width,petal_length,petal_width,species
6.1,3,4.9,1.8,virginica
5.6,2.7,4.2,1.3,versicolor
5.6,2.8,4.9,2,virginica
6.2,2.8,4.8,1.8,virginica
7.7,3.8,6.7,2.2,virginica
5.3,3.7,1.5,0.2,setosa
6.2,3.4,5.4,2.3,virginica
4.9,2.5,4.5,1.7,virginica
5.1,3.5,1.4,0.2,setosa
5,3.4,1.5,0.2,setosa`
TreeNode.getVersion = () => "75.1.1"
class AbstractExtendibleTreeNode extends TreeNode {
  _getFromExtended(firstWordPath) {
    const hit = this._getNodeFromExtended(firstWordPath)
    return hit ? hit.get(firstWordPath) : undefined
  }
  _getFamilyTree() {
    const tree = new TreeNode()
    this.forEach(node => {
      const path = node._getAncestorsArray().map(node => node.id)
      path.reverse()
      tree.touchNode(path.join(" "))
    })
    return tree
  }
  // todo: be more specific with the param
  _getChildrenByParserInExtended(parser) {
    return Utils.flatten(this._getAncestorsArray().map(node => node.getChildrenByParser(parser)))
  }
  _getExtendedParent() {
    return this._getAncestorsArray()[1]
  }
  _hasFromExtended(firstWordPath) {
    return !!this._getNodeFromExtended(firstWordPath)
  }
  _getNodeFromExtended(firstWordPath) {
    return this._getAncestorsArray().find(node => node.has(firstWordPath))
  }
  _getConcatBlockStringFromExtended(firstWordPath) {
    return this._getAncestorsArray()
      .filter(node => node.has(firstWordPath))
      .map(node => node.getNode(firstWordPath).childrenToString())
      .reverse()
      .join("\n")
  }
  _doesExtend(parserId) {
    return this._getAncestorSet().has(parserId)
  }
  _getAncestorSet() {
    if (!this._cache_ancestorSet) this._cache_ancestorSet = new Set(this._getAncestorsArray().map(def => def.id))
    return this._cache_ancestorSet
  }
  // Note: the order is: [this, parent, grandParent, ...]
  _getAncestorsArray(cannotContainNodes) {
    this._initAncestorsArrayCache(cannotContainNodes)
    return this._cache_ancestorsArray
  }
  get idThatThisExtends() {
    return this.get(TreeNotationConstants.extends)
  }
  _initAncestorsArrayCache(cannotContainNodes) {
    if (this._cache_ancestorsArray) return undefined
    if (cannotContainNodes && cannotContainNodes.includes(this)) throw new Error(`Loop detected: '${this.getLine()}' is the ancestor of one of its ancestors.`)
    cannotContainNodes = cannotContainNodes || [this]
    let ancestors = [this]
    const extendedId = this.idThatThisExtends
    if (extendedId) {
      const parentNode = this.idToNodeMap[extendedId]
      if (!parentNode) throw new Error(`${extendedId} not found`)
      ancestors = ancestors.concat(parentNode._getAncestorsArray(cannotContainNodes))
    }
    this._cache_ancestorsArray = ancestors
  }
}
class ExtendibleTreeNode extends AbstractExtendibleTreeNode {
  get idToNodeMap() {
    if (!this.isRoot()) return this.root.idToNodeMap
    if (!this._nodeMapCache) {
      this._nodeMapCache = {}
      this.forEach(child => {
        this._nodeMapCache[child.id] = child
      })
    }
    return this._nodeMapCache
  }
  get id() {
    return this.getWord(0)
  }
}
window.TreeNode = TreeNode
window.ExtendibleTreeNode = ExtendibleTreeNode
window.AbstractExtendibleTreeNode = AbstractExtendibleTreeNode
window.TreeEvents = TreeEvents
window.TreeWord = TreeWord
;

// Compiled language parsers will include these files:
const GlobalNamespaceAdditions = {
  Utils: "Utils.js",
  TreeNode: "TreeNode.js",
  HandGrammarProgram: "GrammarLanguage.js",
  GrammarBackedNode: "GrammarLanguage.js"
}
var GrammarConstantsCompiler
;(function (GrammarConstantsCompiler) {
  GrammarConstantsCompiler["stringTemplate"] = "stringTemplate"
  GrammarConstantsCompiler["indentCharacter"] = "indentCharacter"
  GrammarConstantsCompiler["catchAllCellDelimiter"] = "catchAllCellDelimiter"
  GrammarConstantsCompiler["openChildren"] = "openChildren"
  GrammarConstantsCompiler["joinChildrenWith"] = "joinChildrenWith"
  GrammarConstantsCompiler["closeChildren"] = "closeChildren"
})(GrammarConstantsCompiler || (GrammarConstantsCompiler = {}))
var GrammarConstantsMisc
;(function (GrammarConstantsMisc) {
  GrammarConstantsMisc["doNotSynthesize"] = "doNotSynthesize"
})(GrammarConstantsMisc || (GrammarConstantsMisc = {}))
var PreludeCellTypeIds
;(function (PreludeCellTypeIds) {
  PreludeCellTypeIds["anyCell"] = "anyCell"
  PreludeCellTypeIds["keywordCell"] = "keywordCell"
  PreludeCellTypeIds["extraWordCell"] = "extraWordCell"
  PreludeCellTypeIds["floatCell"] = "floatCell"
  PreludeCellTypeIds["numberCell"] = "numberCell"
  PreludeCellTypeIds["bitCell"] = "bitCell"
  PreludeCellTypeIds["boolCell"] = "boolCell"
  PreludeCellTypeIds["intCell"] = "intCell"
})(PreludeCellTypeIds || (PreludeCellTypeIds = {}))
var GrammarConstantsConstantTypes
;(function (GrammarConstantsConstantTypes) {
  GrammarConstantsConstantTypes["boolean"] = "boolean"
  GrammarConstantsConstantTypes["string"] = "string"
  GrammarConstantsConstantTypes["int"] = "int"
  GrammarConstantsConstantTypes["float"] = "float"
})(GrammarConstantsConstantTypes || (GrammarConstantsConstantTypes = {}))
var GrammarBundleFiles
;(function (GrammarBundleFiles) {
  GrammarBundleFiles["package"] = "package.json"
  GrammarBundleFiles["readme"] = "readme.md"
  GrammarBundleFiles["indexHtml"] = "index.html"
  GrammarBundleFiles["indexJs"] = "index.js"
  GrammarBundleFiles["testJs"] = "test.js"
})(GrammarBundleFiles || (GrammarBundleFiles = {}))
var GrammarCellParser
;(function (GrammarCellParser) {
  GrammarCellParser["prefix"] = "prefix"
  GrammarCellParser["postfix"] = "postfix"
  GrammarCellParser["omnifix"] = "omnifix"
})(GrammarCellParser || (GrammarCellParser = {}))
var GrammarConstants
;(function (GrammarConstants) {
  // node types
  GrammarConstants["extensions"] = "extensions"
  GrammarConstants["comment"] = "//"
  GrammarConstants["version"] = "version"
  GrammarConstants["parser"] = "parser"
  GrammarConstants["cellType"] = "cellType"
  GrammarConstants["grammarFileExtension"] = "grammar"
  GrammarConstants["abstractParserPrefix"] = "abstract"
  GrammarConstants["parserSuffix"] = "Parser"
  GrammarConstants["cellTypeSuffix"] = "Cell"
  // error check time
  GrammarConstants["regex"] = "regex"
  GrammarConstants["reservedWords"] = "reservedWords"
  GrammarConstants["enumFromCellTypes"] = "enumFromCellTypes"
  GrammarConstants["enum"] = "enum"
  GrammarConstants["examples"] = "examples"
  GrammarConstants["min"] = "min"
  GrammarConstants["max"] = "max"
  // baseParsers
  GrammarConstants["baseParser"] = "baseParser"
  GrammarConstants["blobParser"] = "blobParser"
  GrammarConstants["errorParser"] = "errorParser"
  // parse time
  GrammarConstants["extends"] = "extends"
  GrammarConstants["root"] = "root"
  GrammarConstants["crux"] = "crux"
  GrammarConstants["cruxFromId"] = "cruxFromId"
  GrammarConstants["pattern"] = "pattern"
  GrammarConstants["inScope"] = "inScope"
  GrammarConstants["cells"] = "cells"
  GrammarConstants["listDelimiter"] = "listDelimiter"
  GrammarConstants["contentKey"] = "contentKey"
  GrammarConstants["childrenKey"] = "childrenKey"
  GrammarConstants["uniqueFirstWord"] = "uniqueFirstWord"
  GrammarConstants["catchAllCellType"] = "catchAllCellType"
  GrammarConstants["cellParser"] = "cellParser"
  GrammarConstants["catchAllParser"] = "catchAllParser"
  GrammarConstants["constants"] = "constants"
  GrammarConstants["required"] = "required"
  GrammarConstants["single"] = "single"
  GrammarConstants["uniqueLine"] = "uniqueLine"
  GrammarConstants["tags"] = "tags"
  GrammarConstants["_extendsJsClass"] = "_extendsJsClass"
  GrammarConstants["_rootNodeJsHeader"] = "_rootNodeJsHeader"
  // default catchAll parser
  GrammarConstants["BlobParser"] = "BlobParser"
  GrammarConstants["DefaultRootParser"] = "DefaultRootParser"
  // code
  GrammarConstants["javascript"] = "javascript"
  // compile time
  GrammarConstants["compilerParser"] = "compiler"
  GrammarConstants["compilesTo"] = "compilesTo"
  // develop time
  GrammarConstants["description"] = "description"
  GrammarConstants["example"] = "example"
  GrammarConstants["sortTemplate"] = "sortTemplate"
  GrammarConstants["frequency"] = "frequency"
  GrammarConstants["highlightScope"] = "highlightScope"
})(GrammarConstants || (GrammarConstants = {}))
class TypedWord extends TreeWord {
  constructor(node, cellIndex, type) {
    super(node, cellIndex)
    this._type = type
  }
  get type() {
    return this._type
  }
  toString() {
    return this.word + ":" + this.type
  }
}
// todo: can we merge these methods into base TreeNode and ditch this class?
class GrammarBackedNode extends TreeNode {
  get definition() {
    if (this._definition) return this._definition
    this._definition = this.isRoot() ? this.handGrammarProgram : this.parent.definition.getParserDefinitionByParserId(this.constructor.name)
    return this._definition
  }
  get rootGrammarTree() {
    return this.definition.root
  }
  getAutocompleteResults(partialWord, cellIndex) {
    return cellIndex === 0 ? this._getAutocompleteResultsForFirstWord(partialWord) : this._getAutocompleteResultsForCell(partialWord, cellIndex)
  }
  get nodeIndex() {
    // StringMap<int> {firstWord: index}
    // When there are multiple tails with the same firstWord, _index stores the last content.
    // todo: change the above behavior: when a collision occurs, create an array.
    return this._nodeIndex || this._makeNodeIndex()
  }
  _clearIndex() {
    delete this._nodeIndex
    return super._clearIndex()
  }
  _makeIndex(startAt = 0) {
    if (this._nodeIndex) this._makeNodeIndex(startAt)
    return super._makeIndex(startAt)
  }
  _makeNodeIndex(startAt = 0) {
    if (!this._nodeIndex || !startAt) this._nodeIndex = {}
    const nodes = this._getChildrenArray()
    const newIndex = this._nodeIndex
    const length = nodes.length
    for (let index = startAt; index < length; index++) {
      const node = nodes[index]
      const ancestors = Array.from(node.definition._getAncestorSet()).forEach(id => {
        if (!newIndex[id]) newIndex[id] = []
        newIndex[id].push(node)
      })
    }
    return newIndex
  }
  getChildInstancesOfParserId(parserId) {
    return this.nodeIndex[parserId] || []
  }
  doesExtend(parserId) {
    return this.definition._doesExtend(parserId)
  }
  _getErrorParserErrors() {
    return [this.firstWord ? new UnknownParserError(this) : new BlankLineError(this)]
  }
  _getBlobParserCatchAllParser() {
    return BlobParser
  }
  _getAutocompleteResultsForFirstWord(partialWord) {
    const keywordMap = this.definition.firstWordMapWithDefinitions
    let keywords = Object.keys(keywordMap)
    if (partialWord) keywords = keywords.filter(keyword => keyword.includes(partialWord))
    return keywords
      .map(keyword => {
        const def = keywordMap[keyword]
        if (def.suggestInAutocomplete === false) return false
        const description = def.description
        return {
          text: keyword,
          displayText: keyword + (description ? " " + description : "")
        }
      })
      .filter(i => i)
  }
  _getAutocompleteResultsForCell(partialWord, cellIndex) {
    // todo: root should be [] correct?
    const cell = this.parsedCells[cellIndex]
    return cell ? cell.getAutoCompleteWords(partialWord) : []
  }
  // note: this is overwritten by the root node of a runtime grammar program.
  // some of the magic that makes this all work. but maybe there's a better way.
  get handGrammarProgram() {
    if (this.isRoot()) throw new Error(`Root node without getHandGrammarProgram defined.`)
    return this.root.handGrammarProgram
  }
  getRunTimeEnumOptions(cell) {
    return undefined
  }
  _sortNodesByInScopeOrder() {
    const parserOrder = this.definition._getMyInScopeParserIds()
    if (!parserOrder.length) return this
    const orderMap = {}
    parserOrder.forEach((word, index) => (orderMap[word] = index))
    this.sort(Utils.makeSortByFn(runtimeNode => orderMap[runtimeNode.definition.parserIdFromDefinition]))
    return this
  }
  get requiredNodeErrors() {
    const errors = []
    Object.values(this.definition.firstWordMapWithDefinitions).forEach(def => {
      if (def.isRequired() && !this.nodeIndex[def.id]) errors.push(new MissingRequiredParserError(this, def.id))
    })
    return errors
  }
  get programAsCells() {
    // todo: what is this?
    return this.topDownArray.map(node => {
      const cells = node.parsedCells
      let indents = node.getIndentLevel() - 1
      while (indents) {
        cells.unshift(undefined)
        indents--
      }
      return cells
    })
  }
  get programWidth() {
    return Math.max(...this.programAsCells.map(line => line.length))
  }
  get allTypedWords() {
    const words = []
    this.topDownArray.forEach(node => node.wordTypes.forEach((cell, index) => words.push(new TypedWord(node, index, cell.cellTypeId))))
    return words
  }
  findAllWordsWithCellType(cellTypeId) {
    return this.allTypedWords.filter(typedWord => typedWord.type === cellTypeId)
  }
  findAllNodesWithParser(parserId) {
    return this.topDownArray.filter(node => node.definition.parserIdFromDefinition === parserId)
  }
  toCellTypeTree() {
    return this.topDownArray.map(child => child.indentation + child.lineCellTypes).join("\n")
  }
  getParseTable(maxColumnWidth = 40) {
    const tree = new TreeNode(this.toCellTypeTree())
    return new TreeNode(
      tree.topDownArray.map((node, lineNumber) => {
        const sourceNode = this.nodeAtLine(lineNumber)
        const errs = sourceNode.getErrors()
        const errorCount = errs.length
        const obj = {
          lineNumber: lineNumber,
          source: sourceNode.indentation + sourceNode.getLine(),
          parser: sourceNode.constructor.name,
          cellTypes: node.content,
          errorCount: errorCount
        }
        if (errorCount) obj.errorMessages = errs.map(err => err.message).join(";")
        return obj
      })
    ).toFormattedTable(maxColumnWidth)
  }
  // Helper method for selecting potential parsers needed to update grammar file.
  get invalidParsers() {
    return Array.from(
      new Set(
        this.getAllErrors()
          .filter(err => err instanceof UnknownParserError)
          .map(err => err.getNode().firstWord)
      )
    )
  }
  _getAllAutoCompleteWords() {
    return this.getAllWordBoundaryCoordinates().map(coordinate => {
      const results = this.getAutocompleteResultsAt(coordinate.lineIndex, coordinate.charIndex)
      return {
        lineIndex: coordinate.lineIndex,
        charIndex: coordinate.charIndex,
        wordIndex: coordinate.wordIndex,
        word: results.word,
        suggestions: results.matches
      }
    })
  }
  toAutoCompleteCube(fillChar = "") {
    const trees = [this.clone()]
    const filled = this.clone().fill(fillChar)
    this._getAllAutoCompleteWords().forEach(hole => {
      hole.suggestions.forEach((suggestion, index) => {
        if (!trees[index + 1]) trees[index + 1] = filled.clone()
        trees[index + 1].nodeAtLine(hole.lineIndex).setWord(hole.wordIndex, suggestion.text)
      })
    })
    return new TreeNode(trees)
  }
  toAutoCompleteTable() {
    return new TreeNode(
      this._getAllAutoCompleteWords().map(result => {
        result.suggestions = result.suggestions.map(node => node.text).join(" ")
        return result
      })
    ).asTable
  }
  getAutocompleteResultsAt(lineIndex, charIndex) {
    const lineNode = this.nodeAtLine(lineIndex) || this
    const nodeInScope = lineNode.getNodeInScopeAtCharIndex(charIndex)
    // todo: add more tests
    // todo: second param this.childrenToString()
    // todo: change to getAutocomplete definitions
    const wordIndex = lineNode.getWordIndexAtCharacterIndex(charIndex)
    const wordProperties = lineNode.getWordProperties(wordIndex)
    return {
      startCharIndex: wordProperties.startCharIndex,
      endCharIndex: wordProperties.endCharIndex,
      word: wordProperties.word,
      matches: nodeInScope.getAutocompleteResults(wordProperties.word, wordIndex)
    }
  }
  _sortWithParentParsersUpTop() {
    const familyTree = new HandGrammarProgram(this.toString()).parserFamilyTree
    const rank = {}
    familyTree.topDownArray.forEach((node, index) => {
      rank[node.getWord(0)] = index
    })
    const nodeAFirst = -1
    const nodeBFirst = 1
    this.sort((nodeA, nodeB) => {
      const nodeARank = rank[nodeA.getWord(0)]
      const nodeBRank = rank[nodeB.getWord(0)]
      return nodeARank < nodeBRank ? nodeAFirst : nodeBFirst
    })
    return this
  }
  format() {
    if (this.isRoot()) {
      this._sortNodesByInScopeOrder()
      try {
        this._sortWithParentParsersUpTop()
      } catch (err) {
        console.log(`Warning: ${err}`)
      }
    }
    this.topDownArray.forEach(child => {
      child.format()
    })
    return this
  }
  sortFromSortTemplate() {
    if (!this.length) return this
    // Recurse
    this.forEach(node => node.sortFromSortTemplate())
    const def = this.isRoot() ? this.definition.rootParserDefinition : this.definition
    const { sortIndices, sortSections } = def.sortSpec
    // Sort and insert section breaks
    if (sortIndices.size) {
      // Sort keywords
      this.sort((nodeA, nodeB) => {
        var _a, _b
        const aIndex = (_a = sortIndices.get(nodeA.firstWord)) !== null && _a !== void 0 ? _a : sortIndices.get(nodeA.sortKey)
        const bIndex = (_b = sortIndices.get(nodeB.firstWord)) !== null && _b !== void 0 ? _b : sortIndices.get(nodeB.sortKey)
        if (aIndex === undefined) console.error(`sortTemplate is missing "${nodeA.firstWord}"`)
        const a = aIndex !== null && aIndex !== void 0 ? aIndex : 1000
        const b = bIndex !== null && bIndex !== void 0 ? bIndex : 1000
        return a > b ? 1 : a < b ? -1 : nodeA.getLine() > nodeB.getLine()
      })
      // pad sections
      let currentSection = 0
      this.forEach(node => {
        var _a
        const nodeSection = (_a = sortSections.get(node.firstWord)) !== null && _a !== void 0 ? _a : sortSections.get(node.sortKey)
        const sectionHasAdvanced = nodeSection > currentSection
        if (sectionHasAdvanced) {
          currentSection = nodeSection
          node.prependSibling("") // Put a blank line before this section
        }
      })
    }
    return this
  }
  getParserUsage(filepath = "") {
    // returns a report on what parsers from its language the program uses
    const usage = new TreeNode()
    const handGrammarProgram = this.handGrammarProgram
    handGrammarProgram.validConcreteAndAbstractParserDefinitions.forEach(def => {
      const requiredCellTypeIds = def.cellParser.getRequiredCellTypeIds()
      usage.appendLine([def.parserIdFromDefinition, "line-id", "parser", requiredCellTypeIds.join(" ")].join(" "))
    })
    this.topDownArray.forEach((node, lineNumber) => {
      const stats = usage.getNode(node.parserId)
      stats.appendLine([filepath + "-" + lineNumber, node.words.join(" ")].join(" "))
    })
    return usage
  }
  toHighlightScopeTree() {
    return this.topDownArray.map(child => child.indentation + child.getLineHighlightScopes()).join("\n")
  }
  toDefinitionLineNumberTree() {
    return this.topDownArray.map(child => child.definition.lineNumber + " " + child.indentation + child.cellDefinitionLineNumbers.join(" ")).join("\n")
  }
  get asCellTypeTreeWithParserIds() {
    return this.topDownArray.map(child => child.constructor.name + this.wordBreakSymbol + child.indentation + child.lineCellTypes).join("\n")
  }
  toPreludeCellTypeTreeWithParserIds() {
    return this.topDownArray.map(child => child.constructor.name + this.wordBreakSymbol + child.indentation + child.getLineCellPreludeTypes()).join("\n")
  }
  get asTreeWithParsers() {
    return this.topDownArray.map(child => child.constructor.name + this.wordBreakSymbol + child.indentation + child.getLine()).join("\n")
  }
  getCellHighlightScopeAtPosition(lineIndex, wordIndex) {
    this._initCellTypeCache()
    const typeNode = this._cache_highlightScopeTree.topDownArray[lineIndex - 1]
    return typeNode ? typeNode.getWord(wordIndex - 1) : undefined
  }
  _initCellTypeCache() {
    const treeMTime = this.getLineOrChildrenModifiedTime()
    if (this._cache_programCellTypeStringMTime === treeMTime) return undefined
    this._cache_typeTree = new TreeNode(this.toCellTypeTree())
    this._cache_highlightScopeTree = new TreeNode(this.toHighlightScopeTree())
    this._cache_programCellTypeStringMTime = treeMTime
  }
  createParserCombinator() {
    return this.isRoot() ? new TreeNode.ParserCombinator(BlobParser) : new TreeNode.ParserCombinator(this.parent._getParser()._getCatchAllParser(this.parent), {})
  }
  get parserId() {
    return this.definition.parserIdFromDefinition
  }
  get wordTypes() {
    return this.parsedCells.filter(cell => cell.getWord() !== undefined)
  }
  get cellErrors() {
    return this.parsedCells.map(check => check.getErrorIfAny()).filter(identity => identity)
  }
  get singleParserUsedTwiceErrors() {
    const errors = []
    const parent = this.parent
    const hits = parent.getChildInstancesOfParserId(this.definition.id)
    if (hits.length > 1)
      hits.forEach((node, index) => {
        if (node === this) errors.push(new ParserUsedMultipleTimesError(node))
      })
    return errors
  }
  get uniqueLineAppearsTwiceErrors() {
    const errors = []
    const parent = this.parent
    const hits = parent.getChildInstancesOfParserId(this.definition.id)
    if (hits.length > 1) {
      const set = new Set()
      hits.forEach((node, index) => {
        const line = node.getLine()
        if (set.has(line)) errors.push(new ParserUsedMultipleTimesError(node))
        set.add(line)
      })
    }
    return errors
  }
  get scopeErrors() {
    let errors = []
    const def = this.definition
    if (def.isSingle) errors = errors.concat(this.singleParserUsedTwiceErrors)
    if (def.isUniqueLine) errors = errors.concat(this.uniqueLineAppearsTwiceErrors)
    const { requiredNodeErrors } = this
    if (requiredNodeErrors.length) errors = errors.concat(requiredNodeErrors)
    return errors
  }
  getErrors() {
    return this.cellErrors.concat(this.scopeErrors)
  }
  get parsedCells() {
    return this.definition.cellParser.getCellArray(this)
  }
  // todo: just make a fn that computes proper spacing and then is given a node to print
  get lineCellTypes() {
    return this.parsedCells.map(slot => slot.cellTypeId).join(" ")
  }
  getLineCellPreludeTypes() {
    return this.parsedCells
      .map(slot => {
        const def = slot.cellTypeDefinition
        //todo: cleanup
        return def ? def.preludeKindId : PreludeCellTypeIds.anyCell
      })
      .join(" ")
  }
  getLineHighlightScopes(defaultScope = "source") {
    return this.parsedCells.map(slot => slot.highlightScope || defaultScope).join(" ")
  }
  get cellDefinitionLineNumbers() {
    return this.parsedCells.map(cell => cell.definitionLineNumber)
  }
  _getCompiledIndentation() {
    const indentCharacter = this.definition._getCompilerObject()[GrammarConstantsCompiler.indentCharacter]
    const indent = this.indentation
    return indentCharacter !== undefined ? indentCharacter.repeat(indent.length) : indent
  }
  _getFields() {
    // fields are like cells
    const fields = {}
    this.forEach(node => {
      const def = node.definition
      if (def.isRequired() || def.isSingle) fields[node.getWord(0)] = node.content
    })
    return fields
  }
  _getCompiledLine() {
    const compiler = this.definition._getCompilerObject()
    const catchAllCellDelimiter = compiler[GrammarConstantsCompiler.catchAllCellDelimiter]
    const str = compiler[GrammarConstantsCompiler.stringTemplate]
    return str !== undefined ? Utils.formatStr(str, catchAllCellDelimiter, Object.assign(this._getFields(), this.cells)) : this.getLine()
  }
  get listDelimiter() {
    return this.definition._getFromExtended(GrammarConstants.listDelimiter)
  }
  get contentKey() {
    return this.definition._getFromExtended(GrammarConstants.contentKey)
  }
  get childrenKey() {
    return this.definition._getFromExtended(GrammarConstants.childrenKey)
  }
  get childrenAreTextBlob() {
    return this.definition._isBlobParser()
  }
  get isArrayElement() {
    return this.definition._hasFromExtended(GrammarConstants.uniqueFirstWord) ? false : !this.definition.isSingle
  }
  get list() {
    return this.listDelimiter ? this.content.split(this.listDelimiter) : super.list
  }
  get typedContent() {
    // todo: probably a better way to do this, perhaps by defining a cellDelimiter at the node level
    // todo: this currently parse anything other than string types
    if (this.listDelimiter) return this.content.split(this.listDelimiter)
    const cells = this.parsedCells
    if (cells.length === 2) return cells[1].parsed
    return this.content
  }
  get typedTuple() {
    const key = this.firstWord
    if (this.childrenAreTextBlob) return [key, this.childrenToString()]
    const { typedContent, contentKey, childrenKey } = this
    if (contentKey || childrenKey) {
      let obj = {}
      if (childrenKey) obj[childrenKey] = this.childrenToString()
      else obj = this.typedMap
      if (contentKey) {
        obj[contentKey] = typedContent
      }
      return [key, obj]
    }
    const hasChildren = this.length > 0
    const hasChildrenNoContent = typedContent === undefined && hasChildren
    const shouldReturnValueAsObject = hasChildrenNoContent
    if (shouldReturnValueAsObject) return [key, this.typedMap]
    const hasChildrenAndContent = typedContent !== undefined && hasChildren
    const shouldReturnValueAsContentPlusChildren = hasChildrenAndContent
    // If the node has a content and a subtree return it as a string, as
    // Javascript object values can't be both a leaf and a tree.
    if (shouldReturnValueAsContentPlusChildren) return [key, this.contentWithChildren]
    return [key, typedContent]
  }
  get _shouldSerialize() {
    const should = this.shouldSerialize
    return should === undefined ? true : should
  }
  get typedMap() {
    const obj = {}
    this.forEach(node => {
      if (!node._shouldSerialize) return true
      const tuple = node.typedTuple
      if (!node.isArrayElement) obj[tuple[0]] = tuple[1]
      else {
        if (!obj[tuple[0]]) obj[tuple[0]] = []
        obj[tuple[0]].push(tuple[1])
      }
    })
    return obj
  }
  fromTypedMap() {}
  compile() {
    if (this.isRoot()) return super.compile()
    const def = this.definition
    const indent = this._getCompiledIndentation()
    const compiledLine = this._getCompiledLine()
    if (def.isTerminalParser()) return indent + compiledLine
    const compiler = def._getCompilerObject()
    const openChildrenString = compiler[GrammarConstantsCompiler.openChildren] || ""
    const closeChildrenString = compiler[GrammarConstantsCompiler.closeChildren] || ""
    const childJoinCharacter = compiler[GrammarConstantsCompiler.joinChildrenWith] || "\n"
    const compiledChildren = this.map(child => child.compile()).join(childJoinCharacter)
    return `${indent + compiledLine}${openChildrenString}
${compiledChildren}
${indent}${closeChildrenString}`
  }
  // todo: remove
  get cells() {
    const cells = {}
    this.parsedCells.forEach(cell => {
      const cellTypeId = cell.cellTypeId
      if (!cell.isCatchAll()) cells[cellTypeId] = cell.parsed
      else {
        if (!cells[cellTypeId]) cells[cellTypeId] = []
        cells[cellTypeId].push(cell.parsed)
      }
    })
    return cells
  }
}
class BlobParser extends GrammarBackedNode {
  createParserCombinator() {
    return new TreeNode.ParserCombinator(BlobParser, {})
  }
  getErrors() {
    return []
  }
}
// todo: can we remove this? hard to extend.
class UnknownParserNode extends GrammarBackedNode {
  createParserCombinator() {
    return new TreeNode.ParserCombinator(UnknownParserNode, {})
  }
  getErrors() {
    return [new UnknownParserError(this)]
  }
}
/*
A cell contains a word but also the type information for that word.
*/
class AbstractGrammarBackedCell {
  constructor(node, index, typeDef, cellTypeId, isCatchAll, parserDefinitionParser) {
    this._typeDef = typeDef
    this._node = node
    this._isCatchAll = isCatchAll
    this._index = index
    this._cellTypeId = cellTypeId
    this._parserDefinitionParser = parserDefinitionParser
  }
  getWord() {
    return this._node.getWord(this._index)
  }
  get definitionLineNumber() {
    return this._typeDef.lineNumber
  }
  get cellTypeId() {
    return this._cellTypeId
  }
  getNode() {
    return this._node
  }
  get cellIndex() {
    return this._index
  }
  isCatchAll() {
    return this._isCatchAll
  }
  get min() {
    return this.cellTypeDefinition.get(GrammarConstants.min) || "0"
  }
  get max() {
    return this.cellTypeDefinition.get(GrammarConstants.max) || "100"
  }
  get placeholder() {
    return this.cellTypeDefinition.get(GrammarConstants.examples) || ""
  }
  get highlightScope() {
    const definition = this.cellTypeDefinition
    if (definition) return definition.highlightScope // todo: why the undefined?
  }
  getAutoCompleteWords(partialWord = "") {
    const cellDef = this.cellTypeDefinition
    let words = cellDef ? cellDef._getAutocompleteWordOptions(this.getNode().root) : []
    const runTimeOptions = this.getNode().getRunTimeEnumOptions(this)
    if (runTimeOptions) words = runTimeOptions.concat(words)
    if (partialWord) words = words.filter(word => word.includes(partialWord))
    return words.map(word => {
      return {
        text: word,
        displayText: word
      }
    })
  }
  synthesizeCell(seed = Date.now()) {
    // todo: cleanup
    const cellDef = this.cellTypeDefinition
    const enumOptions = cellDef._getFromExtended(GrammarConstants.enum)
    if (enumOptions) return Utils.getRandomString(1, enumOptions.split(" "))
    return this._synthesizeCell(seed)
  }
  _getStumpEnumInput(crux) {
    const cellDef = this.cellTypeDefinition
    const enumOptions = cellDef._getFromExtended(GrammarConstants.enum)
    if (!enumOptions) return undefined
    const options = new TreeNode(
      enumOptions
        .split(" ")
        .map(option => `option ${option}`)
        .join("\n")
    )
    return `select
 name ${crux}
${options.toString(1)}`
  }
  _toStumpInput(crux) {
    // todo: remove
    const enumInput = this._getStumpEnumInput(crux)
    if (enumInput) return enumInput
    // todo: cleanup. We shouldn't have these dual cellType classes.
    return `input
 name ${crux}
 placeholder ${this.placeholder}`
  }
  get cellTypeDefinition() {
    return this._typeDef
  }
  _getErrorContext() {
    return this.getNode().getLine().split(" ")[0] // todo: WordBreakSymbol
  }
  isValid() {
    const runTimeOptions = this.getNode().getRunTimeEnumOptions(this)
    const word = this.getWord()
    if (runTimeOptions) return runTimeOptions.includes(word)
    return this.cellTypeDefinition.isValid(word, this.getNode().root) && this._isValid()
  }
  getErrorIfAny() {
    const word = this.getWord()
    if (word !== undefined && this.isValid()) return undefined
    // todo: refactor invalidwordError. We want better error messages.
    return word === undefined || word === "" ? new MissingWordError(this) : new InvalidWordError(this)
  }
}
AbstractGrammarBackedCell.parserFunctionName = ""
class GrammarBitCell extends AbstractGrammarBackedCell {
  _isValid() {
    const word = this.getWord()
    return word === "0" || word === "1"
  }
  _synthesizeCell() {
    return Utils.getRandomString(1, "01".split(""))
  }
  get regexString() {
    return "[01]"
  }
  get parsed() {
    const word = this.getWord()
    return !!parseInt(word)
  }
}
GrammarBitCell.defaultHighlightScope = "constant.numeric"
class GrammarNumericCell extends AbstractGrammarBackedCell {
  _toStumpInput(crux) {
    return `input
 name ${crux}
 type number
 placeholder ${this.placeholder}
 min ${this.min}
 max ${this.max}`
  }
}
class GrammarIntCell extends GrammarNumericCell {
  _isValid() {
    const word = this.getWord()
    const num = parseInt(word)
    if (isNaN(num)) return false
    return num.toString() === word
  }
  _synthesizeCell(seed) {
    return Utils.randomUniformInt(parseInt(this.min), parseInt(this.max), seed).toString()
  }
  get regexString() {
    return "-?[0-9]+"
  }
  get parsed() {
    const word = this.getWord()
    return parseInt(word)
  }
}
GrammarIntCell.defaultHighlightScope = "constant.numeric.integer"
GrammarIntCell.parserFunctionName = "parseInt"
class GrammarFloatCell extends GrammarNumericCell {
  _isValid() {
    const word = this.getWord()
    const num = parseFloat(word)
    return !isNaN(num) && /^-?\d*(\.\d+)?$/.test(word)
  }
  _synthesizeCell(seed) {
    return Utils.randomUniformFloat(parseFloat(this.min), parseFloat(this.max), seed).toString()
  }
  get regexString() {
    return "-?d*(.d+)?"
  }
  get parsed() {
    const word = this.getWord()
    return parseFloat(word)
  }
}
GrammarFloatCell.defaultHighlightScope = "constant.numeric.float"
GrammarFloatCell.parserFunctionName = "parseFloat"
// ErrorCellType => grammar asks for a '' cell type here but the grammar does not specify a '' cell type. (todo: bring in didyoumean?)
class GrammarBoolCell extends AbstractGrammarBackedCell {
  constructor() {
    super(...arguments)
    this._trues = new Set(["1", "true", "t", "yes"])
    this._falses = new Set(["0", "false", "f", "no"])
  }
  _isValid() {
    const word = this.getWord()
    const str = word.toLowerCase()
    return this._trues.has(str) || this._falses.has(str)
  }
  _synthesizeCell() {
    return Utils.getRandomString(1, ["1", "true", "t", "yes", "0", "false", "f", "no"])
  }
  _getOptions() {
    return Array.from(this._trues).concat(Array.from(this._falses))
  }
  get regexString() {
    return "(?:" + this._getOptions().join("|") + ")"
  }
  get parsed() {
    const word = this.getWord()
    return this._trues.has(word.toLowerCase())
  }
}
GrammarBoolCell.defaultHighlightScope = "constant.numeric"
class GrammarAnyCell extends AbstractGrammarBackedCell {
  _isValid() {
    return true
  }
  _synthesizeCell() {
    const examples = this.cellTypeDefinition._getFromExtended(GrammarConstants.examples)
    if (examples) return Utils.getRandomString(1, examples.split(" "))
    return this._parserDefinitionParser.parserIdFromDefinition + "-" + this.constructor.name
  }
  get regexString() {
    return "[^ ]+"
  }
  get parsed() {
    return this.getWord()
  }
}
class GrammarKeywordCell extends GrammarAnyCell {
  _synthesizeCell() {
    return this._parserDefinitionParser.cruxIfAny
  }
}
GrammarKeywordCell.defaultHighlightScope = "keyword"
class GrammarExtraWordCellTypeCell extends AbstractGrammarBackedCell {
  _isValid() {
    return false
  }
  synthesizeCell() {
    throw new Error(`Trying to synthesize a GrammarExtraWordCellTypeCell`)
    return this._synthesizeCell()
  }
  _synthesizeCell() {
    return "extraWord" // should never occur?
  }
  get parsed() {
    return this.getWord()
  }
  getErrorIfAny() {
    return new ExtraWordError(this)
  }
}
class GrammarUnknownCellTypeCell extends AbstractGrammarBackedCell {
  _isValid() {
    return false
  }
  synthesizeCell() {
    throw new Error(`Trying to synthesize an GrammarUnknownCellTypeCell`)
    return this._synthesizeCell()
  }
  _synthesizeCell() {
    return "extraWord" // should never occur?
  }
  get parsed() {
    return this.getWord()
  }
  getErrorIfAny() {
    return new UnknownCellTypeError(this)
  }
}
class AbstractTreeError {
  constructor(node) {
    this._node = node
  }
  getLineIndex() {
    return this.lineNumber - 1
  }
  get lineNumber() {
    return this.getNode()._getLineNumber() // todo: handle sourcemaps
  }
  isCursorOnWord(lineIndex, characterIndex) {
    return lineIndex === this.getLineIndex() && this._doesCharacterIndexFallOnWord(characterIndex)
  }
  _doesCharacterIndexFallOnWord(characterIndex) {
    return this.cellIndex === this.getNode().getWordIndexAtCharacterIndex(characterIndex)
  }
  // convenience method. may be removed.
  isBlankLineError() {
    return false
  }
  // convenience method. may be removed.
  isMissingWordError() {
    return false
  }
  getIndent() {
    return this.getNode().indentation
  }
  getCodeMirrorLineWidgetElement(onApplySuggestionCallBack = () => {}) {
    const suggestion = this.suggestionMessage
    if (this.isMissingWordError()) return this._getCodeMirrorLineWidgetElementCellTypeHints()
    if (suggestion) return this._getCodeMirrorLineWidgetElementWithSuggestion(onApplySuggestionCallBack, suggestion)
    return this._getCodeMirrorLineWidgetElementWithoutSuggestion()
  }
  get parserId() {
    return this.getNode().definition.parserIdFromDefinition
  }
  _getCodeMirrorLineWidgetElementCellTypeHints() {
    const el = document.createElement("div")
    el.appendChild(document.createTextNode(this.getIndent() + this.getNode().definition.lineHints))
    el.className = "LintCellTypeHints"
    return el
  }
  _getCodeMirrorLineWidgetElementWithoutSuggestion() {
    const el = document.createElement("div")
    el.appendChild(document.createTextNode(this.getIndent() + this.message))
    el.className = "LintError"
    return el
  }
  _getCodeMirrorLineWidgetElementWithSuggestion(onApplySuggestionCallBack, suggestion) {
    const el = document.createElement("div")
    el.appendChild(document.createTextNode(this.getIndent() + `${this.errorTypeName}. Suggestion: ${suggestion}`))
    el.className = "LintErrorWithSuggestion"
    el.onclick = () => {
      this.applySuggestion()
      onApplySuggestionCallBack()
    }
    return el
  }
  getLine() {
    return this.getNode().getLine()
  }
  getExtension() {
    return this.getNode().handGrammarProgram.extensionName
  }
  getNode() {
    return this._node
  }
  get errorTypeName() {
    return this.constructor.name.replace("Error", "")
  }
  get cellIndex() {
    return 0
  }
  toObject() {
    return {
      type: this.errorTypeName,
      line: this.lineNumber,
      cell: this.cellIndex,
      suggestion: this.suggestionMessage,
      path: this.getNode().getFirstWordPath(),
      message: this.message
    }
  }
  hasSuggestion() {
    return this.suggestionMessage !== ""
  }
  get suggestionMessage() {
    return ""
  }
  toString() {
    return this.message
  }
  applySuggestion() {}
  get message() {
    return `${this.errorTypeName} at line ${this.lineNumber} cell ${this.cellIndex}.`
  }
}
class AbstractCellError extends AbstractTreeError {
  constructor(cell) {
    super(cell.getNode())
    this._cell = cell
  }
  get cell() {
    return this._cell
  }
  get cellIndex() {
    return this._cell.cellIndex
  }
  get wordSuggestion() {
    return Utils.didYouMean(
      this.cell.getWord(),
      this.cell.getAutoCompleteWords().map(option => option.text)
    )
  }
}
class UnknownParserError extends AbstractTreeError {
  get message() {
    const node = this.getNode()
    const parentNode = node.parent
    const options = parentNode._getParser().getFirstWordOptions()
    return super.message + ` Invalid parser "${node.firstWord}". Valid parsers are: ${Utils._listToEnglishText(options, 7)}.`
  }
  get wordSuggestion() {
    const node = this.getNode()
    const parentNode = node.parent
    return Utils.didYouMean(
      node.firstWord,
      parentNode.getAutocompleteResults("", 0).map(option => option.text)
    )
  }
  get suggestionMessage() {
    const suggestion = this.wordSuggestion
    const node = this.getNode()
    if (suggestion) return `Change "${node.firstWord}" to "${suggestion}"`
    return ""
  }
  applySuggestion() {
    const suggestion = this.wordSuggestion
    if (suggestion) this.getNode().setWord(this.cellIndex, suggestion)
    return this
  }
}
class BlankLineError extends UnknownParserError {
  get message() {
    return super.message + ` Line: "${this.getNode().getLine()}". Blank lines are errors.`
  }
  // convenience method
  isBlankLineError() {
    return true
  }
  get suggestionMessage() {
    return `Delete line ${this.lineNumber}`
  }
  applySuggestion() {
    this.getNode().destroy()
    return this
  }
}
class MissingRequiredParserError extends AbstractTreeError {
  constructor(node, missingParserId) {
    super(node)
    this._missingParserId = missingParserId
  }
  get message() {
    return super.message + ` A "${this._missingParserId}" is required.`
  }
}
class ParserUsedMultipleTimesError extends AbstractTreeError {
  get message() {
    return super.message + ` Multiple "${this.getNode().firstWord}" found.`
  }
  get suggestionMessage() {
    return `Delete line ${this.lineNumber}`
  }
  applySuggestion() {
    return this.getNode().destroy()
  }
}
class LineAppearsMultipleTimesError extends AbstractTreeError {
  get message() {
    return super.message + ` "${this.getNode().getLine()}" appears multiple times.`
  }
  get suggestionMessage() {
    return `Delete line ${this.lineNumber}`
  }
  applySuggestion() {
    return this.getNode().destroy()
  }
}
class UnknownCellTypeError extends AbstractCellError {
  get message() {
    return super.message + ` No cellType "${this.cell.cellTypeId}" found. Language grammar for "${this.getExtension()}" may need to be fixed.`
  }
}
class InvalidWordError extends AbstractCellError {
  get message() {
    return super.message + ` "${this.cell.getWord()}" does not fit in cellType "${this.cell.cellTypeId}".`
  }
  get suggestionMessage() {
    const suggestion = this.wordSuggestion
    if (suggestion) return `Change "${this.cell.getWord()}" to "${suggestion}"`
    return ""
  }
  applySuggestion() {
    const suggestion = this.wordSuggestion
    if (suggestion) this.getNode().setWord(this.cellIndex, suggestion)
    return this
  }
}
class ExtraWordError extends AbstractCellError {
  get message() {
    return super.message + ` Extra word "${this.cell.getWord()}" in ${this.parserId}.`
  }
  get suggestionMessage() {
    return `Delete word "${this.cell.getWord()}" at cell ${this.cellIndex}`
  }
  applySuggestion() {
    return this.getNode().deleteWordAt(this.cellIndex)
  }
}
class MissingWordError extends AbstractCellError {
  // todo: autocomplete suggestion
  get message() {
    return super.message + ` Missing word for cell "${this.cell.cellTypeId}".`
  }
  isMissingWordError() {
    return true
  }
}
// todo: add standard types, enum types, from disk types
class AbstractGrammarWordTestParser extends TreeNode {}
class GrammarRegexTestParser extends AbstractGrammarWordTestParser {
  isValid(str) {
    if (!this._regex) this._regex = new RegExp("^" + this.content + "$")
    return !!str.match(this._regex)
  }
}
class GrammarReservedWordsTestParser extends AbstractGrammarWordTestParser {
  isValid(str) {
    if (!this._set) this._set = new Set(this.content.split(" "))
    return !this._set.has(str)
  }
}
// todo: remove in favor of custom word type constructors
class EnumFromCellTypesTestParser extends AbstractGrammarWordTestParser {
  _getEnumFromCellTypes(programRootNode) {
    const cellTypeIds = this.getWordsFrom(1)
    const enumGroup = cellTypeIds.join(" ")
    // note: hack where we store it on the program. otherwise has global effects.
    if (!programRootNode._enumMaps) programRootNode._enumMaps = {}
    if (programRootNode._enumMaps[enumGroup]) return programRootNode._enumMaps[enumGroup]
    const wordIndex = 1
    const map = {}
    const cellTypeMap = {}
    cellTypeIds.forEach(typeId => (cellTypeMap[typeId] = true))
    programRootNode.allTypedWords
      .filter(typedWord => cellTypeMap[typedWord.type])
      .forEach(typedWord => {
        map[typedWord.word] = true
      })
    programRootNode._enumMaps[enumGroup] = map
    return map
  }
  // todo: remove
  isValid(str, programRootNode) {
    return this._getEnumFromCellTypes(programRootNode)[str] === true
  }
}
class GrammarEnumTestNode extends AbstractGrammarWordTestParser {
  isValid(str) {
    // enum c c++ java
    return !!this.getOptions()[str]
  }
  getOptions() {
    if (!this._map) this._map = Utils.arrayToMap(this.getWordsFrom(1))
    return this._map
  }
}
class cellTypeDefinitionParser extends AbstractExtendibleTreeNode {
  createParserCombinator() {
    const types = {}
    types[GrammarConstants.regex] = GrammarRegexTestParser
    types[GrammarConstants.reservedWords] = GrammarReservedWordsTestParser
    types[GrammarConstants.enumFromCellTypes] = EnumFromCellTypesTestParser
    types[GrammarConstants.enum] = GrammarEnumTestNode
    types[GrammarConstants.highlightScope] = TreeNode
    types[GrammarConstants.comment] = TreeNode
    types[GrammarConstants.examples] = TreeNode
    types[GrammarConstants.min] = TreeNode
    types[GrammarConstants.max] = TreeNode
    types[GrammarConstants.description] = TreeNode
    types[GrammarConstants.extends] = TreeNode
    return new TreeNode.ParserCombinator(undefined, types)
  }
  get id() {
    return this.getWord(0)
  }
  get idToNodeMap() {
    return this.parent.cellTypeDefinitions
  }
  getGetter(wordIndex) {
    const wordToNativeJavascriptTypeParser = this.getCellConstructor().parserFunctionName
    return `get ${this.cellTypeId}() {
      return ${wordToNativeJavascriptTypeParser ? wordToNativeJavascriptTypeParser + `(this.getWord(${wordIndex}))` : `this.getWord(${wordIndex})`}
    }`
  }
  getCatchAllGetter(wordIndex) {
    const wordToNativeJavascriptTypeParser = this.getCellConstructor().parserFunctionName
    return `get ${this.cellTypeId}() {
      return ${wordToNativeJavascriptTypeParser ? `this.getWordsFrom(${wordIndex}).map(val => ${wordToNativeJavascriptTypeParser}(val))` : `this.getWordsFrom(${wordIndex})`}
    }`
  }
  // `this.getWordsFrom(${requireds.length + 1})`
  // todo: cleanup typings. todo: remove this hidden logic. have a "baseType" property?
  getCellConstructor() {
    return this.preludeKind || GrammarAnyCell
  }
  get preludeKind() {
    return PreludeKinds[this.getWord(0)] || PreludeKinds[this._getExtendedCellTypeId()]
  }
  get preludeKindId() {
    if (PreludeKinds[this.getWord(0)]) return this.getWord(0)
    else if (PreludeKinds[this._getExtendedCellTypeId()]) return this._getExtendedCellTypeId()
    return PreludeCellTypeIds.anyCell
  }
  _getExtendedCellTypeId() {
    const arr = this._getAncestorsArray()
    return arr[arr.length - 1].id
  }
  get highlightScope() {
    const hs = this._getFromExtended(GrammarConstants.highlightScope)
    if (hs) return hs
    const preludeKind = this.preludeKind
    if (preludeKind) return preludeKind.defaultHighlightScope
  }
  _getEnumOptions() {
    const enumNode = this._getNodeFromExtended(GrammarConstants.enum)
    if (!enumNode) return undefined
    // we sort by longest first to capture longest match first. todo: add test
    const options = Object.keys(enumNode.getNode(GrammarConstants.enum).getOptions())
    options.sort((a, b) => b.length - a.length)
    return options
  }
  _getEnumFromCellTypeOptions(program) {
    const node = this._getNodeFromExtended(GrammarConstants.enumFromCellTypes)
    return node ? Object.keys(node.getNode(GrammarConstants.enumFromCellTypes)._getEnumFromCellTypes(program)) : undefined
  }
  _getAutocompleteWordOptions(program) {
    return this._getEnumOptions() || this._getEnumFromCellTypeOptions(program) || []
  }
  get regexString() {
    // todo: enum
    const enumOptions = this._getEnumOptions()
    return this._getFromExtended(GrammarConstants.regex) || (enumOptions ? "(?:" + enumOptions.join("|") + ")" : "[^ ]*")
  }
  _getAllTests() {
    return this._getChildrenByParserInExtended(AbstractGrammarWordTestParser)
  }
  isValid(str, programRootNode) {
    return this._getAllTests().every(node => node.isValid(str, programRootNode))
  }
  get cellTypeId() {
    return this.getWord(0)
  }
}
class AbstractCellParser {
  constructor(definition) {
    this._definition = definition
  }
  get catchAllCellTypeId() {
    return this._definition._getFromExtended(GrammarConstants.catchAllCellType)
  }
  // todo: improve layout (use bold?)
  get lineHints() {
    const catchAllCellTypeId = this.catchAllCellTypeId
    const parserId = this._definition.cruxIfAny || this._definition.id // todo: cleanup
    return `${parserId}: ${this.getRequiredCellTypeIds().join(" ")}${catchAllCellTypeId ? ` ${catchAllCellTypeId}...` : ""}`
  }
  getRequiredCellTypeIds() {
    if (!this._requiredCellTypeIds) {
      const parameters = this._definition._getFromExtended(GrammarConstants.cells)
      this._requiredCellTypeIds = parameters ? parameters.split(" ") : []
    }
    return this._requiredCellTypeIds
  }
  _getCellTypeId(cellIndex, requiredCellTypeIds, totalWordCount) {
    return requiredCellTypeIds[cellIndex]
  }
  _isCatchAllCell(cellIndex, numberOfRequiredCells, totalWordCount) {
    return cellIndex >= numberOfRequiredCells
  }
  getCellArray(node = undefined) {
    const wordCount = node ? node.words.length : 0
    const def = this._definition
    const grammarProgram = def.languageDefinitionProgram
    const requiredCellTypeIds = this.getRequiredCellTypeIds()
    const numberOfRequiredCells = requiredCellTypeIds.length
    const actualWordCountOrRequiredCellCount = Math.max(wordCount, numberOfRequiredCells)
    const cells = []
    // A for loop instead of map because "numberOfCellsToFill" can be longer than words.length
    for (let cellIndex = 0; cellIndex < actualWordCountOrRequiredCellCount; cellIndex++) {
      const isCatchAll = this._isCatchAllCell(cellIndex, numberOfRequiredCells, wordCount)
      let cellTypeId = isCatchAll ? this.catchAllCellTypeId : this._getCellTypeId(cellIndex, requiredCellTypeIds, wordCount)
      let cellTypeDefinition = grammarProgram.getCellTypeDefinitionById(cellTypeId)
      let cellConstructor
      if (cellTypeDefinition) cellConstructor = cellTypeDefinition.getCellConstructor()
      else if (cellTypeId) cellConstructor = GrammarUnknownCellTypeCell
      else {
        cellConstructor = GrammarExtraWordCellTypeCell
        cellTypeId = PreludeCellTypeIds.extraWordCell
        cellTypeDefinition = grammarProgram.getCellTypeDefinitionById(cellTypeId)
      }
      const anyCellConstructor = cellConstructor
      cells[cellIndex] = new anyCellConstructor(node, cellIndex, cellTypeDefinition, cellTypeId, isCatchAll, def)
    }
    return cells
  }
}
class PrefixCellParser extends AbstractCellParser {}
class PostfixCellParser extends AbstractCellParser {
  _isCatchAllCell(cellIndex, numberOfRequiredCells, totalWordCount) {
    return cellIndex < totalWordCount - numberOfRequiredCells
  }
  _getCellTypeId(cellIndex, requiredCellTypeIds, totalWordCount) {
    const catchAllWordCount = Math.max(totalWordCount - requiredCellTypeIds.length, 0)
    return requiredCellTypeIds[cellIndex - catchAllWordCount]
  }
}
class OmnifixCellParser extends AbstractCellParser {
  getCellArray(node = undefined) {
    const cells = []
    const def = this._definition
    const program = node ? node.root : undefined
    const grammarProgram = def.languageDefinitionProgram
    const words = node ? node.words : []
    const requiredCellTypeDefs = this.getRequiredCellTypeIds().map(cellTypeId => grammarProgram.getCellTypeDefinitionById(cellTypeId))
    const catchAllCellTypeId = this.catchAllCellTypeId
    const catchAllCellTypeDef = catchAllCellTypeId && grammarProgram.getCellTypeDefinitionById(catchAllCellTypeId)
    words.forEach((word, wordIndex) => {
      let cellConstructor
      for (let index = 0; index < requiredCellTypeDefs.length; index++) {
        const cellTypeDefinition = requiredCellTypeDefs[index]
        if (cellTypeDefinition.isValid(word, program)) {
          // todo: cleanup cellIndex/wordIndex stuff
          cellConstructor = cellTypeDefinition.getCellConstructor()
          cells.push(new cellConstructor(node, wordIndex, cellTypeDefinition, cellTypeDefinition.id, false, def))
          requiredCellTypeDefs.splice(index, 1)
          return true
        }
      }
      if (catchAllCellTypeDef && catchAllCellTypeDef.isValid(word, program)) {
        cellConstructor = catchAllCellTypeDef.getCellConstructor()
        cells.push(new cellConstructor(node, wordIndex, catchAllCellTypeDef, catchAllCellTypeId, true, def))
        return true
      }
      cells.push(new GrammarUnknownCellTypeCell(node, wordIndex, undefined, undefined, false, def))
    })
    const wordCount = words.length
    requiredCellTypeDefs.forEach((cellTypeDef, index) => {
      let cellConstructor = cellTypeDef.getCellConstructor()
      cells.push(new cellConstructor(node, wordCount + index, cellTypeDef, cellTypeDef.id, false, def))
    })
    return cells
  }
}
class GrammarExampleParser extends TreeNode {}
class GrammarCompilerParser extends TreeNode {
  createParserCombinator() {
    const types = [
      GrammarConstantsCompiler.stringTemplate,
      GrammarConstantsCompiler.indentCharacter,
      GrammarConstantsCompiler.catchAllCellDelimiter,
      GrammarConstantsCompiler.joinChildrenWith,
      GrammarConstantsCompiler.openChildren,
      GrammarConstantsCompiler.closeChildren
    ]
    const map = {}
    types.forEach(type => {
      map[type] = TreeNode
    })
    return new TreeNode.ParserCombinator(undefined, map)
  }
}
class AbstractParserConstantParser extends TreeNode {
  constructor(children, line, parent) {
    super(children, line, parent)
    parent[this.identifier] = this.constantValue
  }
  getGetter() {
    return `get ${this.identifier}() { return ${this.constantValueAsJsText} }`
  }
  get identifier() {
    return this.getWord(1)
  }
  get constantValueAsJsText() {
    const words = this.getWordsFrom(2)
    return words.length > 1 ? `[${words.join(",")}]` : words[0]
  }
  get constantValue() {
    return JSON.parse(this.constantValueAsJsText)
  }
}
class GrammarParserConstantInt extends AbstractParserConstantParser {}
class GrammarParserConstantString extends AbstractParserConstantParser {
  get constantValueAsJsText() {
    return "`" + Utils.escapeBackTicks(this.constantValue) + "`"
  }
  get constantValue() {
    return this.length ? this.childrenToString() : this.getWordsFrom(2).join(" ")
  }
}
class GrammarParserConstantFloat extends AbstractParserConstantParser {}
class GrammarParserConstantBoolean extends AbstractParserConstantParser {}
class AbstractParserDefinitionParser extends AbstractExtendibleTreeNode {
  createParserCombinator() {
    // todo: some of these should just be on nonRootNodes
    const types = [
      GrammarConstants.frequency,
      GrammarConstants.inScope,
      GrammarConstants.cells,
      GrammarConstants.extends,
      GrammarConstants.description,
      GrammarConstants.catchAllParser,
      GrammarConstants.catchAllCellType,
      GrammarConstants.cellParser,
      GrammarConstants.extensions,
      GrammarConstants.version,
      GrammarConstants.sortTemplate,
      GrammarConstants.tags,
      GrammarConstants.crux,
      GrammarConstants.cruxFromId,
      GrammarConstants.listDelimiter,
      GrammarConstants.contentKey,
      GrammarConstants.childrenKey,
      GrammarConstants.uniqueFirstWord,
      GrammarConstants.uniqueLine,
      GrammarConstants.pattern,
      GrammarConstants.baseParser,
      GrammarConstants.required,
      GrammarConstants.root,
      GrammarConstants._extendsJsClass,
      GrammarConstants._rootNodeJsHeader,
      GrammarConstants.javascript,
      GrammarConstants.compilesTo,
      GrammarConstants.javascript,
      GrammarConstants.single,
      GrammarConstants.comment
    ]
    const map = {}
    types.forEach(type => {
      map[type] = TreeNode
    })
    map[GrammarConstantsConstantTypes.boolean] = GrammarParserConstantBoolean
    map[GrammarConstantsConstantTypes.int] = GrammarParserConstantInt
    map[GrammarConstantsConstantTypes.string] = GrammarParserConstantString
    map[GrammarConstantsConstantTypes.float] = GrammarParserConstantFloat
    map[GrammarConstants.compilerParser] = GrammarCompilerParser
    map[GrammarConstants.example] = GrammarExampleParser
    return new TreeNode.ParserCombinator(undefined, map, [{ regex: HandGrammarProgram.parserFullRegex, parser: parserDefinitionParser }])
  }
  get sortSpec() {
    const sortSections = new Map()
    const sortIndices = new Map()
    const sortTemplate = this.get(GrammarConstants.sortTemplate)
    if (!sortTemplate) return { sortSections, sortIndices }
    sortTemplate.split("  ").forEach((section, sectionIndex) => section.split(" ").forEach(word => sortSections.set(word, sectionIndex)))
    sortTemplate.split(" ").forEach((word, index) => sortIndices.set(word, index))
    return { sortSections, sortIndices }
  }
  toTypeScriptInterface(used = new Set()) {
    let childrenInterfaces = []
    let properties = []
    const inScope = this.firstWordMapWithDefinitions
    const thisId = this.id
    used.add(thisId)
    Object.keys(inScope).forEach(key => {
      const def = inScope[key]
      const map = def.firstWordMapWithDefinitions
      const id = def.id
      const optionalTag = def.isRequired() ? "" : "?"
      const escapedKey = key.match(/\?/) ? `"${key}"` : key
      const description = def.description
      if (Object.keys(map).length && !used.has(id)) {
        childrenInterfaces.push(def.toTypeScriptInterface(used))
        properties.push(` ${escapedKey}${optionalTag}: ${id}`)
      } else properties.push(` ${escapedKey}${optionalTag}: any${description ? " // " + description : ""}`)
    })
    properties.sort()
    const description = this.description
    const myInterface = ""
    return `${childrenInterfaces.join("\n")}
${description ? "// " + description : ""}
interface ${thisId} {
${properties.join("\n")}
}`.trim()
  }
  get id() {
    return this.getWord(0)
  }
  get idWithoutSuffix() {
    return this.id.replace(HandGrammarProgram.parserSuffixRegex, "")
  }
  get constantsObject() {
    const obj = this._getUniqueConstantNodes()
    Object.keys(obj).forEach(key => (obj[key] = obj[key].constantValue))
    return obj
  }
  _getUniqueConstantNodes(extended = true) {
    const obj = {}
    const items = extended ? this._getChildrenByParserInExtended(AbstractParserConstantParser) : this.getChildrenByParser(AbstractParserConstantParser)
    items.reverse() // Last definition wins.
    items.forEach(node => (obj[node.identifier] = node))
    return obj
  }
  get examples() {
    return this._getChildrenByParserInExtended(GrammarExampleParser)
  }
  get parserIdFromDefinition() {
    return this.getWord(0)
  }
  // todo: remove? just reused parserId
  get generatedClassName() {
    return this.parserIdFromDefinition
  }
  _hasValidParserId() {
    return !!this.generatedClassName
  }
  _isAbstract() {
    return this.id.startsWith(GrammarConstants.abstractParserPrefix)
  }
  get cruxIfAny() {
    return this.get(GrammarConstants.crux) || (this._hasFromExtended(GrammarConstants.cruxFromId) ? this.idWithoutSuffix : undefined)
  }
  get regexMatch() {
    return this.get(GrammarConstants.pattern)
  }
  get firstCellEnumOptions() {
    const firstCellDef = this._getMyCellTypeDefs()[0]
    return firstCellDef ? firstCellDef._getEnumOptions() : undefined
  }
  get languageDefinitionProgram() {
    return this.root
  }
  get customJavascriptMethods() {
    const hasJsCode = this.has(GrammarConstants.javascript)
    return hasJsCode ? this.getNode(GrammarConstants.javascript).childrenToString() : ""
  }
  get firstWordMapWithDefinitions() {
    if (!this._cache_firstWordToNodeDefMap) this._cache_firstWordToNodeDefMap = this._createParserInfo(this._getInScopeParserIds()).firstWordMap
    return this._cache_firstWordToNodeDefMap
  }
  // todo: remove
  get runTimeFirstWordsInScope() {
    return this._getParser().getFirstWordOptions()
  }
  _getMyCellTypeDefs() {
    const requiredCells = this.get(GrammarConstants.cells)
    if (!requiredCells) return []
    const grammarProgram = this.languageDefinitionProgram
    return requiredCells.split(" ").map(cellTypeId => {
      const cellTypeDef = grammarProgram.getCellTypeDefinitionById(cellTypeId)
      if (!cellTypeDef) throw new Error(`No cellType "${cellTypeId}" found`)
      return cellTypeDef
    })
  }
  // todo: what happens when you have a cell getter and constant with same name?
  get cellGettersAndParserConstants() {
    // todo: add cellType parsings
    const grammarProgram = this.languageDefinitionProgram
    const getters = this._getMyCellTypeDefs().map((cellTypeDef, index) => cellTypeDef.getGetter(index))
    const catchAllCellTypeId = this.get(GrammarConstants.catchAllCellType)
    if (catchAllCellTypeId) getters.push(grammarProgram.getCellTypeDefinitionById(catchAllCellTypeId).getCatchAllGetter(getters.length))
    // Constants
    Object.values(this._getUniqueConstantNodes(false)).forEach(node => getters.push(node.getGetter()))
    return getters.join("\n")
  }
  _createParserInfo(parserIdsInScope) {
    const result = {
      firstWordMap: {},
      regexTests: []
    }
    if (!parserIdsInScope.length) return result
    const allProgramParserDefinitionsMap = this.programParserDefinitionCache
    Object.keys(allProgramParserDefinitionsMap)
      .filter(parserId => {
        const def = allProgramParserDefinitionsMap[parserId]
        return def.isOrExtendsAParserInScope(parserIdsInScope) && !def._isAbstract()
      })
      .forEach(parserId => {
        const def = allProgramParserDefinitionsMap[parserId]
        const regex = def.regexMatch
        const crux = def.cruxIfAny
        const enumOptions = def.firstCellEnumOptions
        if (regex) result.regexTests.push({ regex: regex, parser: def.parserIdFromDefinition })
        else if (crux) result.firstWordMap[crux] = def
        else if (enumOptions) {
          enumOptions.forEach(option => (result.firstWordMap[option] = def))
        }
      })
    return result
  }
  get topParserDefinitions() {
    const arr = Object.values(this.firstWordMapWithDefinitions)
    arr.sort(Utils.makeSortByFn(definition => definition.frequency))
    arr.reverse()
    return arr
  }
  _getMyInScopeParserIds(target = this) {
    const parsersNode = target.getNode(GrammarConstants.inScope)
    const scopedDefinitionIds = target.myScopedParserDefinitions.map(def => def.id)
    return parsersNode ? parsersNode.getWordsFrom(1).concat(scopedDefinitionIds) : scopedDefinitionIds
  }
  _getInScopeParserIds() {
    // todo: allow multiple of these if we allow mixins?
    const ids = this._getMyInScopeParserIds()
    const parentDef = this._getExtendedParent()
    return parentDef ? ids.concat(parentDef._getInScopeParserIds()) : ids
  }
  get isSingle() {
    const hit = this._getNodeFromExtended(GrammarConstants.single)
    return hit && hit.get(GrammarConstants.single) !== "false"
  }
  get isUniqueLine() {
    const hit = this._getNodeFromExtended(GrammarConstants.uniqueLine)
    return hit && hit.get(GrammarConstants.uniqueLine) !== "false"
  }
  isRequired() {
    return this._hasFromExtended(GrammarConstants.required)
  }
  getParserDefinitionByParserId(parserId) {
    // todo: return catch all?
    const def = this.programParserDefinitionCache[parserId]
    if (def) return def
    this.languageDefinitionProgram._addDefaultCatchAllBlobParser() // todo: cleanup. Why did I do this? Needs to be removed or documented.
    const nodeDef = this.languageDefinitionProgram.programParserDefinitionCache[parserId]
    if (!nodeDef) throw new Error(`No definition found for parser id "${parserId}". Node: \n---\n${this.asString}\n---`)
    return nodeDef
  }
  isDefined(parserId) {
    return !!this.programParserDefinitionCache[parserId]
  }
  get idToNodeMap() {
    return this.programParserDefinitionCache
  }
  _amIRoot() {
    if (this._cache_isRoot === undefined) this._cache_isRoot = this._languageRootNode === this
    return this._cache_isRoot
  }
  get _languageRootNode() {
    return this.root.rootParserDefinition
  }
  _isErrorParser() {
    return this.get(GrammarConstants.baseParser) === GrammarConstants.errorParser
  }
  _isBlobParser() {
    // Do not check extended classes. Only do once.
    return this._getFromExtended(GrammarConstants.baseParser) === GrammarConstants.blobParser
  }
  get errorMethodToJavascript() {
    if (this._isBlobParser()) return "getErrors() { return [] }" // Skips parsing child nodes for perf gains.
    if (this._isErrorParser()) return "getErrors() { return this._getErrorParserErrors() }"
    return ""
  }
  get parserAsJavascript() {
    if (this._isBlobParser())
      // todo: do we need this?
      return "createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}"
    const parserInfo = this._createParserInfo(this._getMyInScopeParserIds())
    const myFirstWordMap = parserInfo.firstWordMap
    const regexRules = parserInfo.regexTests
    // todo: use constants in first word maps?
    // todo: cache the super extending?
    const firstWords = Object.keys(myFirstWordMap)
    const hasFirstWords = firstWords.length
    const catchAllParser = this.catchAllParserToJavascript
    if (!hasFirstWords && !catchAllParser && !regexRules.length) return ""
    const firstWordsStr = hasFirstWords
      ? `Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {` + firstWords.map(firstWord => `"${firstWord}" : ${myFirstWordMap[firstWord].parserIdFromDefinition}`).join(",\n") + "})"
      : "undefined"
    const regexStr = regexRules.length
      ? `[${regexRules
          .map(rule => {
            return `{regex: /${rule.regex}/, parser: ${rule.parser}}`
          })
          .join(",")}]`
      : "undefined"
    const catchAllStr = catchAllParser ? catchAllParser : this._amIRoot() ? `this._getBlobParserCatchAllParser()` : "undefined"
    const scopedParserJavascript = this.myScopedParserDefinitions.map(def => def.asJavascriptClass).join("\n\n")
    return `createParserCombinator() {${scopedParserJavascript}
  return new TreeNode.ParserCombinator(${catchAllStr}, ${firstWordsStr}, ${regexStr})
  }`
  }
  get myScopedParserDefinitions() {
    return this.getChildrenByParser(parserDefinitionParser)
  }
  get catchAllParserToJavascript() {
    if (this._isBlobParser()) return "this._getBlobParserCatchAllParser()"
    const parserId = this.get(GrammarConstants.catchAllParser)
    if (!parserId) return ""
    const nodeDef = this.getParserDefinitionByParserId(parserId)
    return nodeDef.generatedClassName
  }
  get asJavascriptClass() {
    const components = [this.parserAsJavascript, this.errorMethodToJavascript, this.cellGettersAndParserConstants, this.customJavascriptMethods].filter(identity => identity)
    const thisClassName = this.generatedClassName
    if (this._amIRoot()) {
      components.push(`static cachedHandGrammarProgramRoot = new HandGrammarProgram(\`${Utils.escapeBackTicks(this.parent.toString().replace(/\\/g, "\\\\"))}\`)
        get handGrammarProgram() {
          return this.constructor.cachedHandGrammarProgramRoot
      }`)
      components.push(`static rootParser = ${thisClassName}`)
    }
    return `class ${thisClassName} extends ${this._getExtendsClassName()} {
      ${components.join("\n")}
    }`
  }
  _getExtendsClassName() {
    // todo: this is hopefully a temporary line in place for now for the case where you want your base class to extend something other than another treeclass
    const hardCodedExtend = this.get(GrammarConstants._extendsJsClass)
    if (hardCodedExtend) return hardCodedExtend
    const extendedDef = this._getExtendedParent()
    return extendedDef ? extendedDef.generatedClassName : "GrammarBackedNode"
  }
  _getCompilerObject() {
    let obj = {}
    const items = this._getChildrenByParserInExtended(GrammarCompilerParser)
    items.reverse() // Last definition wins.
    items.forEach(node => {
      obj = Object.assign(obj, node.toObject()) // todo: what about multiline strings?
    })
    return obj
  }
  // todo: improve layout (use bold?)
  get lineHints() {
    return this.cellParser.lineHints
  }
  isOrExtendsAParserInScope(firstWordsInScope) {
    const chain = this._getParserInheritanceSet()
    return firstWordsInScope.some(firstWord => chain.has(firstWord))
  }
  isTerminalParser() {
    return !this._getFromExtended(GrammarConstants.inScope) && !this._getFromExtended(GrammarConstants.catchAllParser)
  }
  get sublimeMatchLine() {
    const regexMatch = this.regexMatch
    if (regexMatch) return `'${regexMatch}'`
    const cruxMatch = this.cruxIfAny
    if (cruxMatch) return `'^ *${Utils.escapeRegExp(cruxMatch)}(?: |$)'`
    const enumOptions = this.firstCellEnumOptions
    if (enumOptions) return `'^ *(${Utils.escapeRegExp(enumOptions.join("|"))})(?: |$)'`
  }
  // todo: refactor. move some parts to cellParser?
  _toSublimeMatchBlock() {
    const defaultHighlightScope = "source"
    const program = this.languageDefinitionProgram
    const cellParser = this.cellParser
    const requiredCellTypeIds = cellParser.getRequiredCellTypeIds()
    const catchAllCellTypeId = cellParser.catchAllCellTypeId
    const firstCellTypeDef = program.getCellTypeDefinitionById(requiredCellTypeIds[0])
    const firstWordHighlightScope = (firstCellTypeDef ? firstCellTypeDef.highlightScope : defaultHighlightScope) + "." + this.parserIdFromDefinition
    const topHalf = ` '${this.parserIdFromDefinition}':
  - match: ${this.sublimeMatchLine}
    scope: ${firstWordHighlightScope}`
    if (catchAllCellTypeId) requiredCellTypeIds.push(catchAllCellTypeId)
    if (!requiredCellTypeIds.length) return topHalf
    const captures = requiredCellTypeIds
      .map((cellTypeId, index) => {
        const cellTypeDefinition = program.getCellTypeDefinitionById(cellTypeId) // todo: cleanup
        if (!cellTypeDefinition) throw new Error(`No ${GrammarConstants.cellType} ${cellTypeId} found`) // todo: standardize error/capture error at grammar time
        return `        ${index + 1}: ${(cellTypeDefinition.highlightScope || defaultHighlightScope) + "." + cellTypeDefinition.cellTypeId}`
      })
      .join("\n")
    const cellTypesToRegex = cellTypeIds => cellTypeIds.map(cellTypeId => `({{${cellTypeId}}})?`).join(" ?")
    return `${topHalf}
    push:
     - match: ${cellTypesToRegex(requiredCellTypeIds)}
       captures:
${captures}
     - match: $
       pop: true`
  }
  _getParserInheritanceSet() {
    if (!this._cache_parserInheritanceSet) this._cache_parserInheritanceSet = new Set(this.ancestorParserIdsArray)
    return this._cache_parserInheritanceSet
  }
  get ancestorParserIdsArray() {
    if (!this._cache_ancestorParserIdsArray) {
      this._cache_ancestorParserIdsArray = this._getAncestorsArray().map(def => def.parserIdFromDefinition)
      this._cache_ancestorParserIdsArray.reverse()
    }
    return this._cache_ancestorParserIdsArray
  }
  get programParserDefinitionCache() {
    if (!this._cache_parserDefinitionParsers) this._cache_parserDefinitionParsers = this.isRoot || this.hasParserDefinitions ? this.makeProgramParserDefinitionCache() : this.parent.programParserDefinitionCache
    return this._cache_parserDefinitionParsers
  }
  get hasParserDefinitions() {
    return !!this.getChildrenByParser(parserDefinitionParser).length
  }
  makeProgramParserDefinitionCache() {
    const scopedParsers = this.getChildrenByParser(parserDefinitionParser)
    const cache = Object.assign({}, this.parent.programParserDefinitionCache) // todo. We don't really need this. we should just lookup the parent if no local hits.
    scopedParsers.forEach(parserDefinitionParser => (cache[parserDefinitionParser.parserIdFromDefinition] = parserDefinitionParser))
    return cache
  }
  get description() {
    return this._getFromExtended(GrammarConstants.description) || ""
  }
  get frequency() {
    const val = this._getFromExtended(GrammarConstants.frequency)
    return val ? parseFloat(val) : 0
  }
  _getExtendedParserId() {
    const ancestorIds = this.ancestorParserIdsArray
    if (ancestorIds.length > 1) return ancestorIds[ancestorIds.length - 2]
  }
  _toStumpString() {
    const crux = this.cruxIfAny
    const cellArray = this.cellParser.getCellArray().filter((item, index) => index) // for now this only works for keyword langs
    if (!cellArray.length)
      // todo: remove this! just doing it for now until we refactor getCellArray to handle catchAlls better.
      return ""
    const cells = new TreeNode(cellArray.map((cell, index) => cell._toStumpInput(crux)).join("\n"))
    return `div
 label ${crux}
${cells.toString(1)}`
  }
  toStumpString() {
    const nodeBreakSymbol = "\n"
    return this._getConcreteNonErrorInScopeNodeDefinitions(this._getInScopeParserIds())
      .map(def => def._toStumpString())
      .filter(identity => identity)
      .join(nodeBreakSymbol)
  }
  _generateSimulatedLine(seed) {
    // todo: generate simulated data from catch all
    const crux = this.cruxIfAny
    return this.cellParser
      .getCellArray()
      .map((cell, index) => (!index && crux ? crux : cell.synthesizeCell(seed)))
      .join(" ")
  }
  _shouldSynthesize(def, parserChain) {
    if (def._isErrorParser() || def._isAbstract()) return false
    if (parserChain.includes(def.id)) return false
    const tags = def.get(GrammarConstants.tags)
    if (tags && tags.includes(GrammarConstantsMisc.doNotSynthesize)) return false
    return true
  }
  // Get all definitions in this current scope down, even ones that are scoped inside other definitions.
  get inScopeAndDescendantDefinitions() {
    return this.languageDefinitionProgram._collectAllDefinitions(Object.values(this.programParserDefinitionCache), [])
  }
  _collectAllDefinitions(defs, collection = []) {
    defs.forEach(def => {
      collection.push(def)
      def._collectAllDefinitions(def.getChildrenByParser(parserDefinitionParser), collection)
    })
    return collection
  }
  get cruxPath() {
    const parentPath = this.parent.cruxPath
    return (parentPath ? parentPath + " " : "") + this.cruxIfAny
  }
  get cruxPathAsColumnName() {
    return this.cruxPath.replace(/ /g, "_")
  }
  // Get every definition that extends from this one, even ones that are scoped inside other definitions.
  get concreteDescendantDefinitions() {
    const { inScopeAndDescendantDefinitions, id } = this
    return Object.values(inScopeAndDescendantDefinitions).filter(def => def._doesExtend(id) && !def._isAbstract())
  }
  get concreteInScopeDescendantDefinitions() {
    // Note: non-recursive.
    const defs = this.programParserDefinitionCache
    const id = this.id
    return Object.values(defs).filter(def => def._doesExtend(id) && !def._isAbstract())
  }
  _getConcreteNonErrorInScopeNodeDefinitions(parserIds) {
    const defs = []
    parserIds.forEach(parserId => {
      const def = this.getParserDefinitionByParserId(parserId)
      if (def._isErrorParser()) return
      else if (def._isAbstract()) def.concreteInScopeDescendantDefinitions.forEach(def => defs.push(def))
      else defs.push(def)
    })
    return defs
  }
  // todo: refactor
  synthesizeNode(nodeCount = 1, indentCount = -1, parsersAlreadySynthesized = [], seed = Date.now()) {
    let inScopeParserIds = this._getInScopeParserIds()
    const catchAllParserId = this._getFromExtended(GrammarConstants.catchAllParser)
    if (catchAllParserId) inScopeParserIds.push(catchAllParserId)
    const thisId = this.id
    if (!parsersAlreadySynthesized.includes(thisId)) parsersAlreadySynthesized.push(thisId)
    const lines = []
    while (nodeCount) {
      const line = this._generateSimulatedLine(seed)
      if (line) lines.push(" ".repeat(indentCount >= 0 ? indentCount : 0) + line)
      this._getConcreteNonErrorInScopeNodeDefinitions(inScopeParserIds.filter(parserId => !parsersAlreadySynthesized.includes(parserId)))
        .filter(def => this._shouldSynthesize(def, parsersAlreadySynthesized))
        .forEach(def => {
          const chain = parsersAlreadySynthesized // .slice(0)
          chain.push(def.id)
          def.synthesizeNode(1, indentCount + 1, chain, seed).forEach(line => lines.push(line))
        })
      nodeCount--
    }
    return lines
  }
  get cellParser() {
    if (!this._cellParser) {
      const cellParsingStrategy = this._getFromExtended(GrammarConstants.cellParser)
      if (cellParsingStrategy === GrammarCellParser.postfix) this._cellParser = new PostfixCellParser(this)
      else if (cellParsingStrategy === GrammarCellParser.omnifix) this._cellParser = new OmnifixCellParser(this)
      else this._cellParser = new PrefixCellParser(this)
    }
    return this._cellParser
  }
}
// todo: remove?
class parserDefinitionParser extends AbstractParserDefinitionParser {}
// HandGrammarProgram is a constructor that takes a grammar file, and builds a new
// constructor for new language that takes files in that language to execute, compile, etc.
class HandGrammarProgram extends AbstractParserDefinitionParser {
  createParserCombinator() {
    const map = {}
    map[GrammarConstants.comment] = TreeNode
    return new TreeNode.ParserCombinator(UnknownParserNode, map, [
      { regex: HandGrammarProgram.blankLineRegex, parser: TreeNode },
      { regex: HandGrammarProgram.parserFullRegex, parser: parserDefinitionParser },
      { regex: HandGrammarProgram.cellTypeFullRegex, parser: cellTypeDefinitionParser }
    ])
  }
  // rootParser
  // Note: this is some so far unavoidable tricky code. We need to eval the transpiled JS, in a NodeJS or browser environment.
  _compileAndReturnRootParser() {
    if (this._cache_rootParser) return this._cache_rootParser
    if (!this.isNodeJs()) {
      this._cache_rootParser = Utils.appendCodeAndReturnValueOnWindow(this.toBrowserJavascript(), this.rootParserId).rootParser
      return this._cache_rootParser
    }
    const path = require("path")
    const code = this.toNodeJsJavascript(__dirname)
    try {
      const rootNode = this._requireInVmNodeJsRootParser(code)
      this._cache_rootParser = rootNode.rootParser
      if (!this._cache_rootParser) throw new Error(`Failed to rootParser`)
    } catch (err) {
      // todo: figure out best error pattern here for debugging
      console.log(err)
      // console.log(`Error in code: `)
      // console.log(new TreeNode(code).toStringWithLineNumbers())
    }
    return this._cache_rootParser
  }
  get cruxPath() {
    return ""
  }
  trainModel(programs, rootParser = this.compileAndReturnRootParser()) {
    const nodeDefs = this.validConcreteAndAbstractParserDefinitions
    const nodeDefCountIncludingRoot = nodeDefs.length + 1
    const matrix = Utils.makeMatrix(nodeDefCountIncludingRoot, nodeDefCountIncludingRoot, 0)
    const idToIndex = {}
    const indexToId = {}
    nodeDefs.forEach((def, index) => {
      const id = def.id
      idToIndex[id] = index + 1
      indexToId[index + 1] = id
    })
    programs.forEach(code => {
      const exampleProgram = new rootParser(code)
      exampleProgram.topDownArray.forEach(node => {
        const nodeIndex = idToIndex[node.definition.id]
        const parentNode = node.parent
        if (!nodeIndex) return undefined
        if (parentNode.isRoot()) matrix[0][nodeIndex]++
        else {
          const parentIndex = idToIndex[parentNode.definition.id]
          if (!parentIndex) return undefined
          matrix[parentIndex][nodeIndex]++
        }
      })
    })
    return {
      idToIndex,
      indexToId,
      matrix
    }
  }
  _mapPredictions(predictionsVector, model) {
    const total = Utils.sum(predictionsVector)
    const predictions = predictionsVector.slice(1).map((count, index) => {
      const id = model.indexToId[index + 1]
      return {
        id,
        def: this.getParserDefinitionByParserId(id),
        count,
        prob: count / total
      }
    })
    predictions.sort(Utils.makeSortByFn(prediction => prediction.count)).reverse()
    return predictions
  }
  predictChildren(model, node) {
    return this._mapPredictions(this._predictChildren(model, node), model)
  }
  predictParents(model, node) {
    return this._mapPredictions(this._predictParents(model, node), model)
  }
  _predictChildren(model, node) {
    return model.matrix[node.isRoot() ? 0 : model.idToIndex[node.definition.id]]
  }
  _predictParents(model, node) {
    if (node.isRoot()) return []
    const nodeIndex = model.idToIndex[node.definition.id]
    return model.matrix.map(row => row[nodeIndex])
  }
  _setDirName(name) {
    this._dirName = name
    return this
  }
  _requireInVmNodeJsRootParser(code) {
    const vm = require("vm")
    const path = require("path")
    // todo: cleanup up
    try {
      Object.keys(GlobalNamespaceAdditions).forEach(key => {
        global[key] = require("./" + GlobalNamespaceAdditions[key])
      })
      global.require = require
      global.__dirname = this._dirName
      global.module = {}
      return vm.runInThisContext(code)
    } catch (err) {
      // todo: figure out best error pattern here for debugging
      console.log(`Error in compiled grammar code for language "${this.grammarName}"`)
      // console.log(new TreeNode(code).toStringWithLineNumbers())
      console.log(err)
      throw err
    }
  }
  examplesToTestBlocks(rootParser = this.compileAndReturnRootParser(), expectedErrorMessage = "") {
    const testBlocks = {}
    this.validConcreteAndAbstractParserDefinitions.forEach(def =>
      def.examples.forEach(example => {
        const id = def.id + example.content
        testBlocks[id] = equal => {
          const exampleProgram = new rootParser(example.childrenToString())
          const errors = exampleProgram.getAllErrors(example._getLineNumber() + 1)
          equal(errors.join("\n"), expectedErrorMessage, `Expected no errors in ${id}`)
        }
      })
    )
    return testBlocks
  }
  toReadMe() {
    const languageName = this.extensionName
    const rootNodeDef = this.rootParserDefinition
    const cellTypes = this.cellTypeDefinitions
    const parserFamilyTree = this.parserFamilyTree
    const exampleNode = rootNodeDef.examples[0]
    return `title ${languageName} Readme

paragraph ${rootNodeDef.description}

subtitle Quick Example

code
${exampleNode ? exampleNode.childrenToString(1) : ""}

subtitle Quick facts about ${languageName}

list
 - ${languageName} has ${parserFamilyTree.topDownArray.length} node types.
 - ${languageName} has ${Object.keys(cellTypes).length} cell types
 - The source code for ${languageName} is ${this.topDownArray.length} lines long.

subtitle Installing

code
 npm install .

subtitle Testing

code
 node test.js

subtitle Node Types

code
${parserFamilyTree.toString(1)}

subtitle Cell Types

code
${new TreeNode(Object.keys(cellTypes).join("\n")).toString(1)}

subtitle Road Map

paragraph Here are the "todos" present in the source code for ${languageName}:

list
${this.topDownArray
  .filter(node => node.getWord(0) === "todo")
  .map(node => ` - ${node.getLine()}`)
  .join("\n")}

paragraph This readme was auto-generated using the
 link https://github.com/treenotation/jtree JTree library.`
  }
  toBundle() {
    const files = {}
    const rootNodeDef = this.rootParserDefinition
    const languageName = this.extensionName
    const example = rootNodeDef.examples[0]
    const sampleCode = example ? example.childrenToString() : ""
    files[GrammarBundleFiles.package] = JSON.stringify(
      {
        name: languageName,
        private: true,
        dependencies: {
          jtree: TreeNode.getVersion()
        }
      },
      null,
      2
    )
    files[GrammarBundleFiles.readme] = this.toReadMe()
    const testCode = `const program = new ${languageName}(sampleCode)
const errors = program.getAllErrors()
console.log("Sample program compiled with " + errors.length + " errors.")
if (errors.length)
 console.log(errors.map(error => error.message))`
    const nodePath = `${languageName}.node.js`
    files[nodePath] = this.toNodeJsJavascript()
    files[GrammarBundleFiles.indexJs] = `module.exports = require("./${nodePath}")`
    const browserPath = `${languageName}.browser.js`
    files[browserPath] = this.toBrowserJavascript()
    files[GrammarBundleFiles.indexHtml] = `<script src="node_modules/jtree/products/Utils.browser.js"></script>
<script src="node_modules/jtree/products/TreeNode.browser.js"></script>
<script src="node_modules/jtree/products/GrammarLanguage.browser.js"></script>
<script src="${browserPath}"></script>
<script>
const sampleCode = \`${sampleCode.toString()}\`
${testCode}
</script>`
    const samplePath = "sample." + this.extensionName
    files[samplePath] = sampleCode.toString()
    files[GrammarBundleFiles.testJs] = `const ${languageName} = require("./index.js")
/*keep-line*/ const sampleCode = require("fs").readFileSync("${samplePath}", "utf8")
${testCode}`
    return files
  }
  get targetExtension() {
    return this.rootParserDefinition.get(GrammarConstants.compilesTo)
  }
  get cellTypeDefinitions() {
    if (this._cache_cellTypes) return this._cache_cellTypes
    const types = {}
    // todo: add built in word types?
    this.getChildrenByParser(cellTypeDefinitionParser).forEach(type => (types[type.cellTypeId] = type))
    this._cache_cellTypes = types
    return types
  }
  getCellTypeDefinitionById(cellTypeId) {
    // todo: return unknownCellTypeDefinition? or is that handled somewhere else?
    return this.cellTypeDefinitions[cellTypeId]
  }
  get parserFamilyTree() {
    const tree = new TreeNode()
    Object.values(this.validConcreteAndAbstractParserDefinitions).forEach(node => tree.touchNode(node.ancestorParserIdsArray.join(" ")))
    return tree
  }
  get languageDefinitionProgram() {
    return this
  }
  get validConcreteAndAbstractParserDefinitions() {
    return this.getChildrenByParser(parserDefinitionParser).filter(node => node._hasValidParserId())
  }
  get lastRootParserDefinitionNode() {
    return this.findLast(def => def instanceof AbstractParserDefinitionParser && def.has(GrammarConstants.root) && def._hasValidParserId())
  }
  _initRootParserDefinitionNode() {
    if (this._cache_rootParserNode) return
    if (!this._cache_rootParserNode) this._cache_rootParserNode = this.lastRootParserDefinitionNode
    // By default, have a very permissive basic root node.
    // todo: whats the best design pattern to use for this sort of thing?
    if (!this._cache_rootParserNode) {
      this._cache_rootParserNode = this.concat(`${GrammarConstants.DefaultRootParser}
 ${GrammarConstants.root}
 ${GrammarConstants.catchAllParser} ${GrammarConstants.BlobParser}`)[0]
      this._addDefaultCatchAllBlobParser()
    }
  }
  get rootParserDefinition() {
    this._initRootParserDefinitionNode()
    return this._cache_rootParserNode
  }
  _addDefaultCatchAllBlobParser() {
    if (this._addedCatchAll) return
    this._addedCatchAll = true
    delete this._cache_parserDefinitionParsers
    this.concat(`${GrammarConstants.BlobParser}
 ${GrammarConstants.baseParser} ${GrammarConstants.blobParser}`)
  }
  get extensionName() {
    return this.grammarName
  }
  get id() {
    return this.rootParserId
  }
  get rootParserId() {
    return this.rootParserDefinition.parserIdFromDefinition
  }
  get grammarName() {
    return this.rootParserId.replace(HandGrammarProgram.parserSuffixRegex, "")
  }
  _getMyInScopeParserIds() {
    return super._getMyInScopeParserIds(this.rootParserDefinition)
  }
  _getInScopeParserIds() {
    const parsersNode = this.rootParserDefinition.getNode(GrammarConstants.inScope)
    return parsersNode ? parsersNode.getWordsFrom(1) : []
  }
  makeProgramParserDefinitionCache() {
    const cache = {}
    this.getChildrenByParser(parserDefinitionParser).forEach(parserDefinitionParser => (cache[parserDefinitionParser.parserIdFromDefinition] = parserDefinitionParser))
    return cache
  }
  compileAndReturnRootParser() {
    if (!this._cached_rootParser) {
      const rootDef = this.rootParserDefinition
      this._cached_rootParser = rootDef.languageDefinitionProgram._compileAndReturnRootParser()
    }
    return this._cached_rootParser
  }
  get fileExtensions() {
    return this.rootParserDefinition.get(GrammarConstants.extensions) ? this.rootParserDefinition.get(GrammarConstants.extensions).split(" ").join(",") : this.extensionName
  }
  toNodeJsJavascript(jtreeProductsPath = "jtree/products") {
    return this._rootNodeDefToJavascriptClass(jtreeProductsPath, true).trim()
  }
  toBrowserJavascript() {
    return this._rootNodeDefToJavascriptClass("", false).trim()
  }
  _rootNodeDefToJavascriptClass(jtreeProductsPath, forNodeJs = true) {
    const defs = this.validConcreteAndAbstractParserDefinitions
    // todo: throw if there is no root node defined
    const parserClasses = defs.map(def => def.asJavascriptClass).join("\n\n")
    const rootDef = this.rootParserDefinition
    const rootNodeJsHeader = forNodeJs && rootDef._getConcatBlockStringFromExtended(GrammarConstants._rootNodeJsHeader)
    const rootName = rootDef.generatedClassName
    if (!rootName) throw new Error(`Root Node Type Has No Name`)
    let exportScript = ""
    if (forNodeJs)
      exportScript = `module.exports = ${rootName};
${rootName}`
    else exportScript = `window.${rootName} = ${rootName}`
    let nodeJsImports = ``
    if (forNodeJs)
      nodeJsImports = Object.keys(GlobalNamespaceAdditions)
        .map(key => `const { ${key} } = require("${jtreeProductsPath}/${GlobalNamespaceAdditions[key]}")`)
        .join("\n")
    // todo: we can expose the previous "constants" export, if needed, via the grammar, which we preserve.
    return `{
${nodeJsImports}
${rootNodeJsHeader ? rootNodeJsHeader : ""}
${parserClasses}

${exportScript}
}
`
  }
  toSublimeSyntaxFile() {
    const cellTypeDefs = this.cellTypeDefinitions
    const variables = Object.keys(cellTypeDefs)
      .map(name => ` ${name}: '${cellTypeDefs[name].regexString}'`)
      .join("\n")
    const defs = this.validConcreteAndAbstractParserDefinitions.filter(kw => !kw._isAbstract())
    const parserContexts = defs.map(def => def._toSublimeMatchBlock()).join("\n\n")
    const includes = defs.map(parserDef => `  - include: '${parserDef.parserIdFromDefinition}'`).join("\n")
    return `%YAML 1.2
---
name: ${this.extensionName}
file_extensions: [${this.fileExtensions}]
scope: source.${this.extensionName}

variables:
${variables}

contexts:
 main:
${includes}

${parserContexts}`
  }
}
HandGrammarProgram.makeParserId = str => Utils._replaceNonAlphaNumericCharactersWithCharCodes(str).replace(HandGrammarProgram.parserSuffixRegex, "") + GrammarConstants.parserSuffix
HandGrammarProgram.makeCellTypeId = str => Utils._replaceNonAlphaNumericCharactersWithCharCodes(str).replace(HandGrammarProgram.cellTypeSuffixRegex, "") + GrammarConstants.cellTypeSuffix
HandGrammarProgram.parserSuffixRegex = new RegExp(GrammarConstants.parserSuffix + "$")
HandGrammarProgram.parserFullRegex = new RegExp("^[a-zA-Z0-9_]+" + GrammarConstants.parserSuffix + "$")
HandGrammarProgram.blankLineRegex = new RegExp("^$")
HandGrammarProgram.cellTypeSuffixRegex = new RegExp(GrammarConstants.cellTypeSuffix + "$")
HandGrammarProgram.cellTypeFullRegex = new RegExp("^[a-zA-Z0-9_]+" + GrammarConstants.cellTypeSuffix + "$")
HandGrammarProgram._languages = {}
HandGrammarProgram._parsers = {}
const PreludeKinds = {}
PreludeKinds[PreludeCellTypeIds.anyCell] = GrammarAnyCell
PreludeKinds[PreludeCellTypeIds.keywordCell] = GrammarKeywordCell
PreludeKinds[PreludeCellTypeIds.floatCell] = GrammarFloatCell
PreludeKinds[PreludeCellTypeIds.numberCell] = GrammarFloatCell
PreludeKinds[PreludeCellTypeIds.bitCell] = GrammarBitCell
PreludeKinds[PreludeCellTypeIds.boolCell] = GrammarBoolCell
PreludeKinds[PreludeCellTypeIds.intCell] = GrammarIntCell
class UnknownGrammarProgram extends TreeNode {
  _inferRootNodeForAPrefixLanguage(grammarName) {
    grammarName = HandGrammarProgram.makeParserId(grammarName)
    const rootNode = new TreeNode(`${grammarName}
 ${GrammarConstants.root}`)
    // note: right now we assume 1 global cellTypeMap and parserMap per grammar. But we may have scopes in the future?
    const rootNodeNames = this.getFirstWords()
      .filter(identity => identity)
      .map(word => HandGrammarProgram.makeParserId(word))
    rootNode
      .nodeAt(0)
      .touchNode(GrammarConstants.inScope)
      .setWordsFrom(1, Array.from(new Set(rootNodeNames)))
    return rootNode
  }
  _renameIntegerKeywords(clone) {
    // todo: why are we doing this?
    for (let node of clone.getTopDownArrayIterator()) {
      const firstWordIsAnInteger = !!node.firstWord.match(/^\d+$/)
      const parentFirstWord = node.parent.firstWord
      if (firstWordIsAnInteger && parentFirstWord) node.setFirstWord(HandGrammarProgram.makeParserId(parentFirstWord + UnknownGrammarProgram._childSuffix))
    }
  }
  _getKeywordMaps(clone) {
    const keywordsToChildKeywords = {}
    const keywordsToNodeInstances = {}
    for (let node of clone.getTopDownArrayIterator()) {
      const firstWord = node.firstWord
      if (!keywordsToChildKeywords[firstWord]) keywordsToChildKeywords[firstWord] = {}
      if (!keywordsToNodeInstances[firstWord]) keywordsToNodeInstances[firstWord] = []
      keywordsToNodeInstances[firstWord].push(node)
      node.forEach(child => (keywordsToChildKeywords[firstWord][child.firstWord] = true))
    }
    return { keywordsToChildKeywords: keywordsToChildKeywords, keywordsToNodeInstances: keywordsToNodeInstances }
  }
  _inferParserDef(firstWord, globalCellTypeMap, childFirstWords, instances) {
    const edgeSymbol = this.edgeSymbol
    const parserId = HandGrammarProgram.makeParserId(firstWord)
    const nodeDefNode = new TreeNode(parserId).nodeAt(0)
    const childParserIds = childFirstWords.map(word => HandGrammarProgram.makeParserId(word))
    if (childParserIds.length) nodeDefNode.touchNode(GrammarConstants.inScope).setWordsFrom(1, childParserIds)
    const cellsForAllInstances = instances
      .map(line => line.content)
      .filter(identity => identity)
      .map(line => line.split(edgeSymbol))
    const instanceCellCounts = new Set(cellsForAllInstances.map(cells => cells.length))
    const maxCellsOnLine = Math.max(...Array.from(instanceCellCounts))
    const minCellsOnLine = Math.min(...Array.from(instanceCellCounts))
    let catchAllCellType
    let cellTypeIds = []
    for (let cellIndex = 0; cellIndex < maxCellsOnLine; cellIndex++) {
      const cellType = this._getBestCellType(
        firstWord,
        instances.length,
        maxCellsOnLine,
        cellsForAllInstances.map(cells => cells[cellIndex])
      )
      if (!globalCellTypeMap.has(cellType.cellTypeId)) globalCellTypeMap.set(cellType.cellTypeId, cellType.cellTypeDefinition)
      cellTypeIds.push(cellType.cellTypeId)
    }
    if (maxCellsOnLine > minCellsOnLine) {
      //columns = columns.slice(0, min)
      catchAllCellType = cellTypeIds.pop()
      while (cellTypeIds[cellTypeIds.length - 1] === catchAllCellType) {
        cellTypeIds.pop()
      }
    }
    const needsCruxProperty = !firstWord.endsWith(UnknownGrammarProgram._childSuffix + GrammarConstants.parserSuffix) // todo: cleanup
    if (needsCruxProperty) nodeDefNode.set(GrammarConstants.crux, firstWord)
    if (catchAllCellType) nodeDefNode.set(GrammarConstants.catchAllCellType, catchAllCellType)
    const cellLine = cellTypeIds.slice()
    cellLine.unshift(PreludeCellTypeIds.keywordCell)
    if (cellLine.length > 0) nodeDefNode.set(GrammarConstants.cells, cellLine.join(edgeSymbol))
    //if (!catchAllCellType && cellTypeIds.length === 1) nodeDefNode.set(GrammarConstants.cells, cellTypeIds[0])
    // Todo: add conditional frequencies
    return nodeDefNode.parent.toString()
  }
  //  inferGrammarFileForAnSSVLanguage(grammarName: string): string {
  //     grammarName = HandGrammarProgram.makeParserId(grammarName)
  //    const rootNode = new TreeNode(`${grammarName}
  // ${GrammarConstants.root}`)
  //    // note: right now we assume 1 global cellTypeMap and parserMap per grammar. But we may have scopes in the future?
  //    const rootNodeNames = this.getFirstWords().map(word => HandGrammarProgram.makeParserId(word))
  //    rootNode
  //      .nodeAt(0)
  //      .touchNode(GrammarConstants.inScope)
  //      .setWordsFrom(1, Array.from(new Set(rootNodeNames)))
  //    return rootNode
  //  }
  inferGrammarFileForAKeywordLanguage(grammarName) {
    const clone = this.clone()
    this._renameIntegerKeywords(clone)
    const { keywordsToChildKeywords, keywordsToNodeInstances } = this._getKeywordMaps(clone)
    const globalCellTypeMap = new Map()
    globalCellTypeMap.set(PreludeCellTypeIds.keywordCell, undefined)
    const parserDefs = Object.keys(keywordsToChildKeywords)
      .filter(identity => identity)
      .map(firstWord => this._inferParserDef(firstWord, globalCellTypeMap, Object.keys(keywordsToChildKeywords[firstWord]), keywordsToNodeInstances[firstWord]))
    const cellTypeDefs = []
    globalCellTypeMap.forEach((def, id) => cellTypeDefs.push(def ? def : id))
    const nodeBreakSymbol = this.nodeBreakSymbol
    return this._formatCode([this._inferRootNodeForAPrefixLanguage(grammarName).toString(), cellTypeDefs.join(nodeBreakSymbol), parserDefs.join(nodeBreakSymbol)].filter(identity => identity).join("\n"))
  }
  _formatCode(code) {
    // todo: make this run in browser too
    if (!this.isNodeJs()) return code
    const grammarProgram = new HandGrammarProgram(TreeNode.fromDisk(__dirname + "/../langs/grammar/grammar.grammar"))
    const rootParser = grammarProgram.compileAndReturnRootParser()
    const program = new rootParser(code)
    return program.format().toString()
  }
  _getBestCellType(firstWord, instanceCount, maxCellsOnLine, allValues) {
    const asSet = new Set(allValues)
    const edgeSymbol = this.edgeSymbol
    const values = Array.from(asSet).filter(identity => identity)
    const every = fn => {
      for (let index = 0; index < values.length; index++) {
        if (!fn(values[index])) return false
      }
      return true
    }
    if (every(str => str === "0" || str === "1")) return { cellTypeId: PreludeCellTypeIds.bitCell }
    if (
      every(str => {
        const num = parseInt(str)
        if (isNaN(num)) return false
        return num.toString() === str
      })
    ) {
      return { cellTypeId: PreludeCellTypeIds.intCell }
    }
    if (every(str => str.match(/^-?\d*.?\d+$/))) return { cellTypeId: PreludeCellTypeIds.floatCell }
    const bools = new Set(["1", "0", "true", "false", "t", "f", "yes", "no"])
    if (every(str => bools.has(str.toLowerCase()))) return { cellTypeId: PreludeCellTypeIds.boolCell }
    // todo: cleanup
    const enumLimit = 30
    if (instanceCount > 1 && maxCellsOnLine === 1 && allValues.length > asSet.size && asSet.size < enumLimit)
      return {
        cellTypeId: HandGrammarProgram.makeCellTypeId(firstWord),
        cellTypeDefinition: `${HandGrammarProgram.makeCellTypeId(firstWord)}
 enum ${values.join(edgeSymbol)}`
      }
    return { cellTypeId: PreludeCellTypeIds.anyCell }
  }
}
UnknownGrammarProgram._childSuffix = "Child"
window.GrammarConstants = GrammarConstants
window.PreludeCellTypeIds = PreludeCellTypeIds
window.HandGrammarProgram = HandGrammarProgram
window.GrammarBackedNode = GrammarBackedNode
window.UnknownParserError = UnknownParserError
window.UnknownGrammarProgram = UnknownGrammarProgram
;

"use strict"
// Adapted from https://github.com/NeekSandhu/codemirror-textmate/blob/master/src/tmToCm.ts
var CmToken
;(function (CmToken) {
  CmToken["Atom"] = "atom"
  CmToken["Attribute"] = "attribute"
  CmToken["Bracket"] = "bracket"
  CmToken["Builtin"] = "builtin"
  CmToken["Comment"] = "comment"
  CmToken["Def"] = "def"
  CmToken["Error"] = "error"
  CmToken["Header"] = "header"
  CmToken["HR"] = "hr"
  CmToken["Keyword"] = "keyword"
  CmToken["Link"] = "link"
  CmToken["Meta"] = "meta"
  CmToken["Number"] = "number"
  CmToken["Operator"] = "operator"
  CmToken["Property"] = "property"
  CmToken["Qualifier"] = "qualifier"
  CmToken["Quote"] = "quote"
  CmToken["String"] = "string"
  CmToken["String2"] = "string-2"
  CmToken["Tag"] = "tag"
  CmToken["Type"] = "type"
  CmToken["Variable"] = "variable"
  CmToken["Variable2"] = "variable-2"
  CmToken["Variable3"] = "variable-3"
})(CmToken || (CmToken = {}))
const tmToCm = {
  comment: {
    $: CmToken.Comment
  },
  constant: {
    // TODO: Revision
    $: CmToken.Def,
    character: {
      escape: {
        $: CmToken.String2
      }
    },
    language: {
      $: CmToken.Atom
    },
    numeric: {
      $: CmToken.Number
    },
    other: {
      email: {
        link: {
          $: CmToken.Link
        }
      },
      symbol: {
        // TODO: Revision
        $: CmToken.Def
      }
    }
  },
  entity: {
    name: {
      class: {
        $: CmToken.Def
      },
      function: {
        $: CmToken.Def
      },
      tag: {
        $: CmToken.Tag
      },
      type: {
        $: CmToken.Type,
        class: {
          $: CmToken.Variable
        }
      }
    },
    other: {
      "attribute-name": {
        $: CmToken.Attribute
      },
      "inherited-class": {
        // TODO: Revision
        $: CmToken.Def
      }
    },
    support: {
      function: {
        // TODO: Revision
        $: CmToken.Def
      }
    }
  },
  invalid: {
    $: CmToken.Error,
    illegal: { $: CmToken.Error },
    deprecated: {
      $: CmToken.Error
    }
  },
  keyword: {
    $: CmToken.Keyword,
    operator: {
      $: CmToken.Operator
    },
    other: {
      "special-method": CmToken.Def
    }
  },
  punctuation: {
    $: CmToken.Operator,
    definition: {
      comment: {
        $: CmToken.Comment
      },
      tag: {
        $: CmToken.Bracket
      }
      // 'template-expression': {
      //     $: CodeMirrorToken.Operator,
      // },
    }
    // terminator: {
    //     $: CodeMirrorToken.Operator,
    // },
  },
  storage: {
    $: CmToken.Keyword
  },
  string: {
    $: CmToken.String,
    regexp: {
      $: CmToken.String2
    }
  },
  support: {
    class: {
      $: CmToken.Def
    },
    constant: {
      $: CmToken.Variable2
    },
    function: {
      $: CmToken.Def
    },
    type: {
      $: CmToken.Type
    },
    variable: {
      $: CmToken.Variable2,
      property: {
        $: CmToken.Property
      }
    }
  },
  variable: {
    $: CmToken.Def,
    language: {
      // TODO: Revision
      $: CmToken.Variable3
    },
    other: {
      object: {
        $: CmToken.Variable,
        property: {
          $: CmToken.Property
        }
      },
      property: {
        $: CmToken.Property
      }
    },
    parameter: {
      $: CmToken.Def
    }
  }
}
const textMateScopeToCodeMirrorStyle = (scopeSegments, styleTree = tmToCm) => {
  const matchingBranch = styleTree[scopeSegments.shift()]
  return matchingBranch ? textMateScopeToCodeMirrorStyle(scopeSegments, matchingBranch) || matchingBranch.$ || null : null
}
class GrammarCodeMirrorMode {
  constructor(name, getRootParserFn, getProgramCodeFn, codeMirrorLib = undefined) {
    this._name = name
    this._getRootParserFn = getRootParserFn
    this._getProgramCodeFn = getProgramCodeFn || (instance => (instance ? instance.getValue() : this._originalValue))
    this._codeMirrorLib = codeMirrorLib
  }
  _getParsedProgram() {
    const source = this._getProgramCodeFn(this._cmInstance) || ""
    if (!this._cachedProgram || this._cachedSource !== source) {
      this._cachedSource = source
      this._cachedProgram = new (this._getRootParserFn())(source)
    }
    return this._cachedProgram
  }
  _getExcludedIntelliSenseTriggerKeys() {
    return {
      8: "backspace",
      9: "tab",
      13: "enter",
      16: "shift",
      17: "ctrl",
      18: "alt",
      19: "pause",
      20: "capslock",
      27: "escape",
      33: "pageup",
      34: "pagedown",
      35: "end",
      36: "home",
      37: "left",
      38: "up",
      39: "right",
      40: "down",
      45: "insert",
      46: "delete",
      91: "left window key",
      92: "right window key",
      93: "select",
      112: "f1",
      113: "f2",
      114: "f3",
      115: "f4",
      116: "f5",
      117: "f6",
      118: "f7",
      119: "f8",
      120: "f9",
      121: "f10",
      122: "f11",
      123: "f12",
      144: "numlock",
      145: "scrolllock"
    }
  }
  token(stream, state) {
    return this._advanceStreamAndReturnTokenType(stream, state)
  }
  fromTextAreaWithAutocomplete(area, options) {
    this._originalValue = area.value
    const defaultOptions = {
      lineNumbers: true,
      mode: this._name,
      tabSize: 1,
      indentUnit: 1,
      hintOptions: {
        hint: (cmInstance, options) => this.codeMirrorAutocomplete(cmInstance, options)
      }
    }
    Object.assign(defaultOptions, options)
    this._cmInstance = this._getCodeMirrorLib().fromTextArea(area, defaultOptions)
    this._enableAutoComplete(this._cmInstance)
    return this._cmInstance
  }
  _enableAutoComplete(cmInstance) {
    const excludedKeys = this._getExcludedIntelliSenseTriggerKeys()
    const codeMirrorLib = this._getCodeMirrorLib()
    cmInstance.on("keyup", (cm, event) => {
      // https://stackoverflow.com/questions/13744176/codemirror-autocomplete-after-any-keyup
      if (!cm.state.completionActive && !excludedKeys[event.keyCode.toString()])
        // Todo: get typings for CM autocomplete
        codeMirrorLib.commands.autocomplete(cm, null, { completeSingle: false })
    })
  }
  _getCodeMirrorLib() {
    return this._codeMirrorLib
  }
  async codeMirrorAutocomplete(cmInstance, options) {
    const cursor = cmInstance.getDoc().getCursor()
    const codeMirrorLib = this._getCodeMirrorLib()
    const result = await this._getParsedProgram().getAutocompleteResultsAt(cursor.line, cursor.ch)
    // It seems to be better UX if there's only 1 result, and its the word the user entered, to close autocomplete
    if (result.matches.length === 1 && result.matches[0].text === result.word) return null
    return result.matches.length
      ? {
          list: result.matches,
          from: codeMirrorLib.Pos(cursor.line, result.startCharIndex),
          to: codeMirrorLib.Pos(cursor.line, result.endCharIndex)
        }
      : null
  }
  register() {
    const codeMirrorLib = this._getCodeMirrorLib()
    codeMirrorLib.defineMode(this._name, () => this)
    codeMirrorLib.defineMIME("text/" + this._name, this._name)
    return this
  }
  _advanceStreamAndReturnTokenType(stream, state) {
    let nextCharacter = stream.next()
    const lineNumber = stream.lineOracle.line + 1 // state.lineIndex
    const WordBreakSymbol = " "
    const NodeBreakSymbol = "\n"
    while (typeof nextCharacter === "string") {
      const peek = stream.peek()
      if (nextCharacter === WordBreakSymbol) {
        if (peek === undefined || peek === NodeBreakSymbol) {
          stream.skipToEnd() // advance string to end
          this._incrementLine(state)
        }
        if (peek === WordBreakSymbol && state.cellIndex) {
          // If we are missing a cell.
          // TODO: this is broken for a blank 1st cell. We need to track WordBreakSymbol level.
          state.cellIndex++
        }
        return "bracket"
      }
      if (peek === WordBreakSymbol) {
        state.cellIndex++
        return this._getCellStyle(lineNumber, state.cellIndex)
      }
      nextCharacter = stream.next()
    }
    state.cellIndex++
    const style = this._getCellStyle(lineNumber, state.cellIndex)
    this._incrementLine(state)
    return style
  }
  _getCellStyle(lineIndex, cellIndex) {
    const program = this._getParsedProgram()
    // todo: if the current word is an error, don't show red?
    if (!program.getCellHighlightScopeAtPosition) console.log(program)
    const highlightScope = program.getCellHighlightScopeAtPosition(lineIndex, cellIndex)
    const style = highlightScope ? textMateScopeToCodeMirrorStyle(highlightScope.split(".")) : undefined
    return style || "noHighlightScopeDefinedInGrammar"
  }
  // todo: remove.
  startState() {
    return {
      cellIndex: 0
    }
  }
  _incrementLine(state) {
    state.cellIndex = 0
  }
}
window.GrammarCodeMirrorMode = GrammarCodeMirrorMode
;

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// This is CodeMirror (https://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.CodeMirror = factory());
}(this, (function () { 'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) { presto_version = Number(presto_version[1]); }
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

  var rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      { e.removeChild(e.firstChild); }
    return e
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e)
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) { e.className = className; }
    if (style) { e.style.cssText = style; }
    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
    return e
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e
  }

  var range;
  if (document.createRange) { range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r
  }; }
  else { range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r
  }; }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      { child = child.parentNode; }
    if (parent.contains)
      { return parent.contains(child) }
    do {
      if (child.nodeType == 11) { child = child.host; }
      if (child == parent) { return true }
    } while (child = child.parentNode)
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch(e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
      { activeElement = activeElement.shadowRoot.activeElement; }
    return activeElement
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
    return b
  }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
  else if (ie) // Suppress mysterious IE10 errors
    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args)}
  }

  function copyObj(obj, target, overwrite) {
    if (!target) { target = {}; }
    for (var prop in obj)
      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        { target[prop] = obj[prop]; } }
    return target
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) { end = string.length; }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        { return n + (end - i) }
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  }

  var Delayed = function() {this.id = null;};
  Delayed.prototype.set = function (ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      { if (array[i] == elt) { return i } }
    return -1
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = {toString: function(){return "CodeMirror.Pass"}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) { nextTab = string.length; }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        { return pos + Math.min(skipped, goal - col) }
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) { return pos }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      { spaceStrs.push(lst(spaceStrs) + " "); }
    return spaceStrs[n]
  }

  function lst(arr) { return arr[arr.length-1] }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
    return out
  }

  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) { copyObj(props, inst); }
    return inst
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
  }
  function isWordChar(ch, helper) {
    if (!helper) { return isWordCharBasic(ch) }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
    return helper.test(ch)
  }

  function isEmpty(obj) {
    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
    return true
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
    return pos
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) { return from }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) { return pred(mid) ? from : to }
      if (pred(mid)) { to = mid; }
      else { from = mid + dir; }
    }
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

    if (place) {
      if (place.appendChild) { place.appendChild(d.wrapper); }
      else { place(d.wrapper); }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    input.init(d);
  }

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break }
        n -= sz;
      }
    }
    return chunk.lines[n]
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) { text = text.slice(0, end.ch); }
      if (n == start.line) { text = text.slice(start.ch); }
      out.push(text);
      ++n;
    });
    return out
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
    return out
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) { return null }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) { break }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1], ch = child.height;
        if (h < ch) { chunk = child; continue outer }
        h -= ch;
        n += child.chunkSize();
      }
      return n
    } while (!chunk.lines)
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) { break }
      h -= lh;
    }
    return n + i
  }

  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber))
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if ( sticky === void 0 ) sticky = null;

    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

  function copyPos(x) {return Pos(x.line, x.ch)}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) { return Pos(doc.first, 0) }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
    return clipToLen(pos, getLine(doc, pos.line).text.length)
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
    else if (ch < 0) { return Pos(pos.line, 0) }
    else { return pos }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
    return out
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) { return span }
    } }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i)
      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
    return r
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    } }
    return nw
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    } }
    return nw
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) { return null }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) { return null }

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) { span.to = startCh; }
          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) { span$1.to += offset; }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) { (first || (first = [])).push(span$1); }
          }
        } else {
          span$1.from += offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) { first = clearEmptySpans(first); }
    if (last && last != first) { last = clearEmptySpans(last); }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        { for (var i$2 = 0; i$2 < first.length; ++i$2)
          { if (first[i$2].to == null)
            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
      for (var i$3 = 0; i$3 < gap; ++i$3)
        { newMarkers.push(gapMarkers); }
      newMarkers.push(last);
    }
    return newMarkers
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        { spans.splice(i--, 1); }
    }
    if (!spans.length) { return null }
    return spans
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          { (markers || (markers = [])).push(mark); }
      } }
    });
    if (!markers) { return null }
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          { newParts.push({from: p.from, to: m.from}); }
        if (dto > 0 || !mk.inclusiveRight && !dto)
          { newParts.push({from: m.to, to: p.to}); }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.detachLine(line); }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.attachLine(line); }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) { return lenDiff }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) { return -fromCmp }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) { return toCmp }
    return b.id - a.id
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        { found = sp.marker; }
    } }
    return found
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
    } }
    return found
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
    var line = getLine(doc, lineNo$$1);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        { return true }
    } }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      { line = merged.find(-1, true).line; }
    return line
  }

  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return line
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line
      ;(lines || (lines = [])).push(line);
    }
    return lines
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) { return lineN }
    return lineNo(vis)
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) { return lineN }
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) { return lineN }
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return lineNo(line) + 1
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      if (sp.from == null) { return true }
      if (sp.marker.widgetNode) { continue }
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        { return true }
    } }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      { return true }
    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) { return true }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) { break }
      else { h += line.height; }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) { break }
        else { h += cur.height; }
      }
    }
    return h
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) { return 0 }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) { return f(from, to, "ltr", 0) }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) { f(from, to, "ltr"); }
  }

  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) { return i }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") { found = i; }
        else { bidiOther = i; }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") { found = i; }
        else { bidiOther = i; }
      }
    }
    return found != null ? found : bidiOther
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) { return lowTypes.charAt(code) }
      else if (0x590 <= code && code <= 0x5f4) { return "R" }
      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
      else if (0x2000 <= code && code <= 0x200b) { return "w" }
      else if (code == 0x200c) { return "b" }
      else { return "L" }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
      var len = str.length, types = [];
      for (var i = 0; i < len; ++i)
        { types.push(charType(str.charCodeAt(i))); }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") { types[i$1] = prev; }
        else { prev = type; }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
        else if (type$2 == "," && prev$1 == types[i$3+1] &&
                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") { types[i$4] = "N"; }
        else if (type$3 == "%") {
          var end = (void 0);
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i$4; j < end; ++j) { types[j] = replace; }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
        else if (isStrong.test(type$4)) { cur$1 = type$4; }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = (void 0);
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6-1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7, at = order.length;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              pos = j$2;
            } else { ++j$2; }
          }
          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order
    }
  })();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
    return order
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers || (emitter._handlers = {});
      map$$1[type] = (map$$1[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1)
          { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) { return }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) { return }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
      { set.push(arr[i]); } }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) { e.preventDefault(); }
    else { e.returnValue = false; }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) { e.stopPropagation(); }
    else { e.cancelBubble = true; }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

  function e_target(e) {return e.target || e.srcElement}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) { b = 1; }
      else if (e.button & 2) { b = 3; }
      else if (e.button & 4) { b = 2; }
    }
    if (mac && e.ctrlKey && b == 1) { b = 3; }
    return b
  }

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) { return false }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) { return badBidiRects }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
    return badBidiRects = (r1.right - r0.right < 3)
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) { nl = string.length; }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result
  } : function (string) { return string.split(/\r\n?|\n/); };

  var hasSelection = window.getSelection ? function (te) {
    try { return te.selectionStart != te.selectionEnd }
    catch(e) { return false }
  } : function (te) {
    var range$$1;
    try {range$$1 = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range$$1 || range$$1.parentElement() != te) { return false }
    return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
  };

  var hasCopyEvent = (function () {
    var e = elt("div");
    if ("oncopy" in e) { return true }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function"
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) { return badZoomedRects }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
  }

  // Known modes, by name and by MIME
  var modes = {}, mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2)
      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") { found = {name: found}; }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml")
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json")
    }
    if (typeof spec == "string") { return {name: spec} }
    else { return spec || {name: "null"} }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) { return getMode(options, "text/plain") }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) { continue }
        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) { modeObj.helperType = spec.helperType; }
    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
      { modeObj[prop$1] = spec.modeProps[prop$1]; } }

    return modeObj
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) { return state }
    if (mode.copyState) { return mode.copyState(state) }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) { val = val.concat([]); }
      nstate[n] = val;
    }
    return nstate
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) { break }
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state}
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length)
      { return this.string.charAt(this.pos++) }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") { ok = ch == match; }
    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
    if (ok) {++this.pos; return ch}
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)){}
    return this.pos > start
  };
  StringStream.prototype.eatSpace = function () {
      var this$1 = this;

    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }
    return this.pos > start
  };
  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {this.pos = found; return true}
  };
  StringStream.prototype.backUp = function (n) {this.pos -= n;};
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) -
      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) { this.pos += pattern.length; }
        return true
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) { return null }
      if (match && consume !== false) { this.pos += match[0].length; }
      return match
    }
  };
  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try { return inner() }
    finally { this.lineStart -= n; }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n)
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos)
  };

  var SavedContext = function(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
    return line
  };

  Context.prototype.baseToken = function (n) {
      var this$1 = this;

    if (!this.baseTokens) { return null }
    while (this.baseTokens[this.baseTokenPos] <= n)
      { this$1.baseTokenPos += 2; }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n}
  };

  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext)
      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
    else
      { return new Context(doc, copyState(doc.mode, saved), line) }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
  };


  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
            lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function ( o ) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            { st.splice(i, 1, end, st[i+1], i_end); }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) { return }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) { context.state = resetState; }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) { line.styleClasses = result.classes; }
      else if (line.styleClasses) { line.styleClasses = null; }
      if (updateFrontier === cm.doc.highlightFrontier)
        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
    }
    return line.styles
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) { return new Context(doc, true, n) }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) { doc.modeFrontier = context.line; }
    return context
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") { callBlankLine(mode, context.state); }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) { return mode.blankLine(state) }
    if (!mode.innerMode) { return }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) { inner[0] = innerMode(mode, state).mode; }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) { return style }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.")
  }

  var Token = function(stream, type, state) {
    this.start = stream.start; this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) { tokens = []; }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
    }
    return asArray ? tokens : new Token(stream, style, context.state)
  }

  function extractLineClasses(type, output) {
    if (type) { for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) { break }
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        { output[prop] = lineClass[2]; }
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        { output[prop] += " " + lineClass[2]; }
    } }
    return type
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) { return doc.first }
      var line = getLine(doc, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
        { return search }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) { return }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () { return lineNo(this) };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
    if (line.order != null) { line.order = null; }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) { return null }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"))
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   trailingSpace: false,
                   splitSpaces: cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
        if (line.styleClasses.textClass)
          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
        { builder.content.className = "cm-tab-wrap-hack"; }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

    return builder
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) { return }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) { mustWrap = true; }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
          else { content.appendChild(txt); }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) { break }
        pos += skipped + 1;
        var txt$1 = (void 0);
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
          else { content.appendChild(txt$1); }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) { fullStyle += startStyle; }
      if (endStyle) { fullStyle += endStyle; }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
          { token.setAttribute(attr, attributes[attr]); } }
      }
      return builder.content.appendChild(token)
    }
    builder.content.appendChild(content);
  }

  // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) { return text }
    var spaceBefore = trailingBefore, result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
        { ch = "\u00a0"; }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = (void 0);
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) { break }
        }
        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    }
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        { widget = builder.content.appendChild(document.createElement("span")); }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
      return
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles = (void 0);
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) { spanStyle += " " + m.className; }
            if (m.css) { css = (css ? css + ";" : "") + m.css; }
            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
            // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673
            if (m.title) { (attributes || (attributes = {})).title = m.title; }
            if (m.attributes) {
              for (var attr in m.attributes)
                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              { collapsed = sp; }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) { return }
          if (collapsed.to == pos) { collapsed = false; }
        }
      }
      if (pos >= len) { break }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }


  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        { callbacks[i].call(null); }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
      }
    } while (i < callbacks.length)
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) { return }

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) { return }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function ( i ) {
      list.push(function () { return arr[i].apply(null, args); });
    };

    for (var i = 0; i < arr.length; ++i)
      loop( i );
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") { updateLineText(cm, lineView); }
      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
      else if (type == "class") { updateLineClasses(cm, lineView); }
      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
    }
    return lineView.node
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) { cls += " CodeMirror-linebackground"; }
    if (lineView.background) {
      if (cls) { lineView.background.className = cls; }
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built
    }
    return buildLineContent(cm, lineView)
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) { lineView.node = built.pre; }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass)
      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
    else if (lineView.node != lineView.text)
      { lineView.node.className = ""; }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        { gutterWrap.className += " " + lineView.line.gutterClass; }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        { lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
      if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {
        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
      } }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) { lineView.alignable = null; }
    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
      next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        { lineView.node.removeChild(node); }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) { lineView.bgClass = built.bgClass; }
    if (built.textClass) { lineView.textClass = built.textClass; }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) { return }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
      else
        { wrap.appendChild(node); }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
  (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) { return widget.height }
    var cm = widget.doc.cm;
    if (!cm) { return 0 }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
      if (widget.noHScroll)
        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        { return true }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
  function paddingH(display) {
    if (display.cachedPaddingH) { return display.cachedPaddingH }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
    return data
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
    for (var i = 0; i < lineView.rest.length; i++)
      { if (lineView.rest[i] == line)
        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
      { if (lineNo(lineView.rest[i$1]) > lineN)
        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      { return cm.display.view[findViewIndex(cm, lineN)] }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      { return ext }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      { view = updateExternalMeasurement(cm, line); }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    }
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) { ch = -1; }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) { prepared.cache[key] = found; }
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom}
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map$$1, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map$$1.length; i += 3) {
      mStart = map$$1[i];
      mEnd = map$$1[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) { collapse = "right"; }
      }
      if (start != null) {
        node = map$$1[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          { collapse = bias; }
        if (bias == "left" && start == 0)
          { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
            node = map$$1[(i -= 3) + 2];
            collapse = "left";
          } }
        if (bias == "right" && start == mEnd - mStart)
          { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
            node = map$$1[(i += 3) + 2];
            collapse = "right";
          } }
        break
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
      if ((rect = rects[i]).left != rect.right) { break }
    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
      if ((rect = rects[i$1]).left != rect.right) { break }
    } }
    return rect
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
          { rect = node.parentNode.getBoundingClientRect(); }
        else
          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
        if (rect.left || rect.right || start == 0) { break }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) { collapse = bias = "right"; }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
      else
        { rect = node.getBoundingClientRect(); }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
      else
        { rect = nullRect; }
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++)
      { if (mid < heights[i]) { break } }
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) { result.bogus = true; }
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      { return rect }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
        { lineView.measure.caches[i] = {}; } }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      { clearLineMeasurementCacheFor(cm.display.view[i]); }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
  }
  function pageScrollY() {
    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
    return window.pageYOffset || (document.documentElement || document.body).scrollTop
  }

  function widgetTopHeight(lineObj) {
    var height = 0;
    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
      { height += widgetHeight(lineObj.widgets[i]); } } }
    return height
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height; rect.bottom += height;
    }
    if (context == "line") { return rect }
    if (!context) { context = "local"; }
    var yOff = heightAtLine(lineObj);
    if (context == "local") { yOff += paddingTop(cm.display); }
    else { yOff -= cm.display.viewOffset; }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") { return coords }
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) { m.left = m.right; } else { m.right = m.left; }
      return intoCoordSystem(cm, lineObj, m, context)
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos], right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert)
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
    return val
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height}
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) { pos.outside = true; }
    return pos
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }
    if (x < 0) { x = 0; }

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 ? 1 : 0));
      if (!collapsed) { return found }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) { return rangeEnd }
      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
    return {begin: begin, end: end}
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
  }

  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight$$1 = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;

    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                   (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null, boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;
      if (!boxIsAfter(box, x, y, false)) { return false }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true
    }, begin, end);

    var baseX, sticky, outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) { ch++; }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?
        "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top || y >= coords.bottom;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
  }

  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i], ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                     "line", lineObj, preparedMeasure), x, y, true)
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"),
                               "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y)
        { part = order[index - 1]; }
    }
    return part
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
    var part = null, closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) { continue }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) { part = order[order.length - 1]; }
    // Clip the part to the wrapped line.
    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
    return part
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) { display.cachedTextHeight = height; }
    removeChildren(display.measure);
    return height || 1
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) { display.cachedCharWidth = width; }
    return width || 10
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth}
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) { return 0 }

      var widgetsHeight = 0;
      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
      } }

      if (wrapping)
        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
      else
        { return widgetsHeight + th }
    }
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) { return null }
    n -= cm.display.viewFrom;
    if (n < 0) { return null }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) { return i }
    }
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if ( primary === void 0 ) primary = true;

    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) { continue }
      var range$$1 = doc.sel.ranges[i];
      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
      var collapsed = range$$1.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        { drawSelectionCursor(cm, range$$1.head, curFragment); }
      if (!collapsed)
        { drawSelectionRange(cm, range$$1, selFragment); }
    }
    return result
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range$$1, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) { top = 0; }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop]
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");

        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i == 0, last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) { // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else { // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
        if (cmpCoords(toPos, start) < 0) { start = toPos; }
        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
        if (cmpCoords(toPos, end) < 0) { end = toPos; }
      });
      return {start: start, end: end}
    }

    var sFrom = range$$1.from(), sTo = range$$1.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) { return }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
        cm.options.cursorBlinkRate); }
    else if (cm.options.cursorBlinkRate < 0)
      { display.cursorDiv.style.visibility = "hidden"; }
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () { if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
      onBlur(cm);
    } }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

    if (cm.options.readOnly == "nocursor") { return }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) { return }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], wrapping = cm.options.lineWrapping;
      var height = (void 0), width = 0;
      if (cur.hidden) { continue }
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        // Check that lines don't extend past the right of the current
        // editor width
        if (!wrapping && cur.text.firstChild)
          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
      }
      var diff = cur.line.height - height;
      if (diff > .005 || diff < -.005) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
          { updateWidgetHeight(cur.rest[j]); } }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
      var w = line.widgets[i], parent = w.node.parentNode;
      if (parent) { w.height = parent.offsetHeight; }
    } }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)}
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
      if (cm.options.fixedGutter) {
        if (view[i].gutter)
          { view[i].gutter.style.left = left; }
        if (view[i].gutterBackground)
          { view[i].gutterBackground.style.left = left; }
      }
      var align = view[i].alignable;
      if (align) { for (var j = 0; j < align.length; j++)
        { align[j].style.left = left; } }
    } }
    if (cm.options.fixedGutter)
      { display.gutters.style.left = (comp + gutterW) + "px"; }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) { return false }
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true
    }
    return false
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (rect.top + box.top < 0) { doScroll = true; }
    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) { margin = 0; }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
      }
      if (!changed) { break }
    }
    return rect
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) { rect.top = 0; }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) { result.scrollTop = newTop; }
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) { rect.right = rect.left + screenw; }
    if (rect.left < 10)
      { result.scrollLeft = 0; }
    else if (rect.left < screenleft)
      { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
    else if (rect.right > screenw + screenleft - 3)
      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
    return result
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) { return }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) { resolveScrollToPos(cm); }
    if (x != null) { cm.curOp.scrollLeft = x; }
    if (y != null) { cm.curOp.scrollTop = y; }
  }

  function scrollToRange(cm, range$$1) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range$$1;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range$$1 = cm.curOp.scrollToPos;
    if (range$$1) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
      scrollToCoordsRange(cm, from, to, range$$1.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
    setScrollTop(cm, val, true);
    if (gecko) { updateDisplaySimple(cm); }
    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    }
  }

  var NativeScrollbars = function(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert); place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height =
        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width =
        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) { this.zeroWidthHack(); }
      this.checkedZeroWidth = true;
    }

    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed;
    this.disableVert = new Delayed;
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
      else { delay.set(1000, maybeDisable); }
    }
    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function () {};

  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) { measure = measureForScrollbars(cm); }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        { updateHeightsInViewport(cm); }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else { d.scrollbarFiller.style.display = ""; }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else { d.gutterFiller.style.display = ""; }
  }

  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") { setScrollLeft(cm, pos); }
      else { updateScrollTop(cm, pos); }
    }, cm);
    if (cm.display.scrollbars.addClass)
      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: 0,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId           // Unique ID
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) { finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++)
        { group.ops[i].cm.curOp = null; }
      endOperations(group);
    }); }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      { endOperation_R1(ops[i]); }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
      { endOperation_W1(ops[i$1]); }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
      { endOperation_R2(ops[i$2]); }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
      { endOperation_W2(ops[i$3]); }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
      { endOperation_finish(ops[i$4]); }
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) { findMaxLine(cm); }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) { updateHeightsInViewport(cm); }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      { op.preparedSelection = display.input.prepareSelection(); }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt();
    if (op.preparedSelection)
      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      { updateScrollbars(cm, op.barMeasure); }
    if (op.updatedDisplay)
      { setDocumentHeight(cm, op.barMeasure); }

    if (op.selectionChanged) { restartBlink(cm); }

    if (cm.state.focused && op.updateInput)
      { cm.display.input.reset(op.typing); }
    if (takeFocus) { ensureFocus(op.cm); }
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      { display.wheelStartX = display.wheelStartY = null; }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) { for (var i = 0; i < hidden.length; ++i)
      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

    if (display.wrapper.offsetHeight)
      { doc.scrollTop = cm.display.scroller.scrollTop; }

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      { signal(cm, "changes", cm, op.changeObjs); }
    if (op.update)
      { op.update.finish(); }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) { return f() }
    startOperation(cm);
    try { return f() }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) { return f.apply(cm, arguments) }
      startOperation(cm);
      try { return f.apply(cm, arguments) }
      finally { endOperation(cm); }
    }
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) { return f.apply(this, arguments) }
      startOperation(this);
      try { return f.apply(this, arguments) }
      finally { endOperation(this); }
    }
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) { return f.apply(this, arguments) }
      startOperation(cm);
      try { return f.apply(this, arguments) }
      finally { endOperation(cm); }
    }
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) { from = cm.doc.first; }
    if (to == null) { to = cm.doc.first + cm.doc.size; }
    if (!lendiff) { lendiff = 0; }

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      { display.updateLineNumbers = from; }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        { resetView(cm); }
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        { ext.lineN += lendiff; }
      else if (from < ext.lineN + ext.size)
        { display.externalMeasured = null; }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      { display.externalMeasured = null; }

    if (line < display.viewFrom || line >= display.viewTo) { return }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) { return }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) { arr.push(type); }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      { return {index: index, lineN: newN} }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++)
      { n += view[i].size; }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) { return null }
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN}
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
      else if (display.viewFrom < from)
        { display.view = display.view.slice(findViewIndex(cm, from)); }
      display.viewFrom = from;
      if (display.viewTo < to)
        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
      else if (display.viewTo > to)
        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
    }
    return dirty
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo)
      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) { return }
    var end = +new Date + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];

    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) { context.state = resetState; }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) { line.styleClasses = newCls; }
        else if (oldCls) { line.styleClasses = null; }
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
        if (ischange) { changedLines.push(context.line); }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          { processLine(cm, line.text, context); }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) { runInOp(cm, function () {
      for (var i = 0; i < changedLines.length; i++)
        { regLineChange(cm, changedLines[i], "text"); }
    }); }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type))
      { this.events.push(arguments); }
  };
  DisplayUpdate.prototype.finish = function () {
      var this$1 = this;

    for (var i = 0; i < this.events.length; i++)
      { signal.apply(null, this$1.events[i]); }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) { return null }
    var active = activeElt();
    if (!active || !contains(cm.display.lineDiv, active)) { return null }
    var result = {activeElt: active};
    if (window.getSelection) {
      var sel = window.getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
    snapshot.activeElt.focus();
    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(), range$$1 = document.createRange();
      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range$$1.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range$$1);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      { return false }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      { return false }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          { break }
      }
      if (!updateDisplayIfNeeded(cm, update)) { break }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        { node.style.display = "none"; }
      else
        { node.parentNode.removeChild(node); }
      return next
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) { cur = rm(cur); }
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) { cur = rm(cur); }
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    var i = 0;
    for (; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) { wheelPixelsPerUnit = -.53; }
  else if (gecko) { wheelPixelsPerUnit = 15; }
  else if (chrome) { wheelPixelsPerUnit = -.7; }
  else if (safari) { wheelPixelsPerUnit = -1/3; }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
    else if (dy == null) { dy = e.wheelDelta; }
    return {x: dx, y: dy}
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) { return }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY)
        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        { e_preventDefault(e); }
      display.wheelStartX = null; // Abort measurement, if in progress
      return
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) { return }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) { return }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

  Selection.prototype.equals = function (other) {
      var this$1 = this;

    if (other == this) { return true }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this$1.ranges[i], there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
    }
    return true
  };

  Selection.prototype.deepCopy = function () {
      var this$1 = this;

    var out = [];
    for (var i = 0; i < this.ranges.length; i++)
      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }
    return new Selection(out, this.primIndex)
  };

  Selection.prototype.somethingSelected = function () {
      var this$1 = this;

    for (var i = 0; i < this.ranges.length; i++)
      { if (!this$1.ranges[i].empty()) { return true } }
    return false
  };

  Selection.prototype.contains = function (pos, end) {
      var this$1 = this;

    if (!end) { end = pos; }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this$1.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
        { return i }
    }
    return -1
  };

  var Range = function(anchor, head) {
    this.anchor = anchor; this.head = head;
  };

  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) { --primIndex; }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex)
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0)
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) { return change.to }
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) { return pos }
    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
    return Pos(line, ch)
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
    else
      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex)
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) { line.stateAfter = null; }
      if (line.styles) { line.styles = null; }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) { regChange(cm); }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight$$1);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i)
        { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
      return result
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) { doc.remove(from.line, nlines); }
      if (added.length) { doc.insert(from.line, added); }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) { continue }
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) { continue }
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      } }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) { throw new Error("This document is already in use.") }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    if (!cm.options.lineWrapping) { findMaxLine(cm); }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
    return histChange
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) { array.pop(); }
      else { break }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done)
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done)
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done)
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;
    var last;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        { pushSelectionToHistory(doc.sel, hist.done); }
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) { hist.done.shift(); }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) { signal(doc, "historyAdded"); }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      { hist.done[hist.done.length - 1] = sel; }
    else
      { pushSelectionToHistory(sel, hist.done); }

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      { clearSelectionEvents(hist.undone); }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      { dest.push(sel); }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) { return null }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
      else if (out) { out.push(spans[i]); }
    }
    return !out ? spans : out.length ? out : null
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) { return null }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i)
      { nw.push(removeClearedSpans(found[i])); }
    return nw
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) { return stretched }
    if (!stretched) { return old }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            { if (oldCur[k].marker == span.marker) { continue spans } }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = (void 0);
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        } } }
      }
    }
    return copy
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head)
    } else {
      return new Range(other || head, head)
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++)
      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        var this$1 = this;

        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head)); }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
    else { return sel }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      { sel = filterSelectionChange(doc, sel, options); }

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      { ensureCursorVisible(doc.cm); }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) { return }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) { out = sel.ranges.slice(0, i); }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;
      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) { break }
            else {--i; continue}
          }
        }
        if (!m.atomic) { continue }

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
      }
    } }
    return pos
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0)
    }
    return found
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
      else { return null }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
      else { return null }
    } else {
      return new Pos(pos.line, pos.ch + dir)
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () { return obj.canceled = true; }
    };
    if (update) { obj.update = function (from, to, text, origin) {
      if (from) { obj.from = clipPos(doc, from); }
      if (to) { obj.to = clipPos(doc, to); }
      if (text) { obj.text = text; }
      if (origin !== undefined) { obj.origin = origin; }
    }; }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

    if (obj.canceled) {
      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
      return null
    }
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
      if (doc.cm.state.suppressEdits) { return }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) { return }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) { return }

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        { break }
    }
    if (i == source.length) { return }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return
      } else { break }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function ( i ) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {}
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop( i$1 );

      if ( returned ) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) { return }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
      Pos(range.anchor.line + distance, range.anchor.ch),
      Pos(range.head.line + distance, range.head.ch)
    ); }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        { regLineChange(doc.cm, l, "gutter"); }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return
    }
    if (change.from.line > doc.lastLine()) { return }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
    else { updateDoc(doc, change, spans); }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      { signalCursorActivity(cm); }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      { regChange(cm); }
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      { regLineChange(cm, from.line, "text"); }
    else
      { regChange(cm, from.line, to.line + 1, lendiff); }

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) { signalLater(cm, "change", cm, obj); }
      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) { to = from; }
    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
    if (typeof code == "string") { code = doc.splitLines(code); }
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
    else { no = lineNo(handle); }
    if (no == null) { return null }
    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
    return line
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    var this$1 = this;

    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this$1;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length },

    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      var this$1 = this;

      for (var i = at, e = at + n; i < e; ++i) {
        var line = this$1.lines[i];
        this$1.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },

    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },

    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      var this$1 = this;

      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }
    },

    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      var this$1 = this;

      for (var e = at + n; at < e; ++at)
        { if (op(this$1.lines[at])) { return true } }
    }
  };

  function BranchChunk(children) {
    var this$1 = this;

    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this$1;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size },

    removeInner: function(at, n) {
      var this$1 = this;

      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this$1.height -= oldHeight - child.height;
          if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },

    collapse: function(lines) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }
    },

    insertInner: function(at, lines, height) {
      var this$1 = this;

      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this$1.children.splice(++i, 0, leaf);
              leaf.parent = this$1;
            }
            child.lines = child.lines.slice(0, remaining);
            this$1.maybeSpill();
          }
          break
        }
        at -= sz;
      }
    },

    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) { return }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
       } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10)
      me.parent.maybeSpill();
    },

    iterN: function(at, n, op) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) { return true }
          if ((n -= used) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function(doc, node, options) {
    var this$1 = this;

    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
      { this$1[opt] = options[opt]; } } }
    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
      var this$1 = this;

    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) { return }
    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }
    if (!ws.length) { line.widgets = null; }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
      var this$1 = this;

    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) { return }
    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      { addToScrollTop(cm, diff); }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) { widgets.push(widget); }
      else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) { addToScrollTop(cm, widget.height); }
        cm.curOp.forceUpdate = true;
      }
      return true
    });
    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
    return widget
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  var TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
      var this$1 = this;

    if (this.explicitlyCleared) { return }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) { startOperation(cm); }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) { signalLater(this, "clear", found.from, found.to); }
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text"); }
      else if (cm) {
        if (span.to != null) { max = lineNo(line); }
        if (span.from != null) { min = lineNo(line); }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
        { updateLineHeight(line, textHeight(cm.display)); }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
      var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    } }

    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) { reCheckSelection(cm.doc); }
    }
    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
    if (withOp) { endOperation(cm); }
    if (this.parent) { this.parent.clear(); }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
      var this$1 = this;

    if (side == null && this.type == "bookmark") { side = 1; }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) { return from }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) { return to }
      }
    }
    return from && {from: from, to: to}
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
      var this$1 = this;

    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) { return }
    runInOp(cm, function () {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          { updateLineHeight(line, line.height + dHeight); }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
    }
    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp
      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) { copyObj(options, marker, false); }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      { return marker }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
      seeCollapsedSpans();
    }

    if (marker.addToHistory)
      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        { updateMaxLine = true; }
      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
    }); }

    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length)
        { doc.clearHistory(); }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
      if (marker.collapsed)
        { regChange(cm, from.line, to.line + 1); }
      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
               marker.attributes || marker.title)
        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
      if (marker.atomic) { reCheckSelection(cm.doc); }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function(markers, primary) {
    var this$1 = this;

    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      { markers[i].parent = this$1; }
  };

  SharedTextMarker.prototype.clear = function () {
      var this$1 = this;

    if (this.explicitlyCleared) { return }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      { this$1.markers[i].clear(); }
    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj)
  };
  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) { options.widgetNode = widget.cloneNode(true); }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        { if (doc.linked[i].isParent) { return } }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary)
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function ( i ) {
      var marker = markers[i], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) loop( i );
  }

  var nextDocId = 0;
  var Doc = function(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
    if (firstLine == null) { firstLine = 0; }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = (direction == "rtl") ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") { text = this.splitLines(text); }
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) { this.iterN(from - this.first, to - from, op); }
      else { this.iterN(this.first, this.first + this.size, from); }
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
    getLineNumber: function(line) {return lineNo(line)},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") { line = getLine(this, line); }
      return visualLine(line)
    },

    lineCount: function() {return this.size},
    firstLine: function() {return this.first},
    lastLine: function() {return this.first + this.size - 1},

    clipPos: function(pos) {return clipPos(this, pos)},

    getCursor: function(start) {
      var range$$1 = this.sel.primary(), pos;
      if (start == null || start == "head") { pos = range$$1.head; }
      else if (start == "anchor") { pos = range$$1.anchor; }
      else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
      else { pos = range$$1.from(); }
      return pos
    },
    listSelections: function() { return this.sel.ranges },
    somethingSelected: function() {return this.sel.somethingSelected()},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      var this$1 = this;

      if (!ranges.length) { return }
      var out = [];
      for (var i = 0; i < ranges.length; i++)
        { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
                           clipPos(this$1, ranges[i].head)); }
      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var this$1 = this;

      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) { return lines }
      else { return lines.join(lineSep || this.lineSeparator()) }
    },
    getSelections: function(lineSep) {
      var this$1 = this;

      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }
        parts[i] = sel;
      }
      return parts
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        { dup[i] = code; }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var this$1 = this;

      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range$$1 = sel.ranges[i];
        changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
        { makeChange(this$1, changes[i$1]); }
      if (newSel) { setSelectionReplaceHistory(this, newSel); }
      else if (this.cm) { ensureCursorVisible(this.cm); }
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
      return {undo: done, redo: undone}
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
      return this.history.generation
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration)
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)}
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
        return true
      })
    }),

    clearGutter: docMethodOp(function(gutterID) {
      var this$1 = this;

      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
            return true
          });
        }
      });
    }),

    lineInfo: function(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) { return null }
        n = line;
        line = getLine(this, line);
        if (!line) { return null }
      } else {
        n = lineNo(line);
        if (n == null) { return null }
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets}
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) { line[prop] = cls; }
        else if (classTest(cls).test(line[prop])) { return false }
        else { line[prop] += " " + cls; }
        return true
      })
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) { return false }
        else if (cls == null) { line[prop] = null; }
        else {
          var found = cur.match(classTest(cls));
          if (!found) { return false }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true
      })
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options)
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark")
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) { for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          { markers.push(span.marker.parent || span.marker); }
      } }
      return markers
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo$$1 = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) { for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
                span.from == null && lineNo$$1 != from.line ||
                span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            { found.push(span.marker.parent || span.marker); }
        } }
        ++lineNo$$1;
      });
      return found
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) { for (var i = 0; i < sps.length; ++i)
          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
      });
      return markers
    },

    posFromIndex: function(off) {
      var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true }
        off -= sz;
        ++lineNo$$1;
      });
      return clipPos(this, Pos(lineNo$$1, ch))
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) { return 0 }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc
    },

    linkedDoc: function(options) {
      if (!options) { options = {}; }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) { from = options.from; }
      if (options.to != null && options.to < to) { to = options.to; }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) { copy.history = this.history
      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy
    },
    unlinkDoc: function(other) {
      var this$1 = this;

      if (other instanceof CodeMirror) { other = other.doc; }
      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
        var link = this$1.linked[i];
        if (link.doc != other) { continue }
        this$1.linked.splice(i, 1);
        other.unlinkDoc(this$1);
        detachSharedMarkers(findSharedMarkers(this$1));
        break
      } }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode},
    getEditor: function() {return this.cm},

    splitLines: function(str) {
      if (this.lineSep) { return str.split(this.lineSep) }
      return splitLinesAuto(str)
    },
    lineSeparator: function() { return this.lineSep || "\n" },

    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") { dir = "ltr"; }
      if (dir == this.direction) { return }
      this.direction = dir;
      this.iter(function (line) { return line.order = null; });
      if (this.cm) { directionChanged(this.cm); }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      { return }
    e_preventDefault(e);
    if (ie) { lastDrop = +new Date; }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) { return }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function (file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1)
          { return }

        var reader = new FileReader;
        reader.onload = operation(cm, function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
          text[i] = content;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () { return cm.display.input.focus(); }, 20);
        return
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy)
            { selected = cm.listSelections(); }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) { img.parentNode.removeChild(img); }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) { return }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) { return }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) { editors.push(cm); }
    }
    if (editors.length) { editors[0].operation(function () {
      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
    }); }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) { return }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100); }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete", 145: "ScrollLock",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
      else { throw new Error("Unrecognized modifier name: " + mod) }
    }
    if (alt) { name = "Alt-" + name; }
    if (ctrl) { name = "Ctrl-" + name; }
    if (cmd) { name = "Cmd-" + name; }
    if (shift) { name = "Shift-" + name; }
    return name
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
      if (value == "...") { delete keymap[keyname]; continue }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val = (void 0), name = (void 0);
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) { copy[name] = val; }
        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
      }
      delete keymap[keyname];
    } }
    for (var prop in copy) { keymap[prop] = copy[prop]; }
    return keymap
  }

  function lookupKey(key, map$$1, handle, context) {
    map$$1 = getKeyMap(map$$1);
    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
    if (found === false) { return "nothing" }
    if (found === "...") { return "multi" }
    if (found != null && handle(found)) { return "handled" }

    if (map$$1.fallthrough) {
      if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
        { return lookupKey(key, map$$1.fallthrough, handle, context) }
      for (var i = 0; i < map$$1.fallthrough.length; i++) {
        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
        if (result) { return result }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
  }

  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
    return name
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) { return false }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) { return false }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) { name = event.code; }
    return addModifierNames(name, event, noShift)
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = (dir < 0) == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
        } else { ch = dir < 0 ? part.to : part.from; }
        return new Pos(lineNo, ch, sticky)
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) { return moveLogically(line, start, dir) }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir)
    }

    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch)
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = (part.level == 1) == (dir < 0);
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky)
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
        ? new Pos(start.line, mv(ch, 1), "before")
        : new Pos(start.line, ch, "after"); };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = (dir > 0) == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) { return res }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) { return res }
    }

    // Case 4: Nowhere to move
    return null
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
      if (range.empty()) {
        var len = getLine(cm.doc, range.head.line).text.length;
        if (range.head.ch == len && range.head.line < cm.lastLine())
          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
        else
          { return {from: range.head, to: Pos(range.head.line, len)} }
      } else {
        return {from: range.from(), to: range.to()}
      }
    }); },
    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0),
      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
    }); }); },
    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0), to: range.from()
    }); }); },
    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
      return {from: leftPos, to: range.from()}
    }); },
    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      return {from: range.from(), to: rightPos }
    }); },
    undo: function (cm) { return cm.undo(); },
    redo: function (cm) { return cm.redo(); },
    undoSelection: function (cm) { return cm.undoSelection(); },
    redoSelection: function (cm) { return cm.redoSelection(); },
    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
      {origin: "+move", bias: 1}
    ); },
    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
      {origin: "+move", bias: 1}
    ); },
    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
      {origin: "+move", bias: -1}
    ); },
    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
    }, sel_move); },
    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: 0, top: top}, "div")
    }, sel_move); },
    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      var pos = cm.coordsChar({left: 0, top: top}, "div");
      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
      return pos
    }, sel_move); },
    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
    goLineDown: function (cm) { return cm.moveV(1, "line"); },
    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
    goPageDown: function (cm) { return cm.moveV(1, "page"); },
    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
    goCharRight: function (cm) { return cm.moveH(1, "char"); },
    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
    goWordRight: function (cm) { return cm.moveH(1, "word"); },
    delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
    indentAuto: function (cm) { return cm.indentSelection("smart"); },
    indentMore: function (cm) { return cm.indentSelection("add"); },
    indentLess: function (cm) { return cm.indentSelection("subtract"); },
    insertTab: function (cm) { return cm.replaceSelection("\t"); },
    insertSoftTab: function (cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) { cm.indentSelection("add"); }
      else { cm.execCommand("insertTab"); }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) { return runInOp(cm, function () {
      var ranges = cm.listSelections(), newSel = [];
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty()) { continue }
        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
        if (line) {
          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
          if (cur.ch > 0) {
            cur = new Pos(cur.line, cur.ch + 1);
            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
          } else if (cur.line > cm.doc.first) {
            var prev = getLine(cm.doc, cur.line - 1).text;
            if (prev) {
              cur = new Pos(cur.line, 1);
              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                              prev.charAt(prev.length - 1),
                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
            }
          }
        }
        newSel.push(new Range(cur, cur));
      }
      cm.setSelections(newSel);
    }); },
    newlineAndIndent: function (cm) { return runInOp(cm, function () {
      var sels = cm.listSelections();
      for (var i = sels.length - 1; i >= 0; i--)
        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
      sels = cm.listSelections();
      for (var i$1 = 0; i$1 < sels.length; i$1++)
        { cm.indentLine(sels[i$1].from().line, null, true); }
      ensureCursorVisible(cm);
    }); },
    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
  };


  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, visual, lineN, 1)
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, line, lineN, -1)
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
    }
    return start
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) { return false }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      if (dropShift) { cm.display.shift = false; }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) { return result }
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm)
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed;

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) { return "handled" }
      if (/\'$/.test(name))
        { cm.state.keySeq = null; }
      else
        { stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        }); }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
    }
    return dispatchKeyInner(cm, name, e, handle)
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      { cm.state.keySeq = name; }
    if (result == "handled")
      { signalLater(cm, "keyHandled", cm, name, e); }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) { return false }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
          || dispatchKey(cm, name, e, function (b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 { return doHandleBinding(cm, b) }
             })
    } else {
      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) { return }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        { cm.replaceSelection("", null, "cut"); }
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      { showCrossHair(cm); }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) { this.doc.sel.shift = false; }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") { return }
    if (handleCharBinding(cm, e, ch)) { return }
    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time &&
      cmp(pos, this.pos) == 0 && button == this.button
  };

  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date;
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple"
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double"
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single"
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () { return display.scroller.draggable = true; }, 100);
      }
      return
    }
    if (clickInGutter(cm, e)) { return }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText)
      { cm.state.selectingText(e); }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

    if (button == 1) {
      if (pos) { leftButtonDown(cm, pos, repeat, e); }
      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
    } else if (button == 2) {
      if (pos) { extendSelection(cm.doc, pos); }
      setTimeout(function () { return display.input.focus(); }, 20);
    } else if (button == 3) {
      if (captureRightClick) { cm.display.input.onContextMenu(e); }
      else { delayBlurEvent(cm); }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") { name = "Double" + name; }
    else if (repeat == "triple") { name = "Triple" + name; }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") { bound = commands[bound]; }
      if (!bound) { return false }
      var done = false;
      try {
        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done
    })
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
    return value
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
    else { cm.curOp.focus = activeElt(); }

    var behavior = configureMouse(cm, repeat, event);

    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
      { leftButtonStartDrag(cm, event, pos, behavior); }
    else
      { leftButtonSelect(cm, event, pos, behavior); }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) { display.scroller.draggable = false; }
      cm.state.draggingText = false;
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew)
          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9)
          { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }
        else
          { display.input.focus(); }
      }
    });
    var mouseMove = function(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () { return moved = true; };
    // Let the drag handler handle this.
    if (webkit) { display.scroller.draggable = true; }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    // IE's approach to draggable
    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);

    delayBlurEvent(cm);
    setTimeout(function () { return display.input.focus(); }, 20);
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") { return new Range(pos, pos) }
    if (unit == "word") { return cm.findWordAt(pos) }
    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
    var result = unit(cm, pos);
    return new Range(result.from, result.to)
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(event);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        { ourRange = ranges[ourIndex]; }
      else
        { ourRange = new Range(start, start); }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) { ourRange = new Range(start, start); }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range$$1 = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend)
        { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }
      else
        { ourRange = range$$1; }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) { return }
      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
          else if (text.length > leftPos)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
        }
        if (!ranges.length) { ranges.push(new Range(start, start)); }
        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range$$1 = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range$$1.anchor, anchor) > 0) {
          head = range$$1.head;
          anchor = minPos(oldRange.from(), range$$1.anchor);
        } else {
          head = range$$1.anchor;
          anchor = maxPos(oldRange.to(), range$$1.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) { return }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) { setTimeout(operation(cm, function () {
          if (counter != curCount) { return }
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50); }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      e_preventDefault(e);
      display.input.focus();
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) { done(e); }
      else { extend(e); }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range$$1) {
    var anchor = range$$1.anchor;
    var head = range$$1.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }
    var order = getOrder(anchorLine);
    if (!order) { return range$$1 }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }
    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) { return range$$1 }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary)
        { leftSide = dir < 0; }
      else
        { leftSide = dir > 0; }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
  }


  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try { mX = e.clientX; mY = e.clientY; }
      catch(e) { return false }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
    if (prevent) { e_preventDefault(e); }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signal(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e)
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true)
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
    if (signalDOMEvent(cm, e, "contextmenu")) { return }
    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) { return false }
    return gutterEvent(cm, e, "gutterContextMenu", false)
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = {toString: function(){return "CodeMirror.Init"}};

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) { optionHandlers[name] =
        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);

    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) { return }
      var newBreaks = [], lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) { break }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) { cm.refresh(); }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      guttersChanged(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) { prev.detach(cm, next); }
      if (next.attach) { next.attach(cm, prev || null); }
    });
    option("extraKeys", null);
    option("configureMouse", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm) {
      setGuttersForLineNumbers(cm.options);
      guttersChanged(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm) {
      setGuttersForLineNumbers(cm.options);
      guttersChanged(cm);
    }, true);
    option("firstLineNumber", 1, guttersChanged, true);
    option("lineNumberFormatter", function (integer) { return integer; }, guttersChanged, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });
    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) { cm.display.input.resetPosition(); }
    });

    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
    option("phrases", null);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    alignHorizontally(cm);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () { return updateScrollbars(cm); }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);

    var doc = options.value;
    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
    else if (options.mode) { doc.modeOption = options.mode; }
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping)
      { this.display.wrapper.className += " CodeMirror-wrap"; }
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) { display.input.focus(); }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || this.hasFocus())
      { setTimeout(bind(onFocus, this), 20); }
    else
      { onBlur(this); }

    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
      { optionHandlers[opt](this$1, options[opt], Init); } }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) { options.finishInit(this); }
    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      { display.lineDiv.style.textRendering = "auto"; }
  }

  // The default configuration options.
  CodeMirror.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      { on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) { return }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      })); }
    else
      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) { return false }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1
    }
    function farAway(touch, other) {
      if (other.left == null) { return true }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) { d.activeTouch.moved = true; }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          { range = new Range(pos, pos); }
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          { range = cm.findWordAt(pos); }
        else // Triple tap
          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function (e) { return onDragStart(cm, e); },
      drop: operation(cm, onDrop),
      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) { return onFocus(cm, e); });
    on(inp, "blur", function (e) { return onBlur(cm, e); });
  }

  var initHooks = [];
  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) { how = "add"; }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) { how = "prev"; }
      else { state = getContextBefore(cm, n).state; }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) { line.stateAfter = null; }
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) { return }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
      else { indentation = 0; }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
    if (pos < indentation) { indentString += spaceStr(indentation - pos); }

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) { sel = doc.sel; }

    var recent = +new Date - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++)
            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) { return [l]; });
      }
    }

    var updateInput = cm.curOp.updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range$$1 = sel.ranges[i$1];
      var from = range$$1.from(), to = range$$1.to();
      if (range$$1.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          { from = Pos(from.line, from.ch - deleted); }
        else if (cm.state.overwrite && !paste) // Handle overwrite
          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
          { from = to = Pos(from.line, 0); }
      }
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      { triggerElectric(cm, inserted); }

    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput)
        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
      return true
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range$$1 = sel.ranges[i];
      if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
      var mode = cm.getModeAt(range$$1.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range$$1.head.line, "smart");
            break
          } }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
          { indented = indentLine(cm, range$$1.head.line, "smart"); }
      }
      if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges}
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", !!autocorrect);
    field.setAttribute("autocapitalize", !!autocapitalize);
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) { te.style.width = "1000px"; }
    else { te.setAttribute("wrap", "off"); }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) { te.style.border = "1px solid black"; }
    disableBrowserMagic(te);
    return div
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function(){window.focus(); this.display.input.focus();},

      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") { return }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option))
          { operation(this, optionHandlers[option])(this, value, old); }
        signal(this, "optionChange", this, option);
      },

      getOption: function(option) {return this.options[option]},
      getDoc: function() {return this.doc},

      addKeyMap: function(map$$1, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
      },
      removeKeyMap: function(map$$1) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i)
          { if (maps[i] == map$$1 || maps[i].name == map$$1) {
            maps.splice(i, 1);
            return true
          } }
      },

      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
        insertSorted(this.state.overlays,
                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                      priority: (options && options.priority) || 0},
                     function (overlay) { return overlay.priority; });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var this$1 = this;

        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this$1.state.modeGen++;
            regChange(this$1);
            return
          }
        }
      }),

      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
          else { dir = dir ? "add" : "subtract"; }
        }
        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
      }),
      indentSelection: methodOp(function(how) {
        var this$1 = this;

        var ranges = this.doc.sel.ranges, end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range$$1 = ranges[i];
          if (!range$$1.empty()) {
            var from = range$$1.from(), to = range$$1.to();
            var start = Math.max(end, from.line);
            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j)
              { indentLine(this$1, j, how); }
            var newRanges = this$1.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
              { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
          } else if (range$$1.head.line > end) {
            indentLine(this$1, range$$1.head.line, how, true);
            end = range$$1.head.line;
            if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        return takeToken(this, pos, precise)
      },

      getLineTokens: function(line, precise) {
        return takeToken(this, Pos(line), precise, true)
      },

      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type;
        if (ch == 0) { type = styles[2]; }
        else { for (;;) {
          var mid = (before + after) >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
          else { type = styles[mid * 2 + 2]; break }
        } }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
      },

      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) { return mode }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
      },

      getHelper: function(pos, type) {
        return this.getHelpers(pos, type)[0]
      },

      getHelpers: function(pos, type) {
        var this$1 = this;

        var found = [];
        if (!helpers.hasOwnProperty(type)) { return found }
        var help = helpers[type], mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) { found.push(help[mode[type]]); }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) { found.push(val); }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
            { found.push(cur.val); }
        }
        return found
      },

      getStateAfter: function(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
        return getContextBefore(this, line + 1, precise).state
      },

      cursorCoords: function(start, mode) {
        var pos, range$$1 = this.doc.sel.primary();
        if (start == null) { pos = range$$1.head; }
        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
        else { pos = start ? range$$1.from() : range$$1.to(); }
        return cursorCoords(this, pos, mode || "page")
      },

      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page")
      },

      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top)
      },

      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset)
      },
      heightAtLine: function(line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) { line = this.doc.first; }
          else if (line > last) { line = last; end = true; }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
          (end ? this.doc.height - heightAtLine(lineObj) : 0)
      },

      defaultTextHeight: function() { return textHeight(this.display) },
      defaultCharWidth: function() { return charWidth(this.display) },

      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
            { top = pos.top - node.offsetHeight; }
          else if (pos.bottom + node.offsetHeight <= vspace)
            { top = pos.bottom; }
          if (left + node.offsetWidth > hspace)
            { left = hspace - node.offsetWidth; }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") { left = 0; }
          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
          node.style.left = left + "px";
        }
        if (scroll)
          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),

      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd))
          { return commands[cmd].call(null, this) }
      },

      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

      findPosH: function(from, amount, unit, visually) {
        var this$1 = this;

        var dir = 1;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this$1.doc, cur, dir, unit, visually);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveH: methodOp(function(dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range$$1) {
          if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
            { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
          else
            { return dir < 0 ? range$$1.from() : range$$1.to() }
        }, sel_move);
      }),

      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc = this.doc;
        if (sel.somethingSelected())
          { doc.replaceSelection("", null, "+delete"); }
        else
          { deleteNearSelection(this, function (range$$1) {
            var other = findPosH(doc, range$$1.head, dir, unit, false);
            return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
          }); }
      }),

      findPosV: function(from, amount, unit, goalColumn) {
        var this$1 = this;

        var dir = 1, x = goalColumn;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this$1, cur, "div");
          if (x == null) { x = coords.left; }
          else { coords.left = x; }
          cur = findPosV(this$1, coords, dir, unit);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveV: methodOp(function(dir, unit) {
        var this$1 = this;

        var doc = this.doc, goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range$$1) {
          if (collapse)
            { return dir < 0 ? range$$1.from() : range$$1.to() }
          var headPos = cursorCoords(this$1, range$$1.head, "div");
          if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range$$1 == doc.sel.primary())
            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
          return pos
        }, sel_move);
        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
          { doc.sel.ranges[i].goalColumn = goals[i]; } }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function(pos) {
        var doc = this.doc, line = getLine(doc, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper)
            ? function (ch) { return isWordChar(ch, helper); }
            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
          while (start > 0 && check(line.charAt(start - 1))) { --start; }
          while (end < line.length && check(line.charAt(end))) { ++end; }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end))
      },

      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) { return }
        if (this.state.overwrite = !this.state.overwrite)
          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
        else
          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() { return this.display.input.getField() == activeElt() },
      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
      getScrollInfo: function() {
        var scroller = this.display.scroller;
        return {left: scroller.scrollLeft, top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
      },

      scrollIntoView: methodOp(function(range$$1, margin) {
        if (range$$1 == null) {
          range$$1 = {from: this.doc.sel.primary().head, to: null};
          if (margin == null) { margin = this.options.cursorScrollMargin; }
        } else if (typeof range$$1 == "number") {
          range$$1 = {from: Pos(range$$1, 0), to: null};
        } else if (range$$1.from == null) {
          range$$1 = {from: range$$1, to: null};
        }
        if (!range$$1.to) { range$$1.to = range$$1.from; }
        range$$1.margin = margin || 0;

        if (range$$1.from.line != null) {
          scrollToRange(this, range$$1);
        } else {
          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
        }
      }),

      setSize: methodOp(function(width, height) {
        var this$1 = this;

        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
        if (width != null) { this.display.wrapper.style.width = interpret(width); }
        if (height != null) { this.display.wrapper.style.height = interpret(height); }
        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
        var lineNo$$1 = this.display.viewFrom;
        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
          ++lineNo$$1;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function(f){return runInOp(this, f)},
      startOperation: function(){return startOperation(this)},
      endOperation: function(){return endOperation(this)},

      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
          { estimateLineHeights(this); }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function(doc) {
        var old = this.doc;
        old.cm = null;
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old
      }),

      phrase: function(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
      },

      getInputField: function(){return this.display.input.getField()},
      getWrapperElement: function(){return this.display.wrapper},
      getScrollerElement: function(){return this.display.scroller},
      getGutterElement: function(){return this.display.gutters}
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function(type, name, value) {
      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({pred: predicate, val: value});
    };
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    function findNextLine() {
      var l = pos.line + dir;
      if (l < doc.first || l >= doc.first + doc.size) { return false }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l)
    }
    function moveOnce(boundToLine) {
      var next;
      if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine())
          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
        else
          { return false }
      } else {
        pos = next;
      }
      return true
    }

    if (unit == "char") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) { break }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) { type = "s"; }
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
          break
        }

        if (type) { sawType = type; }
        if (dir > 0 && !moveOnce(!first)) { break }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
    return result
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) { break }
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
      y += dir * 5;
    }
    return target
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

    on(div, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
    });

    on(div, "compositionstart", function (e) {
      this$1.composing = {data: e.data, done: false};
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
        this$1.composing.done = true;
      }
    });

    on(div, "touchstart", function () { return input.forceCompositionEnd(); });

    on(div, "input", function () {
      if (!this$1.composing) { this$1.readFromDOMSoon(); }
    });

    function onCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = document.activeElement;
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) { input.showPrimarySelection(); }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = this.cm.state.focused;
    return result
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) { return }
    if (info.focus || takeFocus) { this.showPrimarySelection(); }
    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection()
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
        cmp(minPos(curAnchor, curFocus), from) == 0 &&
        cmp(maxPos(curAnchor, curFocus), to) == 0)
      { return }

    var view = cm.display.view;
    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
        {node: view[0].measure.map[2], offset: 0};
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return
    }

    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try { rng = range(start.node, start.offset, end.offset, end.node); }
    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) { sel.addRange(old); }
      else if (gecko) { this.startGracePeriod(); }
    }
    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
      var this$1 = this;

    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged())
        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();
    if (!sel.rangeCount) { return false }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node)
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor())
        { this.showSelection(this.prepareSelection(), true); }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
  ContentEditableInput.prototype.getField = function () { return this.div };

  ContentEditableInput.prototype.supportsTouch = function () { return true };

  ContentEditableInput.prototype.receivedFocus = function () {
    var input = this;
    if (this.selectionInEditor())
      { this.pollSelection(); }
    else
      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
    var sel = this.getSelection(), cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
      this.blur();
      this.focus();
      return
    }
    if (this.composing) { return }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) { runInOp(cm, function () {
      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
    }); }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine())
      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
      { to = Pos(to.line + 1, 0); }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) { return false }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
      else { break }
    }

    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
      { ++cutFront; }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
      { ++cutEnd; }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) { return }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
      var this$1 = this;

    if (this.readDOMTimeout != null) { return }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) { this$1.composing = null; }
        else { return }
      }
      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
      var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent())
      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) { return }
    e.preventDefault();
    if (!this.cm.isReadOnly())
      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) { return null }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode)
      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
    return false
  }

  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) { text += lineSep; }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return
        }
        var markerID = node.getAttribute("cm-marker"), range$$1;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range$$1 = found[0].find(0)))
            { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
          return
        }
        if (node.getAttribute("contenteditable") == "false") { return }
        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

        if (isBlock) { close(); }
        for (var i = 0; i < node.childNodes.length; i++)
          { walk(node.childNodes[i]); }

        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
        if (isBlock) { closing = true; }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }
    for (;;) {
      walk(from);
      if (from == to) { break }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        { return locateNodeInLineView(lineView, node, offset) }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad)
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) { offset = textNode.nodeValue.length; }
    }
    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map$$1 = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map$$1.length; j += 3) {
          var curNode = map$$1[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map$$1[j] + offset;
            if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
            return Pos(line, ch)
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) { return badPos(found, bad) }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        { return badPos(Pos(found.line, found.ch - dist), bad) }
      else
        { dist += after.textContent.length; }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
      else
        { dist$1 += before.textContent.length; }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  TextareaInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;

    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) { te.style.width = "0px"; }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
      input.poll();
    });

    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

      cm.state.pasteIncoming = +new Date;
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);

    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date;
        input.focus();
        return
      }

      // Pass the `paste` event to the textarea so it's handled by its event listener.
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) { e_preventDefault(e); }
    });

    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) { input.composing.range.clear(); }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    this.textarea = this.wrapper.firstChild;
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm, display = cm.display, doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                          headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                           headPos.left + lineOff.left - wrapOff.left));
    }

    return result
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) { return }
    var cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) { selectInput(this.textarea); }
      if (ie && ie_version >= 9) { this.hasSelection = content; }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) { this.hasSelection = null; }
    }
  };

  TextareaInput.prototype.getField = function () { return this.textarea };

  TextareaInput.prototype.supportsTouch = function () { return false };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try { this.textarea.focus(); }
      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () { this.textarea.blur(); };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
      var this$1 = this;

    if (this.pollingFast) { return }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) { this$1.slowPoll(); }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
      else {input.pollingFast = false; input.slowPoll();}
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
      var this$1 = this;

    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || !cm.state.focused ||
        (hasSelection(input) && !prevInput && !this.composing) ||
        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
      { return false }

    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) { return false }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text ||
        mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
    }
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same,
                     null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
      else { this$1.prevInput = text; }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                           {className: "CodeMirror-composing"});
      }
    });
    return true
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) { this.hasSelection = null; }
    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) { input.contextMenuPending(); }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) { return } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) { window.scrollTo(null, oldScrollY); }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1; te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) { return }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
        var i = 0, poll = function () {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
              te.selectionEnd > 0 && input.prevInput == "\u200b") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) { this.reset(); }
    this.textarea.disabled = val == "nocursor";
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      { options.tabindex = textarea.tabIndex; }
    if (!options.placeholder && textarea.placeholder)
      { options.placeholder = textarea.placeholder; }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () { return textarea; };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function")
            { textarea.form.submit = realSubmit; }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
      options);
    return cm
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror);

  addEditorMethods(CodeMirror);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    { CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments)}
    })(Doc.prototype[prop]); } }

  eventMixin(Doc);
  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name/*, mode, …*/) {
    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
  CodeMirror.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror);

  CodeMirror.version = "5.45.0";

  return CodeMirror;

})));
;

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

;(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    // CommonJS
    mod(require("../../lib/codemirror"))
  else if (typeof define == "function" && define.amd)
    // AMD
    define(["../../lib/codemirror"], mod)
  // Plain browser env
  else mod(CodeMirror)
})(function(CodeMirror) {
  "use strict"

  var HINT_ELEMENT_CLASS = "CodeMirror-hint"
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active"

  // This is the old interface, kept around for now to stay
  // backwards-compatible.
  CodeMirror.showHint = function(cm, getHints, options) {
    if (!getHints) return cm.showHint(options)
    if (options && options.async) getHints.async = true
    var newOpts = { hint: getHints }
    if (options) for (var prop in options) newOpts[prop] = options[prop]
    return cm.showHint(newOpts)
  }

  CodeMirror.defineExtension("showHint", function(options) {
    options = parseOptions(this, this.getCursor("start"), options)
    var selections = this.listSelections()
    if (selections.length > 1) return
    // By default, don't allow completion when something is selected.
    // A hint function can have a `supportsSelection` property to
    // indicate that it can handle selections.
    if (this.somethingSelected()) {
      if (!options.hint.supportsSelection) return
      // Don't try with cross-line selections
      for (var i = 0; i < selections.length; i++) if (selections[i].head.line != selections[i].anchor.line) return
    }

    if (this.state.completionActive) this.state.completionActive.close()
    var completion = (this.state.completionActive = new Completion(this, options))
    if (!completion.options.hint) return

    CodeMirror.signal(this, "startCompletion", this)
    completion.update(true)
  })

  CodeMirror.defineExtension("closeHint", function() {
    if (this.state.completionActive) this.state.completionActive.close()
  })

  function Completion(cm, options) {
    this.cm = cm
    this.options = options
    this.widget = null
    this.debounce = 0
    this.tick = 0
    this.startPos = this.cm.getCursor("start")
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length

    var self = this
    cm.on(
      "cursorActivity",
      (this.activityFunc = function() {
        self.cursorActivity()
      })
    )
  }

  var requestAnimationFrame =
    window.requestAnimationFrame ||
    function(fn) {
      return setTimeout(fn, 1000 / 60)
    }
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout

  Completion.prototype = {
    close: function() {
      if (!this.active()) return
      this.cm.state.completionActive = null
      this.tick = null
      this.cm.off("cursorActivity", this.activityFunc)

      if (this.widget && this.data) CodeMirror.signal(this.data, "close")
      if (this.widget) this.widget.close()
      CodeMirror.signal(this.cm, "endCompletion", this.cm)
    },

    active: function() {
      return this.cm.state.completionActive == this
    },

    pick: function(data, i) {
      var completion = data.list[i]
      if (completion.hint) completion.hint(this.cm, data, completion)
      else this.cm.replaceRange(getText(completion), completion.from || data.from, completion.to || data.to, "complete")
      CodeMirror.signal(data, "pick", completion)
      this.close()
    },

    cursorActivity: function() {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce)
        this.debounce = 0
      }

      var pos = this.cm.getCursor(),
        line = this.cm.getLine(pos.line)
      if (
        pos.line != this.startPos.line ||
        line.length - pos.ch != this.startLen - this.startPos.ch ||
        pos.ch < this.startPos.ch ||
        this.cm.somethingSelected() ||
        (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))
      ) {
        this.close()
      } else {
        var self = this
        this.debounce = requestAnimationFrame(function() {
          self.update()
        })
        if (this.widget) this.widget.disable()
      }
    },

    update: function(first) {
      if (this.tick == null) return
      var self = this,
        myTick = ++this.tick
      fetchHints(this.options.hint, this.cm, this.options, function(data) {
        if (self.tick == myTick) self.finishUpdate(data, first)
      })
    },

    finishUpdate: function(data, first) {
      if (this.data) CodeMirror.signal(this.data, "update")

      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle)
      if (this.widget) this.widget.close()

      this.data = data

      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0)
        } else {
          this.widget = new Widget(this, data)
          CodeMirror.signal(data, "shown")
        }
      }
    }
  }

  function parseOptions(cm, pos, options) {
    var editor = cm.options.hintOptions
    var out = {}
    for (var prop in defaultOptions) out[prop] = defaultOptions[prop]
    if (editor) for (var prop in editor) if (editor[prop] !== undefined) out[prop] = editor[prop]
    if (options) for (var prop in options) if (options[prop] !== undefined) out[prop] = options[prop]
    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)
    return out
  }

  function getText(completion) {
    if (typeof completion == "string") return completion
    else return completion.text
  }

  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function() {
        handle.moveFocus(-1)
      },
      Down: function() {
        handle.moveFocus(1)
      },
      PageUp: function() {
        handle.moveFocus(-handle.menuSize() + 1, true)
      },
      PageDown: function() {
        handle.moveFocus(handle.menuSize() - 1, true)
      },
      Home: function() {
        handle.setFocus(0)
      },
      End: function() {
        handle.setFocus(handle.length - 1)
      },
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    }

    var mac = /Mac/.test(navigator.platform)

    if (mac) {
      baseMap["Ctrl-P"] = function() {
        handle.moveFocus(-1)
      }
      baseMap["Ctrl-N"] = function() {
        handle.moveFocus(1)
      }
    }

    var custom = completion.options.customKeys
    var ourMap = custom ? {} : baseMap
    function addBinding(key, val) {
      var bound
      if (typeof val != "string")
        bound = function(cm) {
          return val(cm, handle)
        }
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val)) bound = baseMap[val]
      else bound = val
      ourMap[key] = bound
    }
    if (custom) for (var key in custom) if (custom.hasOwnProperty(key)) addBinding(key, custom[key])
    var extra = completion.options.extraKeys
    if (extra) for (var key in extra) if (extra.hasOwnProperty(key)) addBinding(key, extra[key])
    return ourMap
  }

  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el
      el = el.parentNode
    }
  }

  function Widget(completion, data) {
    this.completion = completion
    this.data = data
    this.picked = false
    var widget = this,
      cm = completion.cm
    var ownerDocument = cm.getInputField().ownerDocument
    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow

    var hints = (this.hints = ownerDocument.createElement("ul"))
    var theme = completion.cm.options.theme
    hints.className = "CodeMirror-hints " + theme
    this.selectedHint = data.selectedHint || 0

    var completions = data.list
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(ownerDocument.createElement("li")),
        cur = completions[i]
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS)
      if (cur.className != null) className = cur.className + " " + className
      elt.className = className
      if (cur.render) cur.render(elt, data, cur)
      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)))
      elt.hintId = i
    }

    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null)
    var left = pos.left,
      top = pos.bottom,
      below = true
    hints.style.left = left + "px"
    hints.style.top = top + "px"
    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW =
      parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth)
    var winH =
      parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight)
    ;(completion.options.container || ownerDocument.body).appendChild(hints)
    var box = hints.getBoundingClientRect(),
      overlapY = box.bottom - winH
    var scrolls = hints.scrollHeight > hints.clientHeight + 1
    var startScroll = cm.getScrollInfo()

    if (overlapY > 0) {
      var height = box.bottom - box.top,
        curTop = pos.top - (pos.bottom - box.top)
      if (curTop - height > 0) {
        // Fits above cursor
        hints.style.top = (top = pos.top - height) + "px"
        below = false
      } else if (height > winH) {
        hints.style.height = winH - 5 + "px"
        hints.style.top = (top = pos.bottom - box.top) + "px"
        var cursor = cm.getCursor()
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor)
          hints.style.left = (left = pos.left) + "px"
          box = hints.getBoundingClientRect()
        }
      }
    }
    var overlapX = box.right - winW
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = winW - 5 + "px"
        overlapX -= box.right - box.left - winW
      }
      hints.style.left = (left = pos.left - overlapX) + "px"
    }
    if (scrolls)
      for (var node = hints.firstChild; node; node = node.nextSibling)
        node.style.paddingRight = cm.display.nativeBarWidth + "px"

    cm.addKeyMap(
      (this.keyMap = buildKeyMap(completion, {
        moveFocus: function(n, avoidWrap) {
          widget.changeActive(widget.selectedHint + n, avoidWrap)
        },
        setFocus: function(n) {
          widget.changeActive(n)
        },
        menuSize: function() {
          return widget.screenAmount()
        },
        length: completions.length,
        close: function() {
          completion.close()
        },
        pick: function() {
          widget.pick()
        },
        data: data
      }))
    )

    if (completion.options.closeOnUnfocus) {
      var closingOnBlur
      cm.on(
        "blur",
        (this.onBlur = function() {
          closingOnBlur = setTimeout(function() {
            completion.close()
          }, 100)
        })
      )
      cm.on(
        "focus",
        (this.onFocus = function() {
          clearTimeout(closingOnBlur)
        })
      )
    }

    cm.on(
      "scroll",
      (this.onScroll = function() {
        var curScroll = cm.getScrollInfo(),
          editor = cm.getWrapperElement().getBoundingClientRect()
        var newTop = top + startScroll.top - curScroll.top
        var point =
          newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop)
        if (!below) point += hints.offsetHeight
        if (point <= editor.top || point >= editor.bottom) return completion.close()
        hints.style.top = newTop + "px"
        hints.style.left = left + startScroll.left - curScroll.left + "px"
      })
    )

    CodeMirror.on(hints, "dblclick", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement)
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId)
        widget.pick()
      }
    })

    CodeMirror.on(hints, "click", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement)
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId)
        if (completion.options.completeOnSingleClick) widget.pick()
      }
    })

    CodeMirror.on(hints, "mousedown", function() {
      setTimeout(function() {
        cm.focus()
      }, 20)
    })

    CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint])
    return true
  }

  Widget.prototype = {
    close: function() {
      if (this.completion.widget != this) return
      this.completion.widget = null
      this.hints.parentNode.removeChild(this.hints)
      this.completion.cm.removeKeyMap(this.keyMap)

      var cm = this.completion.cm
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur)
        cm.off("focus", this.onFocus)
      }
      cm.off("scroll", this.onScroll)
    },

    disable: function() {
      this.completion.cm.removeKeyMap(this.keyMap)
      var widget = this
      this.keyMap = {
        Enter: function() {
          widget.picked = true
        }
      }
      this.completion.cm.addKeyMap(this.keyMap)
    },

    pick: function() {
      this.completion.pick(this.data, this.selectedHint)
    },

    changeActive: function(i, avoidWrap) {
      if (i >= this.data.list.length) i = avoidWrap ? this.data.list.length - 1 : 0
      else if (i < 0) i = avoidWrap ? 0 : this.data.list.length - 1
      if (this.selectedHint == i) return
      var node = this.hints.childNodes[this.selectedHint]
      if (node) node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "")
      node = this.hints.childNodes[(this.selectedHint = i)]
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS
      if (node.offsetTop < this.hints.scrollTop) this.hints.scrollTop = node.offsetTop - 3
      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node)
    },

    screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1
    }
  }

  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected()) return helpers
    var result = []
    for (var i = 0; i < helpers.length; i++) if (helpers[i].supportsSelection) result.push(helpers[i])
    return result
  }

  function fetchHints(hint, cm, options, callback) {
    if (hint.async) {
      hint(cm, callback, options)
    } else {
      var result = hint(cm, options)
      if (result && result.then) result.then(callback)
      else callback(result)
    }
  }

  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"),
      words
    if (helpers.length) {
      var resolved = function(cm, callback, options) {
        var app = applicableHelpers(cm, helpers)
        function run(i) {
          if (i == app.length) return callback(null)
          fetchHints(app[i], cm, options, function(result) {
            if (result && result.list.length > 0) callback(result)
            else run(i + 1)
          })
        }
        run(0)
      }
      resolved.async = true
      resolved.supportsSelection = true
      return resolved
    } else if ((words = cm.getHelper(cm.getCursor(), "hintWords"))) {
      return function(cm) {
        return CodeMirror.hint.fromList(cm, { words: words })
      }
    } else if (CodeMirror.hint.anyword) {
      return function(cm, options) {
        return CodeMirror.hint.anyword(cm, options)
      }
    } else {
      return function() {}
    }
  }

  CodeMirror.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  })

  CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
    var cur = cm.getCursor(),
      token = cm.getTokenAt(cur)
    var term,
      from = CodeMirror.Pos(cur.line, token.start),
      to = cur
    if (token.start < cur.ch && /\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
      term = token.string.substr(0, cur.ch - token.start)
    } else {
      term = ""
      from = cur
    }
    var found = []
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i]
      if (word.slice(0, term.length) == term) found.push(word)
    }

    if (found.length) return { list: found, from: from, to: to }
  })

  CodeMirror.commands.autocomplete = CodeMirror.showHint

  var defaultOptions = {
    hint: CodeMirror.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnUnfocus: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null
  }

  CodeMirror.defineOption("hintOptions", null)
})
;

{


class abstractTrueBaseColumnParser extends GrammarBackedNode {
      get columnNameCell() {
      return this.getWord(0)
    }
get isColumn() { return true }
get typeForCsvDocs() { return `unspecified` }
get columnValue() {
 return this.content
}
get columnName() {
 return this.definition.cruxPathAsColumnName
}
    }

class abstractUrlColumnParser extends abstractTrueBaseColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get urlCell() {
      return this.getWord(1)
    }
get typeForCsvDocs() { return `url` }
    }

class annualReportsUrlParser extends abstractUrlColumnParser {
      
    }

class abstractUrlGuidColumnParser extends abstractUrlColumnParser {
      
    }

class antlrParser extends abstractUrlGuidColumnParser {
      get sourceDomain() { return `www.antlr.org` }
    }

class hoplParser extends abstractUrlGuidColumnParser {
      get sourceDomain() { return `hopl.info` }
    }

class jupyterKernelParser extends abstractUrlGuidColumnParser {
      get sourceDomain() { return `jupyter.org` }
    }

class meetupParser extends abstractUrlGuidColumnParser {
      createParserCombinator() {class memberCountParser extends abstractPopulationCountColumnParser {
      
    }

class groupCountParser extends abstractCountColumnParser {
      
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"memberCount" : memberCountParser,
"groupCount" : groupCountParser}), undefined)
  }
get sourceDomain() { return `meetup.com` }
    }

class subredditParser extends abstractUrlGuidColumnParser {
      createParserCombinator() {class memberCountParser extends abstractAnnualPopulationCountMapParser {
      
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"memberCount" : memberCountParser}), undefined)
  }
get sourceDomain() { return `reddit.com` }
    }

class replitParser extends abstractUrlGuidColumnParser {
      get sourceDomain() { return `replit.com` }
    }

class rosettaCodeParser extends abstractUrlGuidColumnParser {
      get sourceDomain() { return `rosettacode.org` }
    }

class twitterParser extends abstractUrlGuidColumnParser {
      createParserCombinator() {class followersParser extends abstractPopulationCountColumnParser {
      
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"followers" : followersParser}), undefined)
  }
get sourceDomain() { return `twitter.com` }
    }

class abstractChatUrlColumnParser extends abstractUrlColumnParser {
      get sortKey() { return `abstractChatUrlColumnParser` }
    }

class discordParser extends abstractChatUrlColumnParser {
      
    }

class discourseParser extends abstractChatUrlColumnParser {
      
    }

class ircParser extends abstractChatUrlColumnParser {
      
    }

class zulipParser extends abstractChatUrlColumnParser {
      
    }

class cheatSheetUrlParser extends abstractUrlColumnParser {
      
    }

class conferenceParser extends abstractUrlColumnParser {
      get conferenceNameCell() {
      return this.getWordsFrom(0)
    }
    }

class demoVideoParser extends abstractUrlColumnParser {
      
    }

class documentationParser extends abstractUrlColumnParser {
      
    }

class devDocumentationParser extends abstractUrlColumnParser {
      
    }

class downloadPageUrlParser extends abstractUrlColumnParser {
      
    }

class ebookParser extends abstractUrlColumnParser {
      
    }

class emailListParser extends abstractUrlColumnParser {
      
    }

class esolangParser extends abstractUrlColumnParser {
      get sourceDomain() { return `esolangs.org` }
    }

class eventsPageUrlParser extends abstractUrlColumnParser {
      
    }

class faqPageUrlParser extends abstractUrlColumnParser {
      
    }

class abstractGitRepoUrlColumnParser extends abstractUrlColumnParser {
      get sortKey() { return `abstractGitRepoUrlColumnParser` }
    }

class gitRepoParser extends abstractGitRepoUrlColumnParser {
      
    }

class githubRepoParser extends abstractGitRepoUrlColumnParser {
      createParserCombinator() {class createdParser extends abstractYearColumnParser {
      
    }

class updatedParser extends abstractYearColumnParser {
      
    }

class firstCommitParser extends abstractYearColumnParser {
      
    }

class subscribersParser extends abstractCountColumnParser {
      
    }

class forksParser extends abstractCountColumnParser {
      
    }

class starsParser extends abstractCountColumnParser {
      
    }

class issuesParser extends abstractCountColumnParser {
      
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"description" : descriptionParser,
"created" : createdParser,
"updated" : updatedParser,
"firstCommit" : firstCommitParser,
"subscribers" : subscribersParser,
"forks" : forksParser,
"stars" : starsParser,
"issues" : issuesParser}), undefined)
  }
get columnNameCell() {
      return this.getWord(0)
    }
get githubRepoUrlCell() {
      return this.getWord(1)
    }
get sourceDomain() { return `github.com` }
    }

class gitlabRepoParser extends abstractGitRepoUrlColumnParser {
      get sourceDomain() { return `gitlab.com` }
    }

class sourcehutRepoParser extends abstractGitRepoUrlColumnParser {
      get sourceDomain() { return `sr.ht` }
    }

class gourceParser extends abstractUrlColumnParser {
      get sourceDomain() { return `gource.io` }
    }

class firstAnnouncementParser extends abstractUrlColumnParser {
      
    }

class screenshotParser extends abstractUrlColumnParser {
      
    }

class photoParser extends abstractUrlColumnParser {
      
    }

class languageServerProtocolProjectParser extends abstractUrlColumnParser {
      createParserCombinator() {
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"writtenIn" : writtenInParser}), undefined)
  }
get sourceDomain() { return `langserver.org` }
    }

class linguistGrammarRepoParser extends abstractUrlColumnParser {
      createParserCombinator() {class commitCountParser extends abstractCountColumnParser {
      
    }

class firstCommitParser extends abstractYearColumnParser {
      
    }

class lastCommitParser extends abstractYearColumnParser {
      
    }

class sampleCountParser extends abstractCountColumnParser {
      
    }

class committerCountParser extends abstractPopulationCountColumnParser {
      
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"example" : exampleParser,
"helloWorldCollection" : helloWorldCollectionParser,
"commitCount" : commitCountParser,
"firstCommit" : firstCommitParser,
"lastCommit" : lastCommitParser,
"sampleCount" : sampleCountParser,
"committerCount" : committerCountParser}), undefined)
  }
get columnNameCell() {
      return this.getWord(0)
    }
get urlCell() {
      return this.getWord(1)
    }
get sourceDomain() { return `github.com` }
    }

class officialBlogUrlParser extends abstractUrlColumnParser {
      
    }

class packageRepositoryParser extends abstractUrlColumnParser {
      
    }

class proposalsParser extends abstractUrlColumnParser {
      
    }

class redditDiscussionParser extends abstractUrlColumnParser {
      get sourceDomain() { return `reddit.com` }
    }

class referenceParser extends abstractUrlColumnParser {
      
    }

class releaseNotesUrlParser extends abstractUrlColumnParser {
      
    }

class rijuReplParser extends abstractUrlColumnParser {
      createParserCombinator() {
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"gitRepo" : gitRepoParser,
"website" : websiteParser,
"description" : descriptionParser,
"fileExtensions" : fileExtensionsParser,
"example" : exampleParser,
"helloWorldCollection" : helloWorldCollectionParser}), undefined)
  }
get sourceDomain() { return `riju.codes` }
    }

class roadmapParser extends abstractUrlColumnParser {
      
    }

class specParser extends abstractUrlColumnParser {
      
    }

class websiteParser extends abstractUrlColumnParser {
      
    }

class webReplParser extends abstractUrlColumnParser {
      
    }

class wikipediaParser extends abstractUrlColumnParser {
      createParserCombinator() {class relatedParser extends abstractTrueBaseLinksColumnParser {
      
    }

class summaryParser extends abstractStringColumnParser {
      
    }

class createdParser extends abstractYearColumnParser {
      
    }

class appearedParser extends abstractYearColumnParser {
      
    }

class dailyPageViewsParser extends abstractCountColumnParser {
      
    }

class backlinksCountParser extends abstractCountColumnParser {
      
    }

class revisionCountParser extends abstractCountColumnParser {
      
    }

class pageIdParser extends abstractIntColumnParser {
      
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"fileExtensions" : fileExtensionsParser,
"related" : relatedParser,
"appeared" : appearedParser,
"example" : exampleParser,
"helloWorldCollection" : helloWorldCollectionParser,
"summary" : summaryParser,
"created" : createdParser,
"dailyPageViews" : dailyPageViewsParser,
"backlinksCount" : backlinksCountParser,
"revisionCount" : revisionCountParser,
"pageId" : pageIdParser}), undefined)
  }
get columnNameCell() {
      return this.getWord(0)
    }
get urlCell() {
      return this.getWord(1)
    }
get sourceDomain() { return `wikipedia.org` }
    }

class abstractBooleanColumnParser extends abstractTrueBaseColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get boolCell() {
      return this.getWord(1)
    }
get typeForCsvDocs() { return `boolean` }
    }

class abstractFeatureParser extends abstractBooleanColumnParser {
      createParserCombinator() {
  return new TreeNode.ParserCombinator(featureExampleCodeParser, undefined, undefined)
  }
get sortKey() { return `abstractFeatureParser` }
    }

class canDoShebangParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Shebang_(Unix)` }
get pseudoExample() { return `#! /run` }
get title() { return `Shebang` }
    }

class canReadCommandLineArgsParser extends abstractFeatureParser {
      
    }

class canUseQuestionMarksAsPartOfIdentifierParser extends abstractFeatureParser {
      
    }

class canWriteToDiskParser extends abstractFeatureParser {
      get pseudoExample() { return `write("pldb.csv", "...")` }
get title() { return `Disk Output` }
    }

class hasAbstractTypesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Abstract_type` }
get pseudoExample() { return `abstract class PLDBFile {}` }
get title() { return `Abstract Types` }
    }

class hasAccessModifiersParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Access_modifiers` }
get pseudoExample() { return `class PLDBFile { public title }` }
get title() { return `Access Modifiers` }
    }

class hasAlgebraicTypesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Algebraic_data_type` }
get pseudoExample() { return `garageContents = empty | vehicle` }
get title() { return `Algebraic Data Type` }
    }

class hasAnonymousFunctionsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Anonymous_function` }
get pseudoExample() { return `() => printPldb()` }
get aka() { return `Lambdas` }
get title() { return `Anonymous Functions` }
    }

class hasArraySlicingSyntaxParser extends abstractFeatureParser {
      
    }

class hasAssertStatementsParser extends abstractFeatureParser {
      get pseudoExample() { return `assert(isTrue)` }
get reference() { return `https://en.wikipedia.org/wiki/Debug_code#Assert_Statements` }
get title() { return `Assert Statements` }
    }

class hasAssignmentParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Assignment_(computer_science)` }
get tokenKeyword() { return `assignmentToken` }
get pseudoExample() { return `name = "PLDB"` }
get title() { return `Assignment` }
    }

class hasAsyncAwaitParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Async/await` }
get pseudoExample() { return `async downloadPldb => await getFiles()` }
get title() { return `Async Await` }
    }

class hasBinaryNumbersParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Binary_number` }
get pseudoExample() { return `0b100110100000110011110010010` }
get title() { return `Binary Literals` }
    }

class hasBinaryOperatorsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Binary_operation` }
get pseudoExample() { return `1 + 1` }
get title() { return `Binary Operators` }
    }

class hasBitWiseOperatorsParser extends abstractFeatureParser {
      get pseudoExample() { return `3 == (2 | 1)` }
get reference() { return `https://en.wikipedia.org/wiki/Bitwise_operations_in_C https://en.wikipedia.org/wiki/Bitwise_operation` }
get title() { return `Bitwise Operators` }
    }

class hasBlobsParser extends abstractFeatureParser {
      
    }

class hasBooleansParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Boolean_data_type` }
get tokenKeyword() { return `booleanTokens` }
get pseudoExample() { return `pldb = true` }
get title() { return `Booleans` }
    }

class hasBoundedCheckedArraysParser extends abstractFeatureParser {
      
    }

class hasBreakParser extends abstractFeatureParser {
      
    }

class hasBuiltInRegexParser extends abstractFeatureParser {
      
    }

class hasCaseInsensitiveIdentifiersParser extends abstractFeatureParser {
      get pseudoExample() { return `pLdB = "PLDB"` }
get reference() { return `https://rosettacode.org/wiki/Case-sensitivity_of_identifiers` }
get title() { return `Case Insensitive Identifiers` }
    }

class hasCharactersParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Character_(computing)` }
get pseudoExample() { return `char character = 'P';` }
get title() { return `Characters` }
    }

class hasClassesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Class_(computer_programming)` }
get pseudoExample() { return `class PLDBFile {}` }
get title() { return `Classes` }
    }

class hasClobsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Character_large_object` }
get pseudoExample() { return `class PLDBFile {}` }
get aka() { return `Character large objects` }
get title() { return `Clobs` }
    }

class hasCommentsParser extends abstractFeatureParser {
      get pseudoExample() { return `# Hello PLDB` }
get reference() { return `https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(syntax)#Comments https://en.wikipedia.org/wiki/Comment_(computer_programming)` }
get title() { return `Comments` }
    }

class hasConditionalsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Conditional_(computer_programming)` }
get pseudoExample() { return `if (isTrue) printPldb()` }
get title() { return `Conditionals` }
    }

class hasConstantsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Const_(computer_programming)` }
get pseudoExample() { return `const name = "PLDB"` }
get title() { return `Constants` }
    }

class hasConstructorsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)` }
get pseudoExample() { return `PLDBFile { constructor() {} }` }
get title() { return `Constructors` }
    }

class hasContinueParser extends abstractFeatureParser {
      
    }

class hasDecimalsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Decimal_data_type` }
get pseudoExample() { return `0.80766866` }
get title() { return `Decimals` }
    }

class hasDefaultParametersParser extends abstractFeatureParser {
      get pseudoExample() { return `say(message = "Hello PLDB")` }
get reference() { return `https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters` }
get title() { return `Default Parameters Pattern` }
    }

class hasDependentTypesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Dependent_type` }
get pseudoExample() { return `pldbSortedList // a list where is sorted is true` }
get title() { return `Dependent types` }
    }

class hasDestructuringParser extends abstractFeatureParser {
      get pseudoExample() { return `{title, rank} = pldbFile` }
get reference() { return `https://reasonml.github.io/docs/en/destructuring` }
get website() { return `https://github.com/facebook/reason` }
get title() { return `Destructuring` }
    }

class hasDirectivesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Directive_(programming)` }
get pseudoExample() { return `use strict;` }
get title() { return `Directives` }
    }

class hasDisposeBlocksParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Dispose_pattern` }
get pseudoExample() { return `with pldb: do computeRanks()` }
get title() { return `Dispose Blocks Pattern` }
    }

class hasDocCommentsParser extends abstractFeatureParser {
      get pseudoExample() { return `// param1: A comment about the first param` }
get title() { return `Doc comments` }
    }

class hasDuckTypingParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Duck_typing` }
get pseudoExample() { return `length() // makes me an iterator` }
get title() { return `Duck Typing` }
    }

class hasDynamicPropertiesParser extends abstractFeatureParser {
      get pseudoExample() { return `pldb.score = 50` }
get title() { return `Dynamic Properties` }
    }

class hasDynamicSizedArraysParser extends abstractFeatureParser {
      
    }

class hasDynamicTypingParser extends abstractFeatureParser {
      
    }

class hasEnumsParser extends abstractFeatureParser {
      get pseudoExample() { return `colorsEnum { "red", "white", "blue"}` }
get reference() { return `https://en.wikipedia.org/wiki/Enumerated_type` }
get title() { return `Enums` }
    }

class hasEscapeCharactersParser extends abstractFeatureParser {
      
    }

class hasExceptionsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Exception_handling` }
get pseudoExample() { return `throw new Error("PLDB uh oh")` }
get title() { return `Exceptions` }
    }

class hasExplicitTypeCastingParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Type_conversion` }
get pseudoExample() { return `(float)pldbRank;` }
get title() { return `Type Casting` }
    }

class hasExportsParser extends abstractFeatureParser {
      
    }

class hasExpressionsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Expression_(computer_science)` }
get pseudoExample() { return `(1 + 2)` }
get title() { return `Expressions` }
    }

class hasFirstClassFunctionsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/First-class_function` }
get pseudoExample() { return `[2.1].map(Math.round)` }
get title() { return `First-Class Functions` }
    }

class hasFixedPointParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Fixed-point_arithmetic` }
get pseudoExample() { return `80766866.00` }
get title() { return `Fixed Point Numbers` }
    }

class hasFloatsParser extends abstractFeatureParser {
      get pseudoExample() { return `80766866.0` }
get reference() { return `https://evanw.github.io/float-toy/ https://en.wikipedia.org/wiki/Floating-point_arithmetic` }
get title() { return `Floats` }
    }

class hasFnArgumentsParser extends abstractFeatureParser {
      
    }

class hasForEachLoopsParser extends abstractFeatureParser {
      
    }

class hasForLoopsParser extends abstractFeatureParser {
      
    }

class hasFunctionCompositionParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Function_composition_(computer_science)` }
get pseudoExample() { return `o = (f, g) => x => f(g(x))` }
get title() { return `Function Composition` }
    }

class hasFunctionOverloadingParser extends abstractFeatureParser {
      get pseudoExample() { return `add(string: str, string2: str)` }
get aka() { return `Ad hoc polymorphism` }
get reference() { return `https://en.wikibooks.org/wiki/Introduction_to_Programming_Languages/Overloading https://en.wikipedia.org/wiki/Function_overloading` }
get title() { return `Function Overloading` }
    }

class hasFunctionsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Subroutine` }
get pseudoExample() { return `function computePLDBRanks() {}` }
get aka() { return `routines` }
get title() { return `Functions` }
    }

class hasGarbageCollectionParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)` }
get pseudoExample() { return `var iDontNeedToFreeThis` }
get title() { return `Garbage Collection` }
    }

class hasGeneratorsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Generator_(computer_programming)` }
get pseudoExample() { return `yield 2` }
get title() { return `Generators` }
    }

class hasGenericsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Generic_programming` }
get pseudoExample() { return `function identity<T>(arg: T): T` }
get title() { return `Generics` }
    }

class hasGlobalScopeParser extends abstractFeatureParser {
      
    }

class hasGotosParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Goto` }
get pseudoExample() { return `goto 10` }
get title() { return `Gotos` }
    }

class hasHereDocsParser extends abstractFeatureParser {
      get pseudoExample() { return `\`A big multliline text block\`` }
get reference() { return `https://en.wikipedia.org/wiki/Here_document` }
get title() { return `Here Document` }
    }

class hasHexadecimalsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Hexadecimal` }
get pseudoExample() { return `0x4D06792` }
get aka() { return `Base16` }
get title() { return `Hexadecimals` }
    }

class hasHomoiconicityParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Homoiconicity` }
get pseudoExample() { return `(list ())` }
get title() { return `Homoiconicity` }
    }

class hasIdsParser extends abstractFeatureParser {
      
    }

class hasIfElsesParser extends abstractFeatureParser {
      
    }

class hasIfsParser extends abstractFeatureParser {
      
    }

class hasImplicitArgumentsParser extends abstractFeatureParser {
      get pseudoExample() { return `shout(implicit message: string)` }
get reference() { return `https://docs.scala-lang.org/tour/implicit-parameters.html` }
get title() { return `Implicit Arguments` }
    }

class hasImplicitTypeConversionsParser extends abstractFeatureParser {
      get pseudoExample() { return `console.log("hello " + 2)` }
get reference() { return `https://en.wikipedia.org/wiki/Type_conversion` }
get title() { return `Implicit Type Casting` }
    }

class hasImportsParser extends abstractFeatureParser {
      get tokenKeyword() { return `includeToken` }
get pseudoExample() { return `import pldb` }
get title() { return `File Imports` }
    }

class hasIncrementAndDecrementOperatorsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Increment_and_decrement_operators` }
get pseudoExample() { return `i++` }
get title() { return `Increment and decrement operators` }
    }

class hasInfixNotationParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Infix_notation` }
get pseudoExample() { return `1 + 2` }
get title() { return `Infix Notation` }
    }

class hasInheritanceParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)` }
get pseudoExample() { return `class PLDBFile extends File` }
get title() { return `Inheritance` }
    }

class hasIntegersParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Integer_(computer_science)` }
get pseudoExample() { return `80766866` }
get title() { return `Integers` }
    }

class hasInterfacesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Protocol_(object-oriented_programming)` }
get pseudoExample() { return `interface PLDBFile` }
get title() { return `Interfaces` }
    }

class hasIteratorsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Iterator` }
get pseudoExample() { return `for lang in pldb()` }
get title() { return `Iterators` }
    }

class hasLabelsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Label_(computer_science)` }
get pseudoExample() { return `mainFn:` }
get title() { return `Labels` }
    }

class hasLazyEvaluationParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Lazy_evaluation` }
get pseudoExample() { return `print(range(1000000)[2])` }
get title() { return `Lazy Evaluation` }
    }

class hasLineCommentsParser extends abstractFeatureParser {
      get tokenKeyword() { return `lineCommentToken` }
get pseudoExample() { return `# Hello PLDB` }
get reference() { return `https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(syntax)#Comments` }
get title() { return `Line Comments` }
    }

class hasListsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/List_(abstract_data_type)` }
get pseudoExample() { return `[2, 3, 10]` }
get aka() { return `array` }
get title() { return `Lists` }
    }

class hasMacrosParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Macro_(computer_science)` }
get pseudoExample() { return `#define pldbItems 4000` }
get title() { return `Macros` }
    }

class hasMagicGettersAndSettersParser extends abstractFeatureParser {
      get pseudoExample() { return `get(name) => obj[name]` }
get reference() { return `https://www.php.net/manual/en/language.oop5.overloading.php#object.get` }
get title() { return `Magic Getters and Setters` }
    }

class hasManualMemoryManagementParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Manual_memory_management` }
get pseudoExample() { return `malloc(4);` }
get title() { return `Manual Memory Management` }
    }

class hasMapFunctionsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Map_(higher-order_function)` }
get pseudoExample() { return `pldbFiles.map(downloadFilesFn)` }
get title() { return `Map Functions` }
    }

class hasMapsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Associative_array` }
get pseudoExample() { return `{name: "PLDB"}` }
get aka() { return `dict` }
get title() { return `Maps` }
    }

class hasMemberVariablesParser extends abstractFeatureParser {
      get aka() { return `properties` }
    }

class hasMessagePassingParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Message_passing` }
get pseudoExample() { return `"get pldb"` }
get title() { return `Message Passing` }
    }

class hasMethodChainingParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Method_chaining` }
get pseudoExample() { return `pldbFile.toString().length` }
get title() { return `Method Chaining` }
    }

class hasMethodOverloadingParser extends abstractFeatureParser {
      
    }

class hasMethodsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Method_(computer_programming)` }
get pseudoExample() { return `pldbFile.downloadWebsite()` }
get title() { return `Methods` }
    }

class hasMixinsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Mixin` }
get pseudoExample() { return `extends pldbFile, diskFile` }
get title() { return `Mixins` }
    }

class hasModulesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Module_pattern` }
get pseudoExample() { return `module PLDB {}` }
get title() { return `Module Pattern` }
    }

class hasMonadsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Monad_(functional_programming)` }
get pseudoExample() { return `g >>= f` }
get title() { return `Monad` }
    }

class hasMultiLineCommentsParser extends abstractFeatureParser {
      get tokenKeyword() { return `multiLineCommentTokens` }
get pseudoExample() { return `/* Hello PLDB */` }
get reference() { return `https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(syntax)#Comments` }
get title() { return `MultiLine Comments` }
    }

class hasMultilineStringsParser extends abstractFeatureParser {
      get pseudoExample() { return `hello = """Hello\nPLDB"""` }
get title() { return `Multiline Strings` }
    }

class hasMultipleDispatchParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Multiple_dispatch` }
get pseudoExample() { return `collide_with(x::Spaceship, y::Spaceship)` }
get title() { return `Multiple Dispatch` }
    }

class hasMultipleInheritanceParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Multiple_inheritance` }
get pseudoExample() { return `extends parentWhichExtendsSomethingElse` }
get title() { return `Multiple Inheritance` }
    }

class hasNamespacesParser extends abstractFeatureParser {
      get pseudoExample() { return `namespace PLDB {}` }
get title() { return `Namespaces` }
    }

class hasNullParser extends abstractFeatureParser {
      get pseudoExample() { return `uhOh = null` }
get reference() { return `https://en.wikipedia.org/wiki/Null_pointer` }
get title() { return `Null` }
    }

class hasOctalsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Octal` }
get pseudoExample() { return `0o464063622` }
get aka() { return `Base8` }
get title() { return `Octals` }
    }

class hasOperatorOverloadingParser extends abstractFeatureParser {
      get pseudoExample() { return `def __add__(): doSomethingDifferent()` }
get reference() { return `https://en.wikibooks.org/wiki/Introduction_to_Programming_Languages/Overloading https://en.wikipedia.org/wiki/Operator_overloading` }
get title() { return `Operator Overloading` }
    }

class hasOperatorsParser extends abstractFeatureParser {
      get pseudoExample() { return `1 + 1` }
get reference() { return `https://en.wikipedia.org/wiki/Operator_(computer_programming)` }
get title() { return `Operators` }
    }

class hasPairsParser extends abstractFeatureParser {
      get pseudoExample() { return `(pl . db)` }
get title() { return `Pairs` }
    }

class hasPartialApplicationParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Partial_application` }
get pseudoExample() { return `add5 = num => addNumbers(10, num)` }
get title() { return `Partial Application` }
    }

class hasPatternMatchingParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Pattern_matching` }
get pseudoExample() { return `fib 0 = 1; fib 1 = 1` }
get title() { return `Pattern Matching` }
    }

class hasPipesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Pipeline_(software)` }
get pseudoExample() { return `ls pldb | wc` }
get title() { return `Pipes` }
    }

class hasPointersParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Pointer_(computer_programming)` }
get pseudoExample() { return `int *pldb` }
get title() { return `Pointers` }
    }

class hasPolymorphismParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Polymorphism_(computer_science)` }
get pseudoExample() { return `a + "b"; 1 + 2` }
get title() { return `Polymorphism` }
    }

class hasPostfixNotationParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Reverse_Polish_notation` }
get pseudoExample() { return `2 3 4 + 2 -` }
get title() { return `Postfix Notation` }
    }

class hasPrefixNotationParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Polish_notation` }
get pseudoExample() { return `+ 1 2` }
get title() { return `Prefix Notation` }
    }

class hasPrintDebuggingParser extends abstractFeatureParser {
      get tokenKeyword() { return `printToken` }
get pseudoExample() { return `print "Hello PLDB"` }
get reference() { return `https://en.wikipedia.org/wiki/Debug_code#Print_debugging` }
get title() { return `Print() Debugging` }
    }

class hasProcessorRegistersParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Processor_register` }
get pseudoExample() { return `eax 2` }
get title() { return `Processor Registers` }
    }

class hasRangeOperatorsParser extends abstractFeatureParser {
      get pseudoExample() { return `1 ... 10` }
get reference() { return `https://docstore.mik.ua/orelly/perl4/prog/ch03_15.htm` }
get title() { return `Range Operator` }
    }

class hasReferencesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Reference_(computer_science)` }
get pseudoExample() { return `fn(objPointer)` }
get title() { return `References` }
    }

class hasRefinementTypesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Refinement_type` }
get pseudoExample() { return `evenInt where int % 2 = 0` }
get title() { return `Refinement Types` }
    }

class hasRegularExpressionsSyntaxSugarParser extends abstractFeatureParser {
      get pseudoExample() { return `/pldb/` }
get reference() { return `https://pldb.com/concepts/regex.html` }
get title() { return `Regular Expression Syntax Sugar` }
    }

class hasRequiredMainFunctionParser extends abstractFeatureParser {
      
    }

class hasReservedWordsParser extends abstractFeatureParser {
      
    }

class hasRunTimeGuardsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Guard_(computer_science)` }
get pseudoExample() { return `f x | x > 0 = 1 | otherwise = 0` }
get title() { return `Runtime Guards` }
    }

class hasSExpressionsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/S-expression` }
get pseudoExample() { return `(+ 1 1)` }
get title() { return `S-Expressions` }
    }

class hasScientificNotationParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Scientific_notation` }
get pseudoExample() { return `8076686.6e1` }
get aka() { return `E Notation` }
get title() { return `Scientific Notation` }
    }

class hasSelfOrThisWordParser extends abstractFeatureParser {
      
    }

class hasSemanticIndentationParser extends abstractFeatureParser {
      get pseudoExample() { return `line0 if true line1  print "Hello PLDB"` }
get reference() { return `https://pldb.com/posts/which-programming-languages-use-indentation.html` }
get title() { return `Semantic Indentation` }
get aka() { return `off-side rule` }
    }

class hasSetsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Set_(abstract_data_type)` }
get pseudoExample() { return `{"pldb", "PLDB"}` }
get title() { return `Sets` }
    }

class hasSingleDispatchParser extends abstractFeatureParser {
      get pseudoExample() { return `person.run()` }
get reference() { return `https://en.wikipedia.org/wiki/Dynamic_dispatch#Single_and_multiple_dispatch` }
get title() { return `Single Dispatch` }
    }

class hasSingleTypeArraysParser extends abstractFeatureParser {
      get pseudoExample() { return `const pldbRanks: int[]` }
get reference() { return `https://en.wikipedia.org/wiki/Array_data_structure` }
get title() { return `Single-Type Arrays` }
    }

class hasSourceMapsParser extends abstractFeatureParser {
      get pseudoExample() { return `{file: 'pldb.min.js',sources: ['pldb.js'], mappings: 'CAAC,IAAI,IAAM'}` }
get title() { return `Source Maps` }
    }

class hasStatementTerminatorCharacterParser extends abstractFeatureParser {
      
    }

class hasStatementsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Statement_(computer_science)` }
get pseudoExample() { return `print "Hello PLDB"` }
get title() { return `Statements` }
    }

class hasStaticMethodsParser extends abstractFeatureParser {
      get pseudoExample() { return `static downloadPldb() {}` }
get reference() { return `https://www.geeksforgeeks.org/static-methods-vs-instance-methods-java/` }
get title() { return `Static Methods` }
    }

class hasStaticTypingParser extends abstractFeatureParser {
      get pseudoExample() { return `int pldbRank = 100` }
get reference() { return `https://en.wikipedia.org/wiki/Type_system#Static_type_checking` }
get title() { return `Static Typing` }
    }

class hasStreamsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Stream_(computing)` }
get pseudoExample() { return `echo 123 | 123.txt` }
get title() { return `Streams` }
    }

class hasStringConcatOperatorParser extends abstractFeatureParser {
      
    }

class hasStringsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/String_(computer_science)` }
get tokenKeyword() { return `stringToken` }
get pseudoExample() { return `"Hello PLDB"` }
get title() { return `Strings` }
    }

class hasStructsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Struct_(C_programming_language)` }
get pseudoExample() { return `struct pldbFile { int rank; char *title; };` }
get title() { return `Structs` }
    }

class hasSwitchParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Switch_statement` }
get pseudoExample() { return `switch animal: case dog-buy; case cat-sell;` }
get title() { return `Switch Statements` }
    }

class hasSymbolTablesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Symbol_table` }
get pseudoExample() { return `SymbolName|Type|Scope;bar|function,double|extern` }
get title() { return `Symbol Tables` }
    }

class hasSymbolsParser extends abstractFeatureParser {
      
    }

class hasTemplatesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Template_metaprogramming` }
get pseudoExample() { return `template TCopy(T) {}` }
get title() { return `Templates` }
    }

class hasTernaryOperatorsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Ternary_operation` }
get pseudoExample() { return `true ? 1 : 0` }
get title() { return `Ternary operators` }
    }

class hasThreadsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Thread_(computing)` }
get pseudoExample() { return `thread1(); thread2();` }
get title() { return `Threads` }
    }

class hasTimestampsParser extends abstractFeatureParser {
      
    }

class hasTraitsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Trait_(computer_programming)` }
get pseudoExample() { return `use redBorder` }
get title() { return `Traits` }
    }

class hasTriplesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Semantic_triple` }
get pseudoExample() { return `Javascript isListedIn PLDB` }
get title() { return `Triples` }
    }

class hasTryCatchParser extends abstractFeatureParser {
      
    }

class hasTypeAnnotationsParser extends abstractFeatureParser {
      get pseudoExample() { return `score: number` }
get title() { return `Type Annotations` }
    }

class hasTypeInferenceParser extends abstractFeatureParser {
      get pseudoExample() { return `imAString = "pldb"` }
get reference() { return `https://en.wikipedia.org/wiki/Type_inference` }
get title() { return `Type Inference` }
    }

class hasTypeParametersParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/TypeParameter` }
get pseudoExample() { return `function identity<T>(arg: T): T {return arg}` }
get title() { return `Type Parameters` }
    }

class hasTypedHolesParser extends abstractFeatureParser {
      get pseudoExample() { return `2 + _ => 2 + [int|float]` }
get reference() { return `https://wiki.haskell.org/GHC/Typed_holes` }
get title() { return `Typed Holes` }
    }

class hasUnaryOperatorsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Unary_operation` }
get pseudoExample() { return `count++` }
get title() { return `Unary Operators` }
    }

class hasUnicodeIdentifiersParser extends abstractFeatureParser {
      get pseudoExample() { return `δ = 0.00001` }
get title() { return `Unicode Identifers` }
    }

class hasUnionTypesParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Union_type` }
get pseudoExample() { return `any = string | number` }
get title() { return `Union Types` }
    }

class hasUnitsOfMeasureParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Unit_of_measurement` }
get pseudoExample() { return `42cm` }
get title() { return `Units of Measure` }
    }

class hasUserDefinedOperatorsParser extends abstractFeatureParser {
      
    }

class hasValueReturnedFunctionsParser extends abstractFeatureParser {
      
    }

class hasVariableSubstitutionSyntaxParser extends abstractFeatureParser {
      get pseudoExample() { return `name = "PLDB"; print $name` }
get title() { return `Variable Substitution Syntax` }
    }

class hasVariadicFunctionsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Variadic_function` }
get pseudoExample() { return `args.map(doSomething)` }
get title() { return `Variadic Functions` }
    }

class hasVirtualFunctionsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Virtual_function` }
get pseudoExample() { return `virtual FetchPLDBFile();` }
get title() { return `Virtual function` }
    }

class hasVoidFunctionsParser extends abstractFeatureParser {
      
    }

class hasWhileLoopsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/While_loop` }
get pseudoExample() { return `while (pldb.pop()) loop()` }
get title() { return `While Loops` }
    }

class hasZeroBasedNumberingParser extends abstractFeatureParser {
      get pseudoExample() { return `firstItem = pldb[0]` }
get reference() { return `https://en.wikipedia.org/wiki/Zero-based_numbering` }
get title() { return `Zero-based numbering` }
    }

class hasZippersParser extends abstractFeatureParser {
      get pseudoExample() { return `pldbCursor.moveLeft()` }
get reference() { return `https://wiki.haskell.org/Zipper https://en.wikipedia.org/wiki/Zipper_(data_structure)` }
get title() { return `Zippers` }
    }

class isCaseSensitiveParser extends abstractFeatureParser {
      get pseudoExample() { return `pldb != PLDB` }
get reference() { return `https://en.wikipedia.org/wiki/Case_sensitivity` }
get title() { return `Case Sensitivity` }
    }

class isLispParser extends abstractFeatureParser {
      get pseudoExample() { return `(+ 1 2)` }
get reference() { return `https://en.wikipedia.org/wiki/Lisp_(programming_language)` }
get title() { return `Lispy` }
    }

class letterFirstIdentifiersParser extends abstractFeatureParser {
      get pseudoExample() { return `pldb100 = "OK" // 100pldb = "ERROR"` }
get title() { return `Letter-first Identifiers` }
    }

class mergesWhitespaceParser extends abstractFeatureParser {
      get pseudoExample() { return `result = 1    +    2` }
get reference() { return `http://wiki.c2.com/?SyntacticallySignificantWhitespaceConsideredHarmful` }
get title() { return `Merges Whitespace` }
    }

class supportsBreakpointsParser extends abstractFeatureParser {
      get reference() { return `https://en.wikipedia.org/wiki/Breakpoint` }
get pseudoExample() { return `debugger;` }
get title() { return `Breakpoints` }
    }

class isLanguageParser extends abstractBooleanColumnParser {
      get suggestInAutocomplete() { return false }
get isComputed() { return true }
    }

class isOpenSourceParser extends abstractBooleanColumnParser {
      get alwaysRecommended() { return true }
    }

class isPublicDomainParser extends abstractBooleanColumnParser {
      get alwaysRecommended() { return true }
    }

class gdbSupportParser extends abstractBooleanColumnParser {
      get sourceDomain() { return `sourceware.org` }
    }

class githubCopilotOptimizedParser extends abstractBooleanColumnParser {
      
    }

class isDeadParser extends abstractBooleanColumnParser {
      createParserCombinator() {
  return new TreeNode.ParserCombinator(urlCitationParser, undefined, undefined)
  }
    }

class abstractParadigmParser extends abstractBooleanColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get boolCell() {
      return this.getWord(1)
    }
    }

class visualParadigmParser extends abstractParadigmParser {
      
    }

class usesSemanticVersioningParser extends abstractBooleanColumnParser {
      
    }

class abstractOneWordGuidColumnParser extends abstractTrueBaseColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get externalGuidCell() {
      return this.getWord(1)
    }
get typeForCsvDocs() { return `guid` }
    }

class codeMirrorParser extends abstractOneWordGuidColumnParser {
      get sourceDomain() { return `codemirror.net` }
    }

class monacoParser extends abstractOneWordGuidColumnParser {
      get sourceDomain() { return `microsoft.github.io/monaco-editor/` }
    }

class tryItOnlineParser extends abstractOneWordGuidColumnParser {
      get sourceDomain() { return `tio.run` }
    }

class ubuntuPackageParser extends abstractOneWordGuidColumnParser {
      get sourceDomain() { return `ubuntu.com` }
    }

class abstractMultiwordGuidColumnParser extends abstractTrueBaseColumnParser {
      get externalGuidCell() {
      return this.getWordsFrom(0)
    }
get typeForCsvDocs() { return `guid` }
    }

class compilerExplorerParser extends abstractMultiwordGuidColumnParser {
      createParserCombinator() {
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"example" : exampleParser,
"helloWorldCollection" : helloWorldCollectionParser}), undefined)
  }
get sourceDomain() { return `godbolt.org` }
    }

class githubBigQueryParser extends abstractMultiwordGuidColumnParser {
      createParserCombinator() {class usersParser extends abstractPopulationCountColumnParser {
      
    }

class reposParser extends abstractCountColumnParser {
      
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"users" : usersParser,
"repos" : reposParser}), undefined)
  }
get sourceDomain() { return `cloud.google.com` }
    }

class githubLanguageParser extends abstractMultiwordGuidColumnParser {
      createParserCombinator() {class reposParser extends abstractCountColumnParser {
      get fromCrawler() { return true }
    }

class wrapParser extends abstractBooleanColumnParser {
      
    }

class trendingProjectsCountParser extends abstractCountColumnParser {
      get fromCrawler() { return true }
    }

class trendingProjectsParser extends abstractDelimitedValuesBlobColumnParser {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
get fromCrawler() { return true }
    }

class groupParser extends abstractMultiwordGuidColumnParser {
      
    }

class aliasesParser extends abstractStringListColumnParser {
      
    }

class interpretersParser extends abstractStringListColumnParser {
      
    }

class aceModeParser extends abstractWordColumnParser {
      
    }

class codemirrorModeParser extends abstractWordColumnParser {
      
    }

class codemirrorMimeTypeParser extends abstractWordColumnParser {
      
    }

class tmScopeParser extends abstractMultiwordGuidColumnParser {
      
    }

class typeParser extends abstractEnumColumnParser {
      
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"fileExtensions" : fileExtensionsParser,
"filenames" : filenamesParser,
"type" : typeParser,
"repos" : reposParser,
"wrap" : wrapParser,
"trendingProjectsCount" : trendingProjectsCountParser,
"trendingProjects" : trendingProjectsParser,
"group" : groupParser,
"aliases" : aliasesParser,
"interpreters" : interpretersParser,
"aceMode" : aceModeParser,
"codemirrorMode" : codemirrorModeParser,
"codemirrorMimeType" : codemirrorMimeTypeParser,
"tmScope" : tmScopeParser}), undefined)
  }
get sourceDomain() { return `github.com` }
    }

class leachim6Parser extends abstractMultiwordGuidColumnParser {
      createParserCombinator() {class filepathParser extends abstractStringColumnParser {
      
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"fileExtensions" : fileExtensionsParser,
"example" : exampleParser,
"helloWorldCollection" : helloWorldCollectionParser,
"filepath" : filepathParser}), undefined)
  }
get sourceDomain() { return `github.com/leachim6/hello-world` }
    }

class projectEulerParser extends abstractMultiwordGuidColumnParser {
      createParserCombinator() {class memberCountParser extends abstractAnnualPopulationCountMapParser {
      
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"memberCount" : memberCountParser}), undefined)
  }
get sourceDomain() { return `projecteuler.net` }
    }

class pygmentsHighlighterParser extends abstractMultiwordGuidColumnParser {
      createParserCombinator() {class filenameParser extends abstractTrueBaseColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get fileNameCell() {
      return this.getWord(1)
    }
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"fileExtensions" : fileExtensionsParser,
"filename" : filenameParser}), undefined)
  }
get sourceDomain() { return `pygments.org` }
    }

class pyplParser extends abstractMultiwordGuidColumnParser {
      get sourceDomain() { return `pypl.github.io` }
    }

class quineRelayParser extends abstractMultiwordGuidColumnParser {
      get sourceDomain() { return `github.com/mame/quine-relay` }
    }

class tiobeParser extends abstractMultiwordGuidColumnParser {
      createParserCombinator() {class currentRankParser extends abstractIntColumnParser {
      
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"currentRank" : currentRankParser}), undefined)
  }
get sourceDomain() { return `tiobe.com` }
    }

class abstractStringColumnParser extends abstractTrueBaseColumnParser {
      get stringCell() {
      return this.getWordsFrom(0)
    }
get typeForCsvDocs() { return `string` }
    }

class idParser extends abstractStringColumnParser {
      get suggestInAutocomplete() { return false }
get isComputed() { return true }
    }

class getSourceParser extends abstractStringColumnParser {
      get suggestInAutocomplete() { return false }
get isComputed() { return true }
    }

class descriptionParser extends abstractStringColumnParser {
      get alwaysRecommended() { return true }
    }

class abstractStringListColumnParser extends abstractStringColumnParser {
      get typeForCsvDocs() { return `string[]` }
    }

class keywordsParser extends abstractStringListColumnParser {
      get tokenCell() {
      return this.getWordsFrom(0)
    }
    }

class abstractCommonTokenParser extends abstractStringListColumnParser {
      get tokenCell() {
      return this.getWordsFrom(0)
    }
    }

class lineCommentTokenParser extends abstractCommonTokenParser {
      
    }

class multiLineCommentTokensParser extends abstractCommonTokenParser {
      
    }

class printTokenParser extends abstractCommonTokenParser {
      
    }

class stringTokenParser extends abstractCommonTokenParser {
      
    }

class assignmentTokenParser extends abstractCommonTokenParser {
      
    }

class booleanTokensParser extends abstractCommonTokenParser {
      
    }

class includeTokenParser extends abstractCommonTokenParser {
      
    }

class fileExtensionsParser extends abstractStringListColumnParser {
      get fileExtensionCell() {
      return this.getWordsFrom(0)
    }
    }

class filenamesParser extends abstractStringListColumnParser {
      get fileNameCell() {
      return this.getWordsFrom(0)
    }
    }

class creatorsParser extends abstractStringListColumnParser {
      get creatorNameCell() {
      return this.getWordsFrom(0)
    }
get alwaysRecommended() { return true }
    }

class originCommunityParser extends abstractStringListColumnParser {
      get alwaysRecommended() { return true }
    }

class abstractTrueBaseLinksColumnParser extends abstractStringListColumnParser {
      get trueBaseIdCell() {
      return this.getWordsFrom(0)
    }
get typeForCsvDocs() { return `trueBaseId[]` }
get trueBaseIds() {
 return this.getWordsFrom(1)
}
updateTruebaseIds(oldTrueBaseId, newTrueBaseId) {
 this.setContent(
  this.getWordsFrom(1)
   .map((word) => (word === oldTrueBaseId ? newTrueBaseId : word))
   .join(" ")
 )
}
    }

class forLanguagesParser extends abstractTrueBaseLinksColumnParser {
      
    }

class abstractRelationshipParser extends abstractTrueBaseLinksColumnParser {
      get sortKey() { return `abstractRelationshipParser` }
    }

class relatedParser extends abstractRelationshipParser {
      
    }

class runsOnVmParser extends abstractRelationshipParser {
      
    }

class influencedByParser extends abstractRelationshipParser {
      
    }

class successorOfParser extends abstractRelationshipParser {
      
    }

class subsetOfParser extends abstractRelationshipParser {
      
    }

class implementationOfParser extends abstractRelationshipParser {
      
    }

class renamedToParser extends abstractRelationshipParser {
      
    }

class supersetOfParser extends abstractRelationshipParser {
      
    }

class writtenInParser extends abstractRelationshipParser {
      
    }

class extensionOfParser extends abstractRelationshipParser {
      
    }

class forkOfParser extends abstractRelationshipParser {
      
    }

class compilesToParser extends abstractRelationshipParser {
      
    }

class inputLanguagesParser extends abstractRelationshipParser {
      
    }

class titleParser extends abstractStringColumnParser {
      
    }

class standsForParser extends abstractStringColumnParser {
      
    }

class akaParser extends abstractStringColumnParser {
      
    }

class oldNameParser extends abstractStringColumnParser {
      
    }

class abstractNumericColumnParser extends abstractTrueBaseColumnParser {
      get typeForCsvDocs() { return `number` }
    }

class abstractIntColumnParser extends abstractNumericColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get intCell() {
      return parseInt(this.getWord(1))
    }
get typeForCsvDocs() { return `integer` }
    }

class hoplIdParser extends abstractIntColumnParser {
      get suggestInAutocomplete() { return false }
get isComputed() { return true }
    }

class abstractComputedSumColumnParser extends abstractIntColumnParser {
      get suggestInAutocomplete() { return false }
get isComputed() { return true }
    }

class bookCountParser extends abstractComputedSumColumnParser {
      get suggestInAutocomplete() { return false }
    }

class paperCountParser extends abstractComputedSumColumnParser {
      get suggestInAutocomplete() { return false }
    }

class exampleCountParser extends abstractComputedSumColumnParser {
      get suggestInAutocomplete() { return false }
    }

class factCountParser extends abstractComputedSumColumnParser {
      get suggestInAutocomplete() { return false }
    }

class abstractCountColumnParser extends abstractIntColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get countCell() {
      return parseFloat(this.getWord(1))
    }
    }

class abstractComputedEstimateColumnParser extends abstractCountColumnParser {
      get suggestInAutocomplete() { return false }
get isComputed() { return true }
    }

class numberOfUsersEstimateParser extends abstractComputedEstimateColumnParser {
      get suggestInAutocomplete() { return false }
    }

class numberOfJobsEstimateParser extends abstractComputedEstimateColumnParser {
      get suggestInAutocomplete() { return false }
    }

class centralPackageRepositoryCountParser extends abstractCountColumnParser {
      
    }

class packageInstallCountParser extends abstractCountColumnParser {
      
    }

class packageCountParser extends abstractCountColumnParser {
      
    }

class abstractPopulationCountColumnParser extends abstractCountColumnParser {
      
    }

class packageAuthorsParser extends abstractPopulationCountColumnParser {
      
    }

class abstractComputedRankColumnParser extends abstractIntColumnParser {
      get suggestInAutocomplete() { return false }
get isComputed() { return true }
    }

class rankParser extends abstractComputedRankColumnParser {
      get suggestInAutocomplete() { return false }
    }

class languageRankParser extends abstractComputedRankColumnParser {
      get suggestInAutocomplete() { return false }
    }

class abstractYearColumnParser extends abstractIntColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get yearCell() {
      return parseFloat(this.getWord(1))
    }
    }

class lastActivityParser extends abstractYearColumnParser {
      get isComputed() { return true }
get suggestInAutocomplete() { return false }
    }

class appearedParser extends abstractYearColumnParser {
      
    }

class wordRankParser extends abstractIntColumnParser {
      
    }

class abstractFloatColumnParser extends abstractNumericColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get floatCell() {
      return parseFloat(this.getWord(1))
    }
    }

class abstractPercentageColumnParser extends abstractNumericColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get percentCell() {
      return this.getWord(1)
    }
    }

class countryParser extends abstractTrueBaseColumnParser {
      get countryNameCell() {
      return this.getWordsFrom(0)
    }
get alwaysRecommended() { return true }
    }

class dblpParser extends abstractTrueBaseColumnParser {
      createParserCombinator() {class hitsParser extends abstractCountColumnParser {
      
    }

class publicationsParser extends abstractDelimitedValuesBlobColumnParser {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"hits" : hitsParser,
"publications" : publicationsParser}), undefined)
  }
get sourceDomain() { return `dblp.org` }
get fromCrawler() { return true }
    }

class abstractStringBlobColumnParser extends abstractTrueBaseColumnParser {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
get typeForCsvDocs() { return `multilineString` }
get columnValue() {
 return this.childrenToString()
}
    }

class abstractCodeColumnParser extends abstractStringBlobColumnParser {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
    }

class equationParser extends abstractCodeColumnParser {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
    }

class exampleParser extends abstractCodeColumnParser {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
    }

class helloWorldCollectionParser extends exampleParser {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
get columnNameCell() {
      return this.getWord(0)
    }
get helloWorldCollectionIdCell() {
      return this.getWordsFrom(1)
    }
get sourceDomain() { return `helloworldcollection.de` }
    }

class funFactParser extends abstractCodeColumnParser {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
get columnNameCell() {
      return this.getWord(0)
    }
get urlCell() {
      return this.getWord(1)
    }
    }

class abstractDelimitedValuesBlobColumnParser extends abstractStringBlobColumnParser {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
    }

class goodreadsParser extends abstractDelimitedValuesBlobColumnParser {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
get sourceDomain() { return `goodreads.com` }
get fromCrawler() { return true }
    }

class hackerNewsDiscussionsParser extends abstractDelimitedValuesBlobColumnParser {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
get sourceDomain() { return `news.ycombinator.com` }
get fromCrawler() { return true }
    }

class isbndbParser extends abstractDelimitedValuesBlobColumnParser {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
get sourceDomain() { return `isbndb.com` }
get fromCrawler() { return true }
    }

class semanticScholarParser extends abstractDelimitedValuesBlobColumnParser {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
get sourceDomain() { return `semanticscholar.org` }
get fromCrawler() { return true }
    }

class abstractEnumColumnParser extends abstractTrueBaseColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get enumCell() {
      return this.getWord(1)
    }
get typeForCsvDocs() { return `enum` }
    }

class fileTypeParser extends abstractEnumColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get fileTypeWordCell() {
      return this.getWord(1)
    }
    }

class nativeLanguageParser extends abstractEnumColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get nativeLanguageWordCell() {
      return this.getWord(1)
    }
    }

class announcementMethodParser extends abstractEnumColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get announcementMethodCell() {
      return this.getWord(1)
    }
    }

class typeParser extends abstractEnumColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get typeCell() {
      return this.getWord(1)
    }
    }

class abstractHashMapColumnParser extends abstractTrueBaseColumnParser {
      get typeForCsvDocs() { return `multilineStringMap` }
get columnValue() {
 return this.childrenToString()
}
    }

class abstractAnnualPopulationCountMapParser extends abstractHashMapColumnParser {
      createParserCombinator() {
  return new TreeNode.ParserCombinator(annualPopulationCountParser, undefined, undefined)
  }
    }

class indeedJobsParser extends abstractAnnualPopulationCountMapParser {
      get stringCell() {
      return this.getWordsFrom(0)
    }
get sourceDomain() { return `indeed.com` }
    }

class linkedInSkillParser extends abstractAnnualPopulationCountMapParser {
      get stringCell() {
      return this.getWordsFrom(0)
    }
get sourceDomain() { return `linkedin.com` }
    }

class abstractAnnualRankMapParser extends abstractHashMapColumnParser {
      createParserCombinator() {
  return new TreeNode.ParserCombinator(annualRankParser, undefined, undefined)
  }
    }

class repoStatsParser extends abstractHashMapColumnParser {
      createParserCombinator() {class firstCommitParser extends abstractYearColumnParser {
      
    }

class commitsParser extends abstractCountColumnParser {
      
    }

class committersParser extends abstractCountColumnParser {
      
    }

class filesParser extends abstractCountColumnParser {
      
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"description" : descriptionParser,
"firstCommit" : firstCommitParser,
"commits" : commitsParser,
"committers" : committersParser,
"files" : filesParser}), undefined)
  }
    }

class stackOverflowSurveyParser extends abstractHashMapColumnParser {
      createParserCombinator() {class stackOverflowSurveyYearParser extends GrammarBackedNode {
      createParserCombinator() {class usersParser extends abstractPopulationCountColumnParser {
      
    }

class medianSalaryParser extends abstractIntColumnParser {
      
    }

class fansParser extends abstractPopulationCountColumnParser {
      
    }

class percentageUsingParser extends abstractFloatColumnParser {
      
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"users" : usersParser,
"medianSalary" : medianSalaryParser,
"fans" : fansParser,
"percentageUsing" : percentageUsingParser}), undefined)
  }
get yearCell() {
      return parseFloat(this.getWord(0))
    }
    }
  return new TreeNode.ParserCombinator(undefined, undefined, [{regex: /\d+/, parser: stackOverflowSurveyYearParser}])
  }
get sourceDomain() { return `insights.stackoverflow.com` }
    }

class versionsParser extends abstractHashMapColumnParser {
      createParserCombinator() {
  return new TreeNode.ParserCombinator(versionParser, undefined, undefined)
  }
    }

class abstractWordColumnParser extends abstractTrueBaseColumnParser {
      get columnNameCell() {
      return this.getWord(0)
    }
get wordCell() {
      return this.getWord(1)
    }
get typeForCsvDocs() { return `word` }
    }

class domainNameParser extends abstractWordColumnParser {
      createParserCombinator() {class registeredParser extends abstractYearColumnParser {
      
    }

class awisRankParser extends abstractAnnualRankMapParser {
      get sourceDomain() { return `aws.amazon.com` }
    }
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"registered" : registeredParser,
"awisRank" : awisRankParser}), undefined)
  }
get columnNameCell() {
      return this.getWord(0)
    }
get domainNameCell() {
      return this.getWord(1)
    }
    }

class featureExampleCodeParser extends GrammarBackedNode {
      createParserCombinator() { return new TreeNode.ParserCombinator(this._getBlobParserCatchAllParser())}
getErrors() { return [] }
    }

class annualRankParser extends GrammarBackedNode {
      get yearCell() {
      return parseFloat(this.getWord(0))
    }
get rankCell() {
      return parseFloat(this.getWord(1))
    }
    }

class pldbParser extends GrammarBackedNode {
      createParserCombinator() {
  return new TreeNode.ParserCombinator(trueBaseErrorParser, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"annualReportsUrl" : annualReportsUrlParser,
"antlr" : antlrParser,
"hopl" : hoplParser,
"jupyterKernel" : jupyterKernelParser,
"meetup" : meetupParser,
"subreddit" : subredditParser,
"replit" : replitParser,
"rosettaCode" : rosettaCodeParser,
"twitter" : twitterParser,
"discord" : discordParser,
"discourse" : discourseParser,
"irc" : ircParser,
"zulip" : zulipParser,
"cheatSheetUrl" : cheatSheetUrlParser,
"conference" : conferenceParser,
"demoVideo" : demoVideoParser,
"documentation" : documentationParser,
"devDocumentation" : devDocumentationParser,
"downloadPageUrl" : downloadPageUrlParser,
"ebook" : ebookParser,
"emailList" : emailListParser,
"esolang" : esolangParser,
"eventsPageUrl" : eventsPageUrlParser,
"faqPageUrl" : faqPageUrlParser,
"gitRepo" : gitRepoParser,
"githubRepo" : githubRepoParser,
"gitlabRepo" : gitlabRepoParser,
"sourcehutRepo" : sourcehutRepoParser,
"gource" : gourceParser,
"firstAnnouncement" : firstAnnouncementParser,
"screenshot" : screenshotParser,
"photo" : photoParser,
"languageServerProtocolProject" : languageServerProtocolProjectParser,
"linguistGrammarRepo" : linguistGrammarRepoParser,
"officialBlogUrl" : officialBlogUrlParser,
"packageRepository" : packageRepositoryParser,
"proposals" : proposalsParser,
"redditDiscussion" : redditDiscussionParser,
"reference" : referenceParser,
"releaseNotesUrl" : releaseNotesUrlParser,
"rijuRepl" : rijuReplParser,
"roadmap" : roadmapParser,
"spec" : specParser,
"website" : websiteParser,
"webRepl" : webReplParser,
"wikipedia" : wikipediaParser,
"canDoShebang" : canDoShebangParser,
"canReadCommandLineArgs" : canReadCommandLineArgsParser,
"canUseQuestionMarksAsPartOfIdentifier" : canUseQuestionMarksAsPartOfIdentifierParser,
"canWriteToDisk" : canWriteToDiskParser,
"hasAbstractTypes" : hasAbstractTypesParser,
"hasAccessModifiers" : hasAccessModifiersParser,
"hasAlgebraicTypes" : hasAlgebraicTypesParser,
"hasAnonymousFunctions" : hasAnonymousFunctionsParser,
"hasArraySlicingSyntax" : hasArraySlicingSyntaxParser,
"hasAssertStatements" : hasAssertStatementsParser,
"hasAssignment" : hasAssignmentParser,
"hasAsyncAwait" : hasAsyncAwaitParser,
"hasBinaryNumbers" : hasBinaryNumbersParser,
"hasBinaryOperators" : hasBinaryOperatorsParser,
"hasBitWiseOperators" : hasBitWiseOperatorsParser,
"hasBlobs" : hasBlobsParser,
"hasBooleans" : hasBooleansParser,
"hasBoundedCheckedArrays" : hasBoundedCheckedArraysParser,
"hasBreak" : hasBreakParser,
"hasBuiltInRegex" : hasBuiltInRegexParser,
"hasCaseInsensitiveIdentifiers" : hasCaseInsensitiveIdentifiersParser,
"hasCharacters" : hasCharactersParser,
"hasClasses" : hasClassesParser,
"hasClobs" : hasClobsParser,
"hasComments" : hasCommentsParser,
"hasConditionals" : hasConditionalsParser,
"hasConstants" : hasConstantsParser,
"hasConstructors" : hasConstructorsParser,
"hasContinue" : hasContinueParser,
"hasDecimals" : hasDecimalsParser,
"hasDefaultParameters" : hasDefaultParametersParser,
"hasDependentTypes" : hasDependentTypesParser,
"hasDestructuring" : hasDestructuringParser,
"hasDirectives" : hasDirectivesParser,
"hasDisposeBlocks" : hasDisposeBlocksParser,
"hasDocComments" : hasDocCommentsParser,
"hasDuckTyping" : hasDuckTypingParser,
"hasDynamicProperties" : hasDynamicPropertiesParser,
"hasDynamicSizedArrays" : hasDynamicSizedArraysParser,
"hasDynamicTyping" : hasDynamicTypingParser,
"hasEnums" : hasEnumsParser,
"hasEscapeCharacters" : hasEscapeCharactersParser,
"hasExceptions" : hasExceptionsParser,
"hasExplicitTypeCasting" : hasExplicitTypeCastingParser,
"hasExports" : hasExportsParser,
"hasExpressions" : hasExpressionsParser,
"hasFirstClassFunctions" : hasFirstClassFunctionsParser,
"hasFixedPoint" : hasFixedPointParser,
"hasFloats" : hasFloatsParser,
"hasFnArguments" : hasFnArgumentsParser,
"hasForEachLoops" : hasForEachLoopsParser,
"hasForLoops" : hasForLoopsParser,
"hasFunctionComposition" : hasFunctionCompositionParser,
"hasFunctionOverloading" : hasFunctionOverloadingParser,
"hasFunctions" : hasFunctionsParser,
"hasGarbageCollection" : hasGarbageCollectionParser,
"hasGenerators" : hasGeneratorsParser,
"hasGenerics" : hasGenericsParser,
"hasGlobalScope" : hasGlobalScopeParser,
"hasGotos" : hasGotosParser,
"hasHereDocs" : hasHereDocsParser,
"hasHexadecimals" : hasHexadecimalsParser,
"hasHomoiconicity" : hasHomoiconicityParser,
"hasIds" : hasIdsParser,
"hasIfElses" : hasIfElsesParser,
"hasIfs" : hasIfsParser,
"hasImplicitArguments" : hasImplicitArgumentsParser,
"hasImplicitTypeConversions" : hasImplicitTypeConversionsParser,
"hasImports" : hasImportsParser,
"hasIncrementAndDecrementOperators" : hasIncrementAndDecrementOperatorsParser,
"hasInfixNotation" : hasInfixNotationParser,
"hasInheritance" : hasInheritanceParser,
"hasIntegers" : hasIntegersParser,
"hasInterfaces" : hasInterfacesParser,
"hasIterators" : hasIteratorsParser,
"hasLabels" : hasLabelsParser,
"hasLazyEvaluation" : hasLazyEvaluationParser,
"hasLineComments" : hasLineCommentsParser,
"hasLists" : hasListsParser,
"hasMacros" : hasMacrosParser,
"hasMagicGettersAndSetters" : hasMagicGettersAndSettersParser,
"hasManualMemoryManagement" : hasManualMemoryManagementParser,
"hasMapFunctions" : hasMapFunctionsParser,
"hasMaps" : hasMapsParser,
"hasMemberVariables" : hasMemberVariablesParser,
"hasMessagePassing" : hasMessagePassingParser,
"hasMethodChaining" : hasMethodChainingParser,
"hasMethodOverloading" : hasMethodOverloadingParser,
"hasMethods" : hasMethodsParser,
"hasMixins" : hasMixinsParser,
"hasModules" : hasModulesParser,
"hasMonads" : hasMonadsParser,
"hasMultiLineComments" : hasMultiLineCommentsParser,
"hasMultilineStrings" : hasMultilineStringsParser,
"hasMultipleDispatch" : hasMultipleDispatchParser,
"hasMultipleInheritance" : hasMultipleInheritanceParser,
"hasNamespaces" : hasNamespacesParser,
"hasNull" : hasNullParser,
"hasOctals" : hasOctalsParser,
"hasOperatorOverloading" : hasOperatorOverloadingParser,
"hasOperators" : hasOperatorsParser,
"hasPairs" : hasPairsParser,
"hasPartialApplication" : hasPartialApplicationParser,
"hasPatternMatching" : hasPatternMatchingParser,
"hasPipes" : hasPipesParser,
"hasPointers" : hasPointersParser,
"hasPolymorphism" : hasPolymorphismParser,
"hasPostfixNotation" : hasPostfixNotationParser,
"hasPrefixNotation" : hasPrefixNotationParser,
"hasPrintDebugging" : hasPrintDebuggingParser,
"hasProcessorRegisters" : hasProcessorRegistersParser,
"hasRangeOperators" : hasRangeOperatorsParser,
"hasReferences" : hasReferencesParser,
"hasRefinementTypes" : hasRefinementTypesParser,
"hasRegularExpressionsSyntaxSugar" : hasRegularExpressionsSyntaxSugarParser,
"hasRequiredMainFunction" : hasRequiredMainFunctionParser,
"hasReservedWords" : hasReservedWordsParser,
"hasRunTimeGuards" : hasRunTimeGuardsParser,
"hasSExpressions" : hasSExpressionsParser,
"hasScientificNotation" : hasScientificNotationParser,
"hasSelfOrThisWord" : hasSelfOrThisWordParser,
"hasSemanticIndentation" : hasSemanticIndentationParser,
"hasSets" : hasSetsParser,
"hasSingleDispatch" : hasSingleDispatchParser,
"hasSingleTypeArrays" : hasSingleTypeArraysParser,
"hasSourceMaps" : hasSourceMapsParser,
"hasStatementTerminatorCharacter" : hasStatementTerminatorCharacterParser,
"hasStatements" : hasStatementsParser,
"hasStaticMethods" : hasStaticMethodsParser,
"hasStaticTyping" : hasStaticTypingParser,
"hasStreams" : hasStreamsParser,
"hasStringConcatOperator" : hasStringConcatOperatorParser,
"hasStrings" : hasStringsParser,
"hasStructs" : hasStructsParser,
"hasSwitch" : hasSwitchParser,
"hasSymbolTables" : hasSymbolTablesParser,
"hasSymbols" : hasSymbolsParser,
"hasTemplates" : hasTemplatesParser,
"hasTernaryOperators" : hasTernaryOperatorsParser,
"hasThreads" : hasThreadsParser,
"hasTimestamps" : hasTimestampsParser,
"hasTraits" : hasTraitsParser,
"hasTriples" : hasTriplesParser,
"hasTryCatch" : hasTryCatchParser,
"hasTypeAnnotations" : hasTypeAnnotationsParser,
"hasTypeInference" : hasTypeInferenceParser,
"hasTypeParameters" : hasTypeParametersParser,
"hasTypedHoles" : hasTypedHolesParser,
"hasUnaryOperators" : hasUnaryOperatorsParser,
"hasUnicodeIdentifiers" : hasUnicodeIdentifiersParser,
"hasUnionTypes" : hasUnionTypesParser,
"hasUnitsOfMeasure" : hasUnitsOfMeasureParser,
"hasUserDefinedOperators" : hasUserDefinedOperatorsParser,
"hasValueReturnedFunctions" : hasValueReturnedFunctionsParser,
"hasVariableSubstitutionSyntax" : hasVariableSubstitutionSyntaxParser,
"hasVariadicFunctions" : hasVariadicFunctionsParser,
"hasVirtualFunctions" : hasVirtualFunctionsParser,
"hasVoidFunctions" : hasVoidFunctionsParser,
"hasWhileLoops" : hasWhileLoopsParser,
"hasZeroBasedNumbering" : hasZeroBasedNumberingParser,
"hasZippers" : hasZippersParser,
"isCaseSensitive" : isCaseSensitiveParser,
"isLisp" : isLispParser,
"letterFirstIdentifiers" : letterFirstIdentifiersParser,
"mergesWhitespace" : mergesWhitespaceParser,
"supportsBreakpoints" : supportsBreakpointsParser,
"isLanguage" : isLanguageParser,
"isOpenSource" : isOpenSourceParser,
"isPublicDomain" : isPublicDomainParser,
"gdbSupport" : gdbSupportParser,
"githubCopilotOptimized" : githubCopilotOptimizedParser,
"isDead" : isDeadParser,
"visualParadigm" : visualParadigmParser,
"usesSemanticVersioning" : usesSemanticVersioningParser,
"codeMirror" : codeMirrorParser,
"monaco" : monacoParser,
"tryItOnline" : tryItOnlineParser,
"ubuntuPackage" : ubuntuPackageParser,
"compilerExplorer" : compilerExplorerParser,
"githubBigQuery" : githubBigQueryParser,
"githubLanguage" : githubLanguageParser,
"leachim6" : leachim6Parser,
"projectEuler" : projectEulerParser,
"pygmentsHighlighter" : pygmentsHighlighterParser,
"pypl" : pyplParser,
"quineRelay" : quineRelayParser,
"tiobe" : tiobeParser,
"id" : idParser,
"getSource" : getSourceParser,
"description" : descriptionParser,
"keywords" : keywordsParser,
"lineCommentToken" : lineCommentTokenParser,
"multiLineCommentTokens" : multiLineCommentTokensParser,
"printToken" : printTokenParser,
"stringToken" : stringTokenParser,
"assignmentToken" : assignmentTokenParser,
"booleanTokens" : booleanTokensParser,
"includeToken" : includeTokenParser,
"fileExtensions" : fileExtensionsParser,
"filenames" : filenamesParser,
"creators" : creatorsParser,
"originCommunity" : originCommunityParser,
"forLanguages" : forLanguagesParser,
"related" : relatedParser,
"runsOnVm" : runsOnVmParser,
"influencedBy" : influencedByParser,
"successorOf" : successorOfParser,
"subsetOf" : subsetOfParser,
"implementationOf" : implementationOfParser,
"renamedTo" : renamedToParser,
"supersetOf" : supersetOfParser,
"writtenIn" : writtenInParser,
"extensionOf" : extensionOfParser,
"forkOf" : forkOfParser,
"compilesTo" : compilesToParser,
"inputLanguages" : inputLanguagesParser,
"title" : titleParser,
"standsFor" : standsForParser,
"aka" : akaParser,
"oldName" : oldNameParser,
"hoplId" : hoplIdParser,
"bookCount" : bookCountParser,
"paperCount" : paperCountParser,
"exampleCount" : exampleCountParser,
"factCount" : factCountParser,
"numberOfUsersEstimate" : numberOfUsersEstimateParser,
"numberOfJobsEstimate" : numberOfJobsEstimateParser,
"centralPackageRepositoryCount" : centralPackageRepositoryCountParser,
"packageInstallCount" : packageInstallCountParser,
"packageCount" : packageCountParser,
"packageAuthors" : packageAuthorsParser,
"rank" : rankParser,
"languageRank" : languageRankParser,
"lastActivity" : lastActivityParser,
"appeared" : appearedParser,
"wordRank" : wordRankParser,
"country" : countryParser,
"dblp" : dblpParser,
"equation" : equationParser,
"example" : exampleParser,
"helloWorldCollection" : helloWorldCollectionParser,
"funFact" : funFactParser,
"goodreads" : goodreadsParser,
"hackerNewsDiscussions" : hackerNewsDiscussionsParser,
"isbndb" : isbndbParser,
"semanticScholar" : semanticScholarParser,
"fileType" : fileTypeParser,
"nativeLanguage" : nativeLanguageParser,
"announcementMethod" : announcementMethodParser,
"type" : typeParser,
"indeedJobs" : indeedJobsParser,
"linkedInSkill" : linkedInSkillParser,
"repoStats" : repoStatsParser,
"stackOverflowSurvey" : stackOverflowSurveyParser,
"versions" : versionsParser,
"domainName" : domainNameParser}), [{regex: /^$/, parser: blankLineParser}])
  }
get fileNameCell() {
      return this.getWord(0)
    }
get fileExtension() { return `pldb` }
static cachedHandGrammarProgramRoot = new HandGrammarProgram(`// Basics
// todo trim the trailing slash
// Basics
// todo Grammar should probably have pattern matching. And then we can detect semantic versions in the below.
// todo Scoping by file in Grammar lang would be really useful for this file. Also, multiple inheritance or mixins.
// WorldWideColumns is an experimental attempt to define reusuable base abstract column types for TrueBases.
// Version 2.0.0
// Cell Parsers
// Enum Parsers
// Numeric cell parsers
// Common numeric cell extensions
// String Cell Parsers
// Line Parsers
// The main line parser. Anything extending this will be included in the CSV dumps.
// Common string parsers
// Common blob parsers
// Links between TrueBase files
// Boolean column node
// Commmon numeric parsers
// Common time parsers
// Common miscellaneous parsers
// URL Parsers
// GUID Parsers
// Hashmap parsers
// Common population columns
// Common computed types























































conferenceNameCell
 extends stringCell
countryNameCell
 extends stringCell
tokenCell
 highlightScope keyword
fileExtensionCell
 extends stringCell
fileTypeWordCell
 enum paper text binary na
 highlightScope constant.language
githubRepoUrlCell
 extends urlCell
 regex ^https://github.com/.+/.+$
helloWorldCollectionIdCell
 description Id for this language on hello world collection.
nativeLanguageWordCell
 description The name of a natural language like English or Japanese.
announcementMethodCell
 description Common ways languages are first announced.
 enum pressRelease paper rfc webpage blogPost interview dissertation
 highlightScope constant.language
creatorNameCell
 extends stringCell
aliasCell
rankCell
 extends intCell
typeCell
 enum assembly pl barCodeFormat hardwareDescriptionLanguage knowledgeBase binaryDataFormat contractLanguage timeFormat computingMachine xmlFormat yamlFormat jsonFormat compiler grammarLanguage dataValidationLanguage application ir isa queryLanguage protocol os esolang template textMarkup characterEncoding idl library editor cloud textDataFormat visual plzoo interpreter notation binaryExecutable dataNotation stylesheetLanguage schema bytecode vm filesystem standard linter packageManager framework webApi feature optimizingCompiler numeralSystem hashFunction database font distribution headerLang dataStructure musicalNotation textEncodingFormat equation wikiMarkup decompiler configFormat diffFormat unixApplication webBrowser browserEngine
 highlightScope constant.language
versionCell
 extends stringCell
 description Version numbers.
domainNameCell
 extends stringCell
blankCell
anyCell
enumCell
boolCell
 extends enumCell
 enum true false
numberCell
intCell
 extends numberCell
 highlightScope constant.numeric.integer
floatCell
 extends numberCell
 highlightScope constant.numeric.float
percentCell
 highlightScope constant.numeric.integer
 regex \\d+%
countCell
 extends intCell
populationCountCell
 description A count of people.
 extends countCell
yearCell
 extends intCell
stringCell
 highlightScope string
wordCell
 extends stringCell
 description Any string except for a blank cell.
 regex .+
columnNameCell
 highlightScope keyword
 regex [a-zA-Z0-9]+
trueBaseIdCell
 description A global identifier for this entity in a TrueBase. Currently a very restricted character set to ensure compatibility between a wide variety of URLs and filesystems.
 regex [a-z0-9\\-\\.]+
 highlightScope string
 enum 05ab1e 1-pak 1620sps 1c-enterprise 2-pak 20-gate 2lisp 2obj 3-lisp 3apl 3d-logo 3dcomposer 3ds 3mf 3rip 4g-standard 4th-dimension 51forth 6gunz 8th a-0-system a-sharp a51 aadl aaf aarch64 aardappel aardvark abacus-machine abal abap abbreviated-test-language-for-all-systems abc-80 abc-algol abc abcl-cp abcl-f abcl-lang abcl abcpp abel able abnf abs abset abstract-state-machine-language abstracto absys ac-toolbox accent ace acl acl2 acme acore acorn-atom acorn-lang acorn acornsoft-logo acos acsi-matic acsl act-iii act-one actalk action-code-script action actionscript active-language-i active-u-datalog activevfp activity-pub actor actors actus ad-hoc ada-95 ada-9x ada-tl ada adabtpl adagio adam-standard adam adamant adaplex address adenine-programming-language adept ades-ii ades aditi adlib adobe-font-metrics ads-b-standard advanced-continuous-simulation-language advice-taker aed aepl aesop afnix afs agda agent-k agentspeak agl agora ags-script aheui aida aids ail aime aiml aimms air airtable-app ais aith akl al aladin alambik alan alba albatross alcor aldat aldes aldor aldwych ale alec alef aleph alf alfred algae algebraic-compiler algebraic-modeling-language algem algernon algo algobox algol-58 algol-60 algol-68-r algol-68-rt algol-68 algol-e algol-n algol-w algol-x algol algy alice aljabr allegro-common-lisp allo alloy alma-0 alma-007 alma-o alma almir almquist-shell alohanet alonzo alpaca alpak alpha-programming-language alphabasic alphapop alphard-programming-language alphard alpine-abuild alps altac altair-basic altibase altran alumina amalthea amanda amazon-dynamodb amazon-rds amber ambienttalk ambit-g ambit-l ambit ambush amiga-e amiga-programming-languages amigabasic amos amperes-circuital-equation ampl amppl-i amppl-ii amqp amtran-70 amtran amulet ana analytical-engine-machine and-or andante andorra-i andorra android angelscript angr anna ans-mumps ansi-basic ant-build-system ante-esolang ante antha antlr apache-cassandra apache-derby apache-hbase apache-phoenix apache-velocity apache apacheconf apar aparel ape100 apescript apex api-blueprint apl-gpss apl-hp apl-z80 apl apl2 aplette aplgol-2 aplgol aplo aplus aplusplus aplx apollo-guidance-computer apostle appcode-editor appl-a apple-1-machine apple-basic apple-prodos applescript applesoft-basic applog april aprol apse apt-pm apt aqasm aql aquarius-prolog arabic-numerals arablan arango-db arbortext-command-language arc-assembly arc-isa arc archi archieml arctic arden-syntax arduino arend aretext arexx arezzo-notation argdown argon argos argus arith-matic arjuna ark-lang ark arkscript arm-templates arm armani arret arrow-format arrow arta artspeak arturo arvelie-format ascii-armor ascii asciidoc asciidots asciimath asdf asf-sdf ashmedai asic-programming-language asmjs asn-1 asp.net asp aspectcpp aspectj aspen aspol assembly-language assemblyscript associons asspegique astatine asterisk asterius-compiler astlog astro astroml asymptote atari-basic atari-microsoft-basic atari-st-basic atlas-autocode atlas atmel-avr atol atom-editor atom atomese atomo atomos atomspace ats attic-numerals attoparsec atx aubit-4gl augeas augment aui aur-pm aurora austral autasim autocad-app autocode autocoder-ii autocoder-iii autocoder autoconf autodraft autogrp autohotkey autoit autolisp autoloft automast automator autopromt avail avalon-common-lisp averest avi-synth avr avro awk awl aws axcess axiom-computer-algebra-system axiom axt-format aztec-c azure b-line b b3-ir b32-business-basic b4tran babel baby-modula-3 babylonian-numerals back badlanguage bag-format balanced-ternary-notation balg balgol balinda-lisp ballerina-central-pm ballerina balm balsa baltazar baltik bam-format bamboo bancstar-programming-language bare barrel bartok base64 baseball basel bash basic-11 basic-256 basic-ap basic-e basic-pdp-1-lisp basic-plus basic-programming basic-stamp basic basic09 basic4android basic4gl basic4ppc basicode basicx basil basis-universal-format batari-basic batch battlestar bawk bayer-expressions bayes-equation baysick bazel bbc-basic bbcode bbj bbn-lisp bbx bc-neliac bc bcpl bcx bdl beads-lang beagle beam-bytecode beam-vm beanshell beatnik beautiful-report-language bebasic bed-format bedsocs bee beebasic beef-lang beef beflix befunge behavior-markup-language bel-lang bel ber berkeley-db-lib berkeleydb berry besys beta-basic beta-project beta-prolog beta bgraf2 bhsl bibtex bicep biferno bigloo bigmac bigwig-format bigwig-programming-language bigwig binary-equation binary-ninja binary-notation binaryen bind-app bioconductor-pm biomod bioscript biossim biplan bird birkbeck-assembly bison bisonpp bistro-programming-language bitarray bitbake bitc bizubee bjou bla blackcoffee blacklight blade-lang blade blake-hash-function blank blaze-2 blaze blazex blc blender-app bliss blitz3d blitzbasic blitzmax blitzplus blockly blockml bloom blooms bloop blox blue-programming-language blue blueprints bluespec blur-markup-language blz bmd bml bmp-format bnf boa bob bog boil bolin bolt bon-programming-language boo boogie boomerang-decompiler boost-lib booster borneo boron bosque bossam bounce-lang bounce bourne-shell boxer boxx bpel bpkg-pm bpl bpmn bpn2 bqn brackets-editor brain-flak brainfuck breccia bridgetalk brightscript-lang brisk brl bro broccoli-1 broccoli-2 broccoli brooks-programming-language brouhaha brown-university-interactive-language bscript-interpreter bscript bsml bsp bucardo bucklescript buddyscript bugsys bullfrog bun bush business-application-language business-basic business-object-notation business-process-modeling-language business-rule-language butterfly-common-lisp buzz bx bytecode-modeling-language bytelisp bython bywater-basic c-- c-al c-cubed c-flat c-for-all c-headers c-shell c-smile c-talk c c2 c3 ca-realizer ca-telon ca65-assembly cabal cache-basic cache-objectscript cactus cadence-skill cado-systems-technical-information cafeobj caffeine cages caisys cajole cal calc-var calc calc4 cali-lang caltech-intermediate-form calypso cam camac camal camil caml candor candy-codes candy cane canon-capsl cantor capn-proto capsl capsule capybara caramel carbon carp carpet carth cartocss casio-basic cassandre cat catala catalysis categorical-query-language cayenne cayley cbasic cbor ccal ccd ccel ccr ccs cda cddl cdf cdl cdlpp cecil cedar-fortran cedar ceemac celip cell cellsim celsius-webscript ceprol cesil ceu ceylon cfengine cfml cfscript cg cgol ch chain-format chain-programming-language chained-arrow-notation chaiscript champ chaos-lang chapel chappe-code charcoal charity charly charmpp charrette-ada chartio-app charybdis chatterbot checked-c checkout cheetah chef chemtrains cheri chevrotain chibicc chicken-lang chicken chicon chika chill chimera chinese-basic chip-8 chip-programming-language chipmunk-basic chirp chisel chocolatey-pm chomski chrome-programming-language chronolog chronologmc chronologz chrysalisp chuck ciao-programming-language ciel cif cigale cil cilk cimfast cims-pl-i cir circa circal circle-lang cirru cish cito citrine cityhash-hash-function cixl cl-i claire clamp clanger clarion clarity claro clascal clash class classic-ada classic clausal-lang clay clean cleanlang clear cleo cleogo cleopatra cli-assembly click clickpath clike clion-editor clipper clips clisp clist clix cloc cloe clojars-pm clojure clojurescript clos closure-templates cloud-firestore-security-rules clover clox clp-star clpr clu clx cmake cmix cmn cms-2 cms-exec cms-pipelines cmu-common-lisp co-dfns co2 cobloc cobol-net cobol cobolscript cobra coco-r coco cocoapods-pm coconut coda-editor code-blocks-editor codecept codeflow codegear-delphi codelite-editor codemirror codeql codil coff coffee-cinema-4d coffeepp coffeescript cogmap cogo coherence coherent-parallel-c coi-protocol cokescript col colascript colasl cold-k coldfusion-components coldfusion collada color-basic colorforth comal combined-log-format comby comfy comit comm commen commodore-basic common-lisp common-log-format common-workflow-language commonloops commonmark compact-application-solution-language compiler-compiler complex-prolog component-pascal computer-compiler computest comskee comsl comsol-script comtran cona conan-center-pm conan-pm conc concept-script conceptual concert-c concise-encoding concordance concur concurnas concurr concurrent-cpp concurrent-metatem concurrent-ml concurrent-pascal concurrent-prolog cone confluence congolog conlan conll-u conman connection-machine-lisp connection-machine conniver consim constraintlisp constraints consul context-diff contracts.coffee contrans converge convert cooc cool coordinate-format copas cope copilot coq cor coral-64 coral-lang coral coralpp corbascript corc corelscript corescript corman-common-lisp cornell-university-programming-language corvision cosh cosmicos cosmo cosmos cotton couchbase-mobile couchbase couchdb coulombs-equation cowsel cp cpan-pm cperl cpl cpp cql cqlf cqlpp crack cram-format cran-pm cranelift-ir crates-pm creative-basic crema creole crmsh croc croma crush cryptol crystal cs-script csa csharp csl csmp cson csound csp-oz-dc csp-oz csp cspydr css-doodle css cssa cst csv csvpp csvw ct ctalk-lang ctalk ctan-pm ctr cubase cube cuda cuecat cuelang culler-fried-system cullinet cuneiform cupid cupit-2 curl curly curry curv cuscus cusip cvl cweb cx cyber cybil cycl cyclone cycript cymbal cypher cyphertext cython cytosol d-data-language-specification d d2 d3 d4-programming-language d4 dad dafny dag daisy-systems dak dale dalvik-bytecode daml-oil daml damn daonode dap-algol dap-fortran daplex darcs-patch darkbasic darklang dart-pm dart dartcvl dartmouth-basic das dashrep dasl dasm dat-protocol data-access-language data-general-business-basic data-text databus dataflex datafun datalisp datalog datan datapackage datapoint-dasl datascript datatrieve dataweave datev datomic dax dbase dbml dc dcalgol dcat dda ddfcsv ddfql ddml de-bruijn-index-notation deacon deb debl debuma dec64 decision-model-notation declare dedukti deesel definite-clause-grammar-notation del delirium delphi delta-prolog dem demeter demos dendral deno dependent-ml dern descartes descript descriptran desktop desmos detab-65 detab-x detap deva device-independent-file-format devicetree devil dex dexterity dexvis dfl dfns dgraph dhall diagram dialog diamag diana dibol dice diet diff differential-datalog digital-command-language digraf dinkc dinnerbell dino dio dipe-r diplans disc dispel displayport-standard distributed-processes distributed-smalltalk ditran ditroff-ffortid ditroff dixy django djangoql djot dkim-standard dllup dlp dlvm dm-1 dm dmap dml dna dns docker dockerfile docopt doe-macsyma dog dogescript doh doi dojo dokuwiki dolittle dollar-sign dolphin domino doml doodle dopl dot-product-equation dot-ql dot dowl dpp dprl draco-programming-language draconian dragonbasic dragoon drakon dreamlisp dribble drl drol drupal dscript dsd dsl-90 dslx dss dsym dtd dtrace dts dual dub-pm duel duro durra dvi-standard dwg dxf dylan dynamo-pm dynamo-visual-language dynamo dystal dyvil e eagle earl-grey eas-e ease easl easy-english easy easybuild easylanguage easytrieve ebg ebnf ec ecl eclectic-csp eclipse-command-language eclipse-editor ecmascript eco-editor ecological-metadata-language ecr ecsharp ect ed-editor eden edge-side-includes edgedb edgelisp edgeql edh edina edinburgh-imp edinburgh-lcf edison edje-data-collection edn edsac-initial-orders edscript edsim educe-star educe eex eff efl egel egison egl egs4 eiffel ejs el1 elan elastic-query-dsl election-markup-language electre elegance elegant elena elf elfe elixir ella-programming-language ellie elliott-algol ellpack elm-packages-pm elm elmol elpa-pm elpi elvish elymas em emacs-editor emacs-lisp emberjs-framework emberscript emerald-lang emerald emesh emfatic emily emma emojicode emoticon empirical emu encore energese-notation energy-momentum-equation english-programming-language eno enso-lang enso enterprise-mashup-markup-language entropy envoy-app epigram epilog epsilon eql eqlog eqn eqs equate erb erg erlang errol esc-p escapade-programming-language eskew esoteric-reaction esp espol esterel eta etc ethereum-vm ethernet etoys etruscan-numerals etude euboea euclid euclidean-geometry euler eulers-equation eulisp eumel euphoria eurisko eva eve everparse3d ex-editor exapt excel-app exec-2 executable-json exel exfat exkited expect explan explor explorer express expresso ext ext2 ext3 ext4 extempore extended-ml extended-pascal extensible-embeddable-language extran ez ezhil f-prime f-script f-sharp f fable-lang fable fac facelets fact-lang fact factor fad falcon false family-basic fancy fantom fap far faradays-induction-equation farcaster fardlang fast-fourier-transform-equation fasta-format fastq-format fasttrack-scripting-host fat faust fawlty fay fcl fcpu fe feel felix femtolisp fen-notation fenix-project fennel ferite fern ferret fetlang feynman-diagram ffmpeg fhir fibonacci-notation fibonacci fickle figlet-font filebench-wml filetab-d filetab filterscript firebase firefox firrtl fish fishlang fizz fjolnir fjs fl flacc flagship flame-ir flang flapjax flare flatbuffers flatline flavors fleck flengpp flex-lang flex flexbuffers flexml flic flix floorplan flora floral floscript flow-matic flow flow9 flowchart-fun flowcode flowgorithm flowlog flownet flownote flua flutter-framework flux-lang flux fm-standard fmj fml-lang fml fo foaf focal focus foil foogol foral-lp foral forall forest-database forest-lang forgebox-pm fork-lang fork fork95 formac formality formatted-table forml forms-3 formula forte-4gl forth forthnet-pm forthscript fortran-77 fortran-8x fortran-90 fortran-cep fortran-d fortran-ii fortran-iii fortran-iv fortran-m fortran fortransit fortress fossil-scm foundry fox foxpro fp fp2 fp3 fpgac fpp fractran frame framework-office-suite fran frank-lang frank free-pascal freebasic freebsd freefem freemarker frege frenetic fresco frink frost frtime fructure-editor fsl fstar ftp fun function-block-diagram funl futhark futurebasic futurescript fuzuli fuzzyclips fx-87 fxml fxscript g-2 g-code g-expressions g-fu g-portugol gaea gaiman galaksija-basic galileo gambas game-maker-language game-oriented-assembly-lisp game gamemonkey-script gamerlanguage gaml gams gap gargoyle garp gas gasp-ii gasp gat gauche gauss-flux-equation gauss-magnetism-equation gaussfit gcc-machine-description gcc gcla-ii gcp gdata gdb gdl gdpl gdscript geany-editor gecko gedanken gedit-editor gel gellish gello gem gema gemini-protocol general-algebraic-modeling-system generate-ninja generic-haskell generic genero genexus genie genius-extension-language genshi-text genshi genstat gentee gentoo-ebuild gentran-90 gentran geo-ml geogebra geojson george gerald gerber-image gerbil germinal gettext gfa-basic gff-format gfoo gforth gfs ghc gherkin ghidra-decompiler ghostscript gif-format gimple gintonic giotto gist git-config git gitignore gks glbasic gleam glicol glide glish glitch-editor glms gloss glpk-lib glsl glu glue-nail gluon glush glyph-bitmap-distribution-format glyph gnome-basic gns gnu-e gnu-rtl gnuplot go-bang go goal goby godel godot-game-engine gofer gogs-editor gold golfscript golo golog google-apps-script google-cloud-mysql google-cloud google-data-studio-app google-sheets-app goose gopher-protocol goql gorillascript gospel gosu gp gpds gpgs gps gpss-360 gpss-85 gpss-fortran gpss gql graal grace grad-assistant gradle grain grammar grammatical-framework graph-it graph-modeling-language grapheasy graphics-basic graphlog graphml graphos graphql-plus-minus graphql-sdl graphql graqula grass gravity-equation gravity greek-numerals green greenplum gremlin gren grep grid-notation gridstudio-editor grin grml groff groove groovy-server-pages groovy grouplog grunt gsbl gsql gtf-format guide guido-music-notation guile guix gura guru gvl gw-basic gwion gwl gxl gypsy gzip h-lang habit hac hack hackage-pm hackett hackppl hacspec haggis hakaru hal-format hal-s halide ham hamdown haml hamler hancock handel-c handlebars hank harbour hare harlan harvey harwell-boeing-format hascript hashlink haskell-sharp haskell hasklig hasl haste haxe haxelibs-pm haystaq hazel hbasic hcard hccb hcl hdf hdfs hdmi-standard hdt heap.coffee hecl hedy heic helang helena helium hello helper henk heraklit herbrand hermes heron-lang heron hex-pm hex-rays hexagon hexagony hfs-plus hfs hhvm hi-visual high-tech-basic highlightjs hilbert hilltop-lang hilvl hina hiq hivemind hiveql hjson hl7 hla hlasm hlsl hlvm hmmm hmsl hobbes hocon hodor hol holcf holo holonforth holyc homa homebrew-pm homespring honu hook hoon hoot-smalltalk hop hope hopscotch horse64 hotcocoalisp hotdog hp-basic-for-openvms hp-gl hp-pascal hp-time-shared-basic hpp hprl hr-code hrqr hsaml-format hscript hsl hsml hspec htel html htmx http-2 http-3 http httplang huginn hugo hujson humanhash-hash-function hummingbird-quickscript hurl hush huwcode hxml hy hybrid hycom hypac hyper-basic hypercard hyperflow hyperfun hyperlisp hyperlog hyperscript-lang hyperscript hypertalk hyphy hytime hytran i-expressions i ia-32 ial iam ib-templog ibex ibm-1401-symbolic-programming-system ibm-basic ibm-basica ibm-db2 ibm-gml ibm-i-control-language ibm-logo ibm-rational-sqabasic ibm-rpg ibm-system-38-language ibuki-cl icalendar-format icarus icd icedcoffeescript ices-system icetran ici icml icon icot id idio idl-sl idl idris ids idyll ifo ifps igor-pro iif iikuse iitran ikarus ilbm ilu ilx imac-machine image imaginary-number-equation imandra imap-protocol imba imf imp-lang imp imp72 impala impl ina-jo inc inchi incipit indental infer infiniband-standard influxdb infolog inform information-algebra information-processing-language information-theory-equation informix infusion-framework ingres ini ink-lang ink inko inmagic inno-setup inquire inscan insight insitux instruction-list integer-basic integral-equation intellijidea-editor interactive interbase intercal intercellas interchange-file-format intercons interleaved-notation interlisp-vax interlisp interpress interscript intersystems-cache intuitionistic invokator io iode ioke ion-schema ion ios iota-and-jot iota ip-pascal ipad-machine ipf ipfs iphone-machine ipl-v iptables-rope iptscrae ipv4 iqf iqr irc-log ircis isabelle-91 isabelle-hol isabelle isac isbl isbn iscript isetl isis islisp iso-8601 ispl isq iswim it iterm2 itl ivtran ivy ixml izibasic j jacal jacl jade jai jakt jal-compiler jammy janet jank janus-lang janus-programming-language jargon jasmin jasmine jasper jass java-bytecode java-ee-version-history java-properties java-server-pages java javacc javafx-script javaml javascript javascriptcore jaws-scripting-language jayfor jazz jbc jcard jcl jcof jean jedit-editor jedlang jeebox jeeves jekyll jelly jesth jet-propulsion-laboratory-display-information-system jevko jflex jfugue ji jingo jinja jinx jis-x-0201 jison-lex jison jisp jiyu jlang jmap jmespath jmp jmsl joe-e join-java joker jolie jonprl josie joss-ii joss joule jovial joy joyce joycep jpeg-format jpl jplace jpp jq jql jquery jr jruby jscript jsf jsgf jsharp jsil-compiler jsl jslt jsml json-graph-format json-graph-spec json-lambda json-ld json-schema json-script json-stat json-url json-with-comments json json5 jsoniq jsonnet jsparagus jspp jsx jsyn judoscript juicy jule julia-lang julia juliahub-pm juniper juno jupyter-editor jupyter-notebook just juttle juvix jvm jython k-framework k kaffeine kaggle-app kai kail kaitai kakoune-editor kal kaleidoquery kaleidoscope kaleidoscope90 kaleidoscope91 kalyn kamby kami kamilalisp kaml karel karl kasaya kate-editor kate katex kaukatcr kavascript kawa-scheme-implementation kayia kb kee kefir kei kek-nodal keli keras kerf kermeta kernel-e kernel kew keykit keysight-vee khepri ki kicad kid kiev kilo-lisp kima king-kong kiss kit kitlang kitten kivy-lang kixtart kl-one kl0 kl1 klaim klerer-may-system klipa klisp klong kml knight knitr knowledge-interchange-format ko koara kodu-game-lab kogut koi koka komodo-editor kona konna konsolscript korn-shell kotlin kqml krc kris krl-0 krl krs krypton ktexteditor-editor kubernetes kuin kuka kumir kuroko kvikkalkul kvsapi kylix kyma l l2 l6 labtran labview ladder-logic lagoona lain lambcalc lambda-obliv lambda-prolog lambda-zero lambda lamderp lamdu-editor lamdu lamina lammps-format lanai language-for-class-description language-h language-server-protocol laning-and-zierler-system lap laravel-framework larceny larch laris larp lasp lass lasso latex latino latte-js latte laure lav-format lava lawvere lazarus-editor lazy-k lazyml lc-3 lcf lcl ld-json ldap ldl ldl1 ldpl le-lisp leaf lean leap leazy leda legol lem-editor lemick lemon leo-editor leogo leopard les lesk lesma less lever levy lex lexon lexx-editor lezer lfe lg lgdf li-chen-wang liberty-basic libra libsvm-format life lift lighttpd-configuration-file ligo lil-pl lil lila-lang lila lily lilypond limbo limdep linc-4gl lincoln-reckoner lincos linda linden-scripting-language linearml lingo lingua-graphica link linked-markdown linker-script links-programming-language links linktext linoleum linotte linq linux-kernel-module linux liquid liquidity lis lisaac liseb liso lisp-1-5 lisp-2 lisp-a lisp-machine-lisp lisp lispme lisptalk lispworks lispyscript listdown lite-c literate-agda literate-coffeescript literate-haskell litescript lithe little-b little-smalltalk little livecode livescript livr lkif llhd lll lllpg llvmir lmdb lnf lo lobster local loci locomotive-basic locs logal logica logicon login logist loglan loglisp loglo logo logol logos logowriter logres logscheme logtalk lol lola-2 lola lolcode lookml loom loomscript loopnpp loops lore lorel-1 lorel lotis lotos lotusscript lowstar lpc lpl lrltran lsd lse lsif-format lsl lua luajit luarocks-pm luau lucene-query-syntax lucid-chart-app lucid-lang lucid-representations lucid lucinda luna-1 luna lunar lush lustre lux lyapas lygon lynx lyric lyx-editor m-expressions m-lisp m-programming-language m2001 m3db m4 m4sugar mac macaims macbasic macbook-air-machine macchiato mace machiavelli macintosh-common-lisp macintosh-machine macro-10 macro-11 macro-spitbol macro macroml macsyma mad madcap-vi madcap mads mages magic-paper magik magit magma magma2 magritte mai-basic-four mai make makedoc makefile mako mal malbolge mallard-basic malus mama-software man-machine-language manchester-syntax mangle manhood manim manool manticore manuscript map mapbasic maple maplesoft-app-center-pm mapper mapquery maps maraca-lang margin maria-db-column-store maria-xml mariadb mark-iv markdeep markdown marklogic marko markovjunior markus markwhen marlais marmot marp marsyas marten mary-2 mary mascara masim maskjs masm mass-energy-equation material-exchange-format math-matic mathcad mathematica-editor mathematica-packagedata-pm mathematica mathics mathjax mathlab mathlingua mathml mathpix-markdown mathsy mathtype mathworks-file-exchange-pm matita matlab matplotlib matrix-pascal matrix-protocol maude maven-pm maven-pom mavis mavo mawk max maxima maxscript maya mbasic mbox mckeeman-form mcleyvier-command-language mcobol md5-hash-function mdbs-qrs mdl mdx-lang mdx meanscriptcli mech-lang mediawiki medic medusa megalog megaparsec meld melody melpha-pm memcached memex-machine mendel mentat mercurial mercury-programming-system mercury merd mermaid meroon mesa meson messagepack met-english meta-assembler meta-ii meta-lisp meta-plus metacomco metafont metah metal-programming-language metal metalang99 metalex metaml metapi metapost metasim metatem metaweb-query-language methodology-description-language mewl mewmew mgmt mheg-5 michelson micro-cpp micro-editor micro-flowcharts micro-mitten micro-prolog microarchitecture-description-language microdare microdata microl microplanner micropython microsoft-access microsoft-azure-cosmos-db microsoft-basic microsoft-equation-editor microsoft-macro-assembler microsoft-mysql-server microsoft-small-basic microtal midas miis mike mime mimic mimium mimix-stream-language min minc mini-ml minid minidsdb minihaskell minikanren minilang miniml-error miniml minion miniprolog minivital minizinc minopt mint mips mir mirager mirah miranda miranim mirc mirfac mirth miso-framework miva mizar ml mlab mlatu mlir mlisp2 mlite mlpolyr mmix mmsearch mmx mobl-lang mobl moby-programming-language mochajs mochi mockingbird-notation mocklisp modcap model-204 model-k modelica modl modlisp modsim-iii modula-2 modula-2p modula-3-star modula-3 modula-p modula-r modula modular-prolog module-management-system moescript moinmoin mojo molecular-query-language molfile-format molog monaco mond monesa mongodb monkey monodevelop-editor monte moo mool moonrock-basic-compiler moonscript moose morfa morfik morphe morphism morse-code mortran motif-software mountain mouse mouse4 moxie moya mp3-format mpgs mpl mps mpsx mql mqtt mrdb ms2 mscgen msg-84 msl msp430 msx-basic mtml mu muddl mudlle muf mufp mul-t multi-user-basic multiaddr multibase multicodec multics multigame multihash-hash-function mumath mumps mums mun-lang munin muon mupad murmur-hash-function mushroom music-sp musicxml musimp musp mustache musys mvel mvl mxml mybb mycroft myghty myia mypy myrddin mys mysql mythryl n-prolog n-triples n nadesiko nail nakl nano-editor napier88 napss narpl nasal nasm nassi-shneiderman-charts native-structured-storage nato-phonetic-alphabet natural navier-stokes-equation nawk ncar-command-language ncl ndl nearley neater nebula nectar neeilang neko neliac nelua nemerle neo4j neovim-editor neralie-format nesc nesl ness nested-context-language nestedtext net-format netbasic netbeans-editor netform netlib netlinx netlogo netrexx netscript network-control-language neuronc neut neutron never newclay newick-format newlisp newp newspeak newsqueak newton newtonscript nexml nextflow nexus-format nfql nginx-config ngl-programming-language ngql ngs nhx nial nianiolang nice nickle nikl nil nilscript nim nimble-pm nimrod nimskull ninja nios nirvana nit nix nixos njcl nl nlpl nltk nml noah nodal nodejs noisecraft nomad-software noms-db none noodle nop-2 nord normal-distribution-equation northstar-basic nosica notation3 note notepad-editor notepad-plus-plus-editor noulith nova-editor noweb np npl-lang npl npm-pm npy nqc nrl nroff ns-basic nsis nsl ntfs ntp nu-prolog nu nua-prolog nuget-pm nul-lang nulan numba numbers-app numerica numpad numpy nuprl nushell nut nuua nvdl nwscript nxc nxt-g nydp nylo nymph nyquist o-matrix o-xml o o2 o42a oak oaklisp oasis-operating-system oasis oberon-2 oberon obj obj2 objdump object-definition-language object-oberon object-pascal object-query-language object-rexx object-z objectcharts objective-c objective-cpp objective-j objective-modula-2 objective-s objectlogo objectpal objectscript objectworld objvlisp objvprolog obliq obscure observable-lang obsidian ocaml occam-2 occam-pi occam ocl octave octopus octune odata odbc oden odin odrl oem ofl oforth ofx ogdl ognl ohaskell ohayo ohm oil ok oldas ole-protocol olga oli oliver olog om omar omega ometa omg-idl omgrofl omikron-basic omnimark omnis-studio omnitab-80 omnitab-ii omnitab one-man-language onex oniguruma onnx onyx ooc ook oolp oopal oops oopsilon oopsp ooxml opa opal opam-pm open-nn open-shading-language openada opencl opencomal opendoc-protocol openedge-advanced-business-language openexr-format opengl opengraph openlisp openmusic openrc-runscript openroad openscad openspice opentype-feature-file openvera operational-control-language operon opl-langage-informatique opl opp ops-3 ops ops5 optimization-programming-language optimized-systems-software optimj oracle-java oracle orange orc-format orc-lang orca-lang orca-pl orca order oregano org orient-db orient84-k orlog osiris osl-2 osql ottawa-euclid otter owbasic owen-lang owl-dl owl ox oxide oxygene oxyl oz p-cl p-prolog p-star p-tac p p3l p4 p4p package-control-pm packagist-pm pacmanconf pacol pact-i pact-ia pact pactolus padl-1 pailisp paisley palasm palcode palingol pamela pan pancode pandas pandoc-app pandora panon-1 panon-1b panther-lang paperalgo papyrus par paragon parallax-propeller parallel-ellpack parallel-pascal paralog-e parasail parasolid parenscript parenthetic pari-gp parlog parmod parquet parrot-assembly parrot-basic parrot-internal-representation parrot-vm parse-tree-notation parser partiql pascal-abc.net pascal-fc pascal-i pascal-mtp pascal-plus pascal-s pascal-sc pascal-script pascal-xsc pascal pascals-calculator-machine pasion pasro passambler passerine pasukon patch patchwork path-pascal pawn-scripting-language pawn paxscript pbasic pbm-format pbt-omega pclos pcn pcol pcpp pcrap pcre pdel pdf pdl-ada pdl pdp-11-machine pear-pm pearl pearscript pearson-correlation-coefficient-equation pebble peg pegasus-autocode pegjs pei penguor penrose peoplecode pep pep8 perfectscript peridot perl-6 perl-data-language perl petr pfort pfortran pgbouncer pgen pgm-format pgolog pgql pharen pharo phel phigs phocus phoenix-object-basic phorth php phpstorm-editor phylip phyloxml-format physictran pi-calculus pic-microcontroller pic picasso picat piccola pick-operating-system pickcode pickle-format pico picolisp pict pictol picturebalm pie-lang pie piet-programming-language pig pikachu pike pikelet pikt pilib pilot pin pinto pipelines pisc pit pixin pizza pkgconfig pl-0 pl-11 pl-as pl-c pl-exus pl-i-formac pl-i-subset-g pl-i pl-ll pl-m pl-p pl-s-ii pl-s pl-sql pl-x pl360 pl4 placa plaid-programming-language plain-english plain plam plan2d planguage planit plankalkul planner-73 planner plantuml plasma playground plb please-build please plex plexil pliant plink-bed-format plink-bim-format plink-fam-format plink-map-format plink-ped-format plist plot-lang plot plpgsql pluk plum plumb plunk plus plush plz pm2 pml png-format pnuts po pocket-smalltalk pod pod6 pogol pogoscript pointless polac polly poly polyglot-compiler polylith polymath polymorphic-programming-language polyp polytoil pomsky pony pop-11 pop-2 pop-pl pop-protocol popasm popcorn-linux poplog popr popsy port-alg portable-standard-lisp portal-langage pose post-canonical-system post-x postcss postgresql postscript potential potion pov-ray-sdl power-bi-app power-query-m powerbasic powerbuilder powerhouse-programming-language powerisa powerlanguage powerloom-knowledgebase powerpc powershell-gallery-pm powershell ppm-format pqq praat-script praxis-lang praxis preferred-executable-format preforth presto price-equation principle-of-sufficient-reason prism prisma-schema-language prismjs priz pro-star-c probevue proc-procedure-language processing processor-technology procfile procol prodel profit progol prograph progres progsbase proiv project-mentat prolog-d-linda prolog-elf prolog-iii prolog-kr prolog-linda prolog-pack-pm prolog prologpp promal promela prometheus prompter promql property-specification-language prophet proplan proset prosper protel proteus-programming-language protium proto-gnosis protobuf protos-l protosynthex proverif-lang providex prow proxy prql ps-algol psather pseint psg psi psl psyche-c psyche psyco pt ptx public-key-file pufft pug pumpkin punched-tape punycode puppet pure purebasic puredata purescript pursuit-pm push pv-wave pvs py pycharm-editor pycket pygmalion pygments pyke pypi-pm pyret-lang pyret pyrex pyth pythagorean-equation python-cl-compiler python-for-s60 python-format-spec python pytorch q-equational-programming-language q-gert q-sharp q qa4 qalb qas qb64 qbasic qbe qcl qed-editor qed-lang qfx qif qlisp qmake qml qoir qore qr-code qt qtscript quadril quaint-lang quaint quake quakec quanta quel query-by-example quexal quick-macros quickbasic quicklisp-pm quicksight-app quikscript quiktran quilt qunity quorum qute quty r r2ml r3 r4 ra rack racket raco-pm radish ragel rails rainbow raku ralph ramdascript ramen ramis-software raml rand-abel rant rapid rapidbatch rapidgen-rpl rapidq rapidwrite rapira raptor raptorjit rascal rascalmpl rason rasp ratfiv ratfor ratsno ravenscar-profile razor rbasic rbs rbscript rc rcpp rdata-format rdf-schema rdf rdfa rdml rdoc rds-format react-native readable-lisp readable real-time-cmix real-time-concurrent-c real-time-euclid real-time-mentat realbasic reason rebeca-modeling-language rebol rebus rec-sm rec-studio recfiles recol red-lang red redcode redis redpanda-app redprl redscript redshift reduce ref-arf refal refer refined-c reflex-framework reflisp reforth regent regex regina regulus reia reko-decompiler rel-english rel-lang rel relational-data-file relational-production-language relationlog relax relaxng relfun relix remix ren-c ren-notation renderman-shading-language renderscript renpy report-writer-language rescript resharper-editor rest restructuredtext retdec retroforth reuse-description-language reverse-polish-notation revit-app revolution-programming-language rexon rexx rf-maple rfc rgb-format rhet rhine rholang rhoscript rhtml ricscript rider-editor riff rigal rigc ring rio ripple risc-v rise rita rlab rlisp rlmeta rlox rmarkdown robic robomind robot-battle robotalk robotc robotframework robots.txt roc rocket rockstar-rkt rockstar rocky-mountain-basic roff roku-brightscript rol rol2 roman-abacus-machine roman-numerals ron roop root-format root-lib ros-msg roscoe rosetta-2 rosetta-smalltalk rosette-lang rosette rosie roslyn-compiler rouge roy royalscript rpg-ii rpg-iii rpl-lang rpl rpm-package-manager rpm-spec rpp rpscript rpython rql rsharp rsl rss rstudio-editor rt-aslan rt-cdl rt-z rtf rtl-2 rtp-protocol ru ruby-document-format ruby-mine-editor ruby rubygems-pm ruleml run-basic runcible runescript runic runiq runoff runrev ruri russell rust-hir rust-mir rust rustscript ruth rye s-algol s-expressions s-lang s-plus s-sl s-snobol s s2 s3 sa-c-programming-language sa saal sac-1 sac-2 sac-programming-language safari sagemath sako sale salem salsa saltstack sam-coupe sam-format sam76 saml sampletalk saol sap-hana sapphire sarl sartex sas sasl-programming-language sass sassy sather-k sather satysfi saustall savi sawzall sb-one sba sbasic sbcl sbml sbol scala-js scala scalpel scaml scan scat scenic schemal schemaorg schematron scheme-2-d scheme school schoonschip schrodingers-equation scieneer-common-lisp scikit-learn scil-vp scilab scipy scl sclipting scm scoop-pm scoop scopes score scrapscript scratch scratchpad-ii scratchpad screamer scribble scribe scrimshaw script scriptbasic scriptease scriptol scriptx scroll-lang scroll scsh scss sdf-format sdf sdl sdlbasic sdms sdtm search sectorc secure-operations-language sed seed7 segras self semanol semi-thue-system semicolon semver send-standard sensetalk sentient seph-programming-language sepi seq seque sequel-2 sequencel sequential-function-chart sequential-pascal serious service-modeling-language sespath sespool set-builder-notation setl setlog setlx setun seval seymour sgml sh sha-1-hash-function sha-2-hash-function sha-3-hash-function shacl shadama shade shaderlab shadow shakespeare-programming-language shakti sham shapefile shapeup shared-prolog sharpscript sheep-lang sheep sheerpower4gl shen shex shift shill shiv shml shoe short-code-computer-language shrdlu si-library si sibelius-software sibilant sidopsp sierra sieve sigma-76 signal sil sile silk sill siman-iv siman simcal simcode simdis simfactory simit simkin-programming-language siml-i simnet simodula simons-basic simpas simpl simple-binary-encoding simple-stackless-lisp simple simplescript simplictiy simpp simscript simul simula-67 simula simulink sina sinclair-basic sing-sharp singular siphash-hash-function siprol siri sisal sisc sitemap sixten sizzle sk8 sketchpad-iii sketchpad skew skil skip skookumscript skulpt sky sl sl5 slam-ii slang slash sleuth slice slick slideshow slim-framework slim-pl slim slip slips slog slony slope slpl smalgol smali small-c small-euclid small-x small smallbasic smalltalk-76 smalltalk-80 smalltalk-mt smalltalk-v smalltalk-yx smalltalk smalltalkhub-pm smallvdm smart smartgameformat smarts smartsheet-app smarty smdl smile smiles-format smithy smoke smolcs smpl smsl smt smtp smx-computer-language snakemake snap snaptag snbt snit snobat snobol snobol3 snobol4 snoop snostorm snowball-programming-language snowman-decompiler snql soap soaplang soar-ml social-networks-query-language socialite solaris-pm solaris solid solidity solmar son sophia soql-lang soql sora sorca sort-merge-generator sosl souffle soul soulver souper sourcelair-editor sourcepawn sourcetree southampton-basic-system sox soy sp-k space sparc spark-pl spark-pm spark sparqcode sparql spatial speakeasy spec-sharp spec specl specol specrtl speedcoding speedie spf-standard spice-lisp spice spider spiderbasic spidermonkey spil spill spin spip spir-v spir spiral spitbol spl splaw spline-font-database split-c sporth sprint sprite-os spry sps spss spyder-editor sqhtml sql-92 sql-psm sql sqlalchemy sqlar-format sqlite-storage-format sqlite sqlmp sqlpl sqr sqrl square squeak squidconf squiggle squire squirrel squoze squrl sr-programming-language sr srecode-template srl srv ssb ssc-pm ssharp ssi ssl-lang ssl ssml stacklang stackless-python stage2 stalin stan standard-lisp standard-ml staple star-prolog star starlark starlogo staroffice-basic starpial stata statebox statemate static-typescript statsplorer status-quo-function status-quo-script steinhaus-moser-notation stella stencil stl stockholm-format stoical ston stonecutter stoneknifeforth storymatic storyscript stos-basic strand-programming-language strat stratego strcmacs streamit streem strema stress string-diagrams-notation stringbean stringcomp stripe strips strongtalk structured-storage structured-text strudel strudl struql stutter-lang stx stylus sub subl subleq sublime-editor sublime-syntax-test sublime-syntax subrip-text subscript subtext subversion subx sue sugar sugarj sugarss sugartex sugi summer sun-raster-format suneido superbasic supercollider superforth superjson supermac superplan supertalk superxpp surge svelte svg svgbob svl sw2 swagger swallow sweave sweet-expressions sweetjs swi-prolog swift-il swift swizzle swrl swym sybyl-notation symbal symbmath symbol symbolic-assembly sympl sympy synapse synchronized-multimedia-integration-language syndicate synergist synglish synon synproc syntex syntol sysml system-v-abi systemverilog systemz t-lang t t2b t3x tab tablam tablatal tableau-app tablog tabloid tabsol tabtran tac tacl tacpol-programming-language tactics tads taf tahoe-lafs taichi taijilang taktentus tal tale tall tamgu tampio tangledown tao-lang tao tao3d tap-code tap taql tarmac tarot tasm tawa taxa taxis tbox-lib tcc tcl tcoz tcp tcsh tcsp tdfl tdms tea-pl tea-pm tea teal teasharp teco tefkat tektronix tela telcomp telefile-assembly telnet-protocol telos telsim templar template-attribute-language tempo temporal-prolog ten tengo tensorflow teradata-aster teradata tern ternary-notation terra terse tetra tetruss-app tex texpr text-executive-programming-language textadept-editor textframe texti textile textmate-editor texy tfl the-message-system theos-multi-user-basic thinbasic thinglab think-c thorn threaded-lists thrift tht thue-programming-language thune thymeleaf ti-89-basic ti-basic-assembly ti-basic tibbo-basic tibet tick-c tics tidb tiddler tiddlywiki tidyverse tiff-format tiger-basic tikiwiki tiledb tilton timber-programming-language timed-csp timpani tinkertoy tiny-basic tinyc-compiler tinygo-compiler tiscript titan titanium tl-isa tl tla tlc tldr tls tmg tmlanguage tmtp toadskin todotxt toffeescript toi toki-sona tom-oopl tom tomal toml toolbus toontalk topaz-lang topaz topshell torchscript tornado tosh touch touchdevelop toy-lang tpdl-star tql trac trace trafola-h traits tramp tranquil transact-sql transaction-language-1 transcode transforma translang tree-annotation-operator treelang treenotation treesheets treet trellis tremor-query trex tridash trig-syntax trio triple triroff triton troff tromp-diagrams trs-80-color-computer truck true-basic truth ts tsar tscript tsl tsql2 tsquery tsv ttcn ttm ttsneo tuple-space tuplemarkup turbo-assembler turbo-basic-xl turbo-basic turbo-pascal turing-plus turing turnstile-plus turnstile turtle tutor tutorial-d twelf twig twiki two-d twoducks txl txr txt2tags txtzyme tyco tymshare-superbasic tynker type-language typecastjs typecobol typedefs typescript typographical-number-theory typoscript typst tyruba u-datalog u uan ubasic ubercode uberscript ubik ubjson uc ucg ucl ucsd-pascal udp ufl ufo ugbasic ugnis uiml uiua ujml ulisp ultralisp-pm umka uml uml2-sp umple umta uncol underlay unicode-lang unicode unicon-adl unicon unicorn uniface unified-diff unified-parallel-c unisim unison unity-engine unity unity3d-asset universe unix unlambda unlws uno unql-lang unql unravel unrealscript unseemly up-arrow-notation upic urbiscript url urn urweb usb-standard uscript uscript2 usd ussa utc-format utf-8 utopia-84 uxf v-golf v-promela v-visual-language v v8 v8torque val-ii val vala vale-assembly vale varlist vba vbscript vcard vcf-format vcl vcpkg-pm vdm-sl vdscript vector-pascal vega-editor-app velato vely venus verifpal verilog verona verse versioned-text-markup-language verve vex vga-standard vhdl-ams vhdl vi-editor video vienna-definition-language vienna-fortran vigil vilnius-basic vim-editor vim-script vim-scripts-pm vimwiki violent-es viptran virgil viron virt visavis visdown vissim visual-basic.net visual-basic visual-dataflex visual-dialogscript visual-eiffel visual-foxpro visual-logic visual-objects visual-occam visual-paradigm-app visual-prolog visual-smalltalk-enterprise visual-studio-code-editor visual-studio-editor visual-studio-marketplace-pm visual-test visual visualworks viva vivaldi viz vlibtemplate vml volt vortex voxml vpl vrml vspl vsxu vtl-lang vtl vtml vuejs vulcan vvvv vyper vyxal w wah walt wart wasm wasmer wasp-lang wast watbol watcom water watfiv watfor wats wavefront-material wavefront-object wcl wcps wddx wdf wdl web-idl webdna webgl webkit webl webp-format webql webstorm-editor weebasic wescheme wgsl whack whalecalf whiley whirl whirlwind whitespace whois-protocol wikitax winbatch windev windows-registry-entries wing winwrap-basic winxed wireless-markup-language wirth-syntax-notation wisp wiswesser-line-notation wizml wizor wlambda wlanguage wml wmlscript woe wol wolfram wolontis-bell-interpreter wonkey woofjs wordpress work-flow-language workfl world-of-warcraft-addon-data world worst wren writeacourse wsdl wsfn-programming-language wu wxbasic wylbur wyvern x-basic x-bitmap-format x-bitmap x-font-directory-index x-it x-klaim x-pixmap x10 x11-basic x86-64-isa x86-assembly x86-isa xadl xaml xbase xbasepp xbasic xbel xbl xblite xbrl xc xcard xcas xcompose xcore xcy xdr xduce xe xetex xgboost-model xgboost xgmml xhtml xidoc xl-lang xl xlwings-editor xmi xmind xml-gl xml-ql xml-query-algebra xml xmpp-protocol xmtc xoc-compiler xodio xojo xotcl xpages xpath xpl xpl0 xpm-format xpop xproc xprofan xql-lang xql xquery xs-lang xs xsd xsharp xsim xslt xsv-app xt3d xtao xtclang xtend xtext xtran xuml xupdate xxl y-lang y yabasic yacas yacc yakou-lang yaml yamp yang yap-prolog yara yarv yasl yasnippet yawl ycp yedalog yess yeti yii yinyang yoga yoix yoptascript yorick yugabytedb yum-pm z-expressions z-flat z-machine z-notation z-shell z z2 z80 zbasic zccs zed zeek zeno zenscript zephir zephyr-asdl zeta zgrass zig zigzag zil zim-format zimbu zimpl zip-format zish zl zlang zoem zolang zone zonnon zope zopl zot zpl zpp zuo zz
urlCell
 highlightScope constant.language
 regex (ftp|https?)://.+
externalGuidCell
 description A GUID from another site.
fileNameCell
 highlightScope string
abstractTrueBaseColumnParser
 cells columnNameCell
 string typeForCsvDocs unspecified
 cruxFromId
 boolean isColumn true
 single
 javascript
  get columnValue() {
   return this.content
  }
  get columnName() {
   return this.definition.cruxPathAsColumnName
  }
abstractUrlColumnParser
 string typeForCsvDocs url
 cells columnNameCell urlCell
 extends abstractTrueBaseColumnParser
annualReportsUrlParser
 extends abstractUrlColumnParser
 description What is a URL to annual reports for this language?
 single false
abstractUrlGuidColumnParser
 description A column containing a URL that is also a Globablly Unique Identifier (GUID) for an entity on that site.
 extends abstractUrlColumnParser
antlrParser
 extends abstractUrlGuidColumnParser
 description What is a URL to an ANTLR grammar for this language?
 // A good collection of ANTLR grammars: https://github.com/antlr/grammars-v4/tree/master/LANGUAGE)
 string sourceDomain www.antlr.org
hoplParser
 extends abstractUrlGuidColumnParser
 description What is the URL to this language in Diarmuid Pigott's Online Historical Encyclopaedia of Programming Languages site?
 string sourceDomain hopl.info
jupyterKernelParser
 extends abstractUrlGuidColumnParser
 single false
 description What is a link to a Jupyter Kernel for this language?
 string sourceDomain jupyter.org
meetupParser
 description What is a URL for active meetup groups for this language on Meetup.com?
 extends abstractUrlGuidColumnParser
 contentKey url
 string sourceDomain meetup.com
 memberCountParser
  description How many people in this meetup group?
  extends abstractPopulationCountColumnParser
 groupCountParser
  description How many groups?
  extends abstractCountColumnParser
subredditParser
 extends abstractUrlGuidColumnParser
 string sourceDomain reddit.com
 contentKey url
 single false
 description What is a URL of a subreddit(s) for this language?
 example
  subreddit php
 memberCountParser
  extends abstractAnnualPopulationCountMapParser
  description How many members in this subreddit?
replitParser
 extends abstractUrlGuidColumnParser
 description What is a URL to try this language on replit.com?
 string sourceDomain replit.com
rosettaCodeParser
 extends abstractUrlGuidColumnParser
 description What is a URL to this language on Rosetta Code - http://www.rosettacode.org/?
 string sourceDomain rosettacode.org
twitterParser
 extends abstractUrlGuidColumnParser
 description What is a URL to the official Twitter account of this thing, if any?
 string sourceDomain twitter.com
 followersParser
  description How many followers does the linked account have?
  extends abstractPopulationCountColumnParser
abstractChatUrlColumnParser
 description What is a URL to a chat room about the language?
 extends abstractUrlColumnParser
 // todo remove the need for the below from grammar
 string sortKey abstractChatUrlColumnParser
discordParser
 extends abstractChatUrlColumnParser
 description What is a URL to an official (or popular unofficial) Discord for this language?
discourseParser
 extends abstractChatUrlColumnParser
 description What is a URL to an official (or popular unofficial) Discourse for this language?
ircParser
 extends abstractChatUrlColumnParser
 description What is a link to an official (or popular unofficial) IRC channel(s) for language development?
zulipParser
 extends abstractChatUrlColumnParser
 description What is a URL to an official (or popular unofficial) Zulip for language development?
cheatSheetUrlParser
 extends abstractUrlColumnParser
 single false
 description What is a URL to a cheat sheet for this language?
conferenceParser
 description What is a URL to a recurring conference(s) focused on this language?
 catchAllCellType conferenceNameCell
 extends abstractUrlColumnParser
 single false
demoVideoParser
 description What is a URL of a demo video of this language?
 extends abstractUrlColumnParser
 single false
documentationParser
 extends abstractUrlColumnParser
 description What is a URL to the official documentation for this language?
 single false
devDocumentationParser
 extends abstractUrlColumnParser
 description What is a URL to the official documentation for developers who want to contribute to the language project?
 single false
downloadPageUrlParser
 extends abstractUrlColumnParser
 description What is a URL to the download page for this language?
 single false
ebookParser
 extends abstractUrlColumnParser
 description What is a link to a free public domain high quality eBook about this language?
emailListParser
 extends abstractUrlColumnParser
 description What is a link to the mailing list for this language?
 single false
esolangParser
 extends abstractUrlColumnParser
 description What is a URL to this language on https://esolangs.org/?
 string sourceDomain esolangs.org
eventsPageUrlParser
 extends abstractUrlColumnParser
 description What is a URL to an events pages for this language?
 single false
faqPageUrlParser
 extends abstractUrlColumnParser
 description What is a URL to a frequently asked questions page for this language?
 single false
abstractGitRepoUrlColumnParser
 extends abstractUrlColumnParser
 // todo remove the need for the below from grammar
 string sortKey abstractGitRepoUrlColumnParser
gitRepoParser
 description What is the URL of the official git repo for the language project if not hosted on GitHub or GitLab or Sourcehut?
 extends abstractGitRepoUrlColumnParser
githubRepoParser
 description What is the URL of the official GitHub repo for the project if it is hosted there?
 extends abstractGitRepoUrlColumnParser
 cells columnNameCell githubRepoUrlCell
 inScope descriptionParser
 contentKey url
 string sourceDomain github.com
 createdParser
  extends abstractYearColumnParser
  description When was the *Github repo* for this entity created?
 updatedParser
  extends abstractYearColumnParser
  description What year was the last commit made?
 firstCommitParser
  extends abstractYearColumnParser
  description What year the first commit made in this git repo?
 subscribersParser
  extends abstractCountColumnParser
  description How many subscribers to the repo?
 forksParser
  extends abstractCountColumnParser
  description How many forks of the repo?
 starsParser
  extends abstractCountColumnParser
  description How many stars of the repo?
 issuesParser
  extends abstractCountColumnParser
  description How many isses on the repo?
gitlabRepoParser
 description What is the URL of the official GitLab repo for the language project?
 extends abstractGitRepoUrlColumnParser
 string sourceDomain gitlab.com
sourcehutRepoParser
 description What is the URL of the official sourcehut repo for this project?
 extends abstractGitRepoUrlColumnParser
 string sourceDomain sr.ht
gourceParser
 description What is a URL to a Gource visualization of this project's git history?
 extends abstractUrlColumnParser
 string sourceDomain gource.io
firstAnnouncementParser
 description What is a URL announcing the creation or release of this language?
 extends abstractUrlColumnParser
screenshotParser
 description What is a URL to a screenshot of this visual language in the form https://pldb.com/screenshots/[id].png?
 extends abstractUrlColumnParser
photoParser
 description What is a URL to a screenshot of this real world notation in the form https://pldb.com/photos/[id].png?
 extends abstractUrlColumnParser
languageServerProtocolProjectParser
 extends abstractUrlColumnParser
 inScope writtenInParser
 single false
 description What is the URL to a project implementing LSP for this language?
 string sourceDomain langserver.org
linguistGrammarRepoParser
 description What is the URL to the Linguist Grammar repo used by GitHub for this language?
 // Linguist is a library used by GitHub to syntax highlight files on GitHub via a grammar. The list of languages supported by Linguist and the grammar package used for each language is listed here: https://github.com/github/linguist/blob/master/vendor/README.md. If Linguist has support for a language, it will have a repo on GitHub. Given a language is supported by Linguist, that is a good indication it has at least 200 unique :user/:repo repositories, according to their docs.
 extends abstractUrlColumnParser
 cells columnNameCell urlCell
 contentKey url
 string sourceDomain github.com
 inScope exampleParser
 commitCountParser
  description How many commits in this repo?
  extends abstractCountColumnParser
 firstCommitParser
  description What year was the first commit made?
  extends abstractYearColumnParser
 lastCommitParser
  description What year was the last commit made?
  extends abstractYearColumnParser
 sampleCountParser
  description How many language samples in this repo?
  extends abstractCountColumnParser
 committerCountParser
  description How many people have made commits in this repo?
  extends abstractPopulationCountColumnParser
officialBlogUrlParser
 extends abstractUrlColumnParser
 description What is the URL to the official blog for this language?
 single false
packageRepositoryParser
 extends abstractUrlColumnParser
 description What is a URL to the package repository for this language?
 single false
proposalsParser
 extends abstractUrlColumnParser
 description What is the URL to a the place where language proposals are made, if one exists?
redditDiscussionParser
 description What is a link to a related discussion on reddit?
 extends abstractUrlColumnParser
 string sourceDomain reddit.com
 single false
referenceParser
 extends abstractUrlColumnParser
 description What is a URL to more info about this thing?
 // You can add raw links and then auto "upgrade" them using some of the importer code.
 single false
releaseNotesUrlParser
 extends abstractUrlColumnParser
 description What is the URL to the release notes or changelog for this language?
rijuReplParser
 extends abstractUrlColumnParser
 description What is a URL to try this language on riju.codes?
 string sourceDomain riju.codes
 contentKey id
 inScope fileExtensionsParser descriptionParser websiteParser gitRepoParser exampleParser
roadmapParser
 extends abstractUrlColumnParser
 description What is the URL to a public roadmap page for this language, if one exists?
specParser
 extends abstractUrlColumnParser
 description What is a URL to the official spec for this language?
websiteParser
 description What is the URL of the official homepage for this language project?
 extends abstractUrlColumnParser
webReplParser
 extends abstractUrlColumnParser
 description What is a URL for an online repl of this language?
 single false
wikipediaParser
 inScope fileExtensionsParser exampleParser
 extends abstractUrlColumnParser
 description What is the URL of this entity on Wikipedia, if and only if it has a page dedicated to it?
 cells columnNameCell urlCell
 string sourceDomain wikipedia.org
 contentKey url
 relatedParser
  description What languages does Wikipedia have as related?
  extends abstractTrueBaseLinksColumnParser
 summaryParser
  description What is the text summary of the language from the Wikipedia page?
  extends abstractStringColumnParser
 createdParser
  extends abstractYearColumnParser
  description When was the *Wikipedia page* for this entity created?
 appearedParser
  extends abstractYearColumnParser
  description When does Wikipedia claim this entity first appeared?
 dailyPageViewsParser
  extends abstractCountColumnParser
  description How many page views per day does this Wikipedia page get? Useful as a signal for rankings. Available via WP api.
 backlinksCountParser
  extends abstractCountColumnParser
  description How many pages on WP link to this page?
 revisionCountParser
  extends abstractCountColumnParser
  description How many revisions does this page have?
 pageIdParser
  extends abstractIntColumnParser
  description What is the internal ID for this entity on WP?
abstractBooleanColumnParser
 string typeForCsvDocs boolean
 cells columnNameCell boolCell
 extends abstractTrueBaseColumnParser
abstractFeatureParser
 extends abstractBooleanColumnParser
 contentKey value
 childrenKey example
 catchAllParser featureExampleCodeParser
 string sortKey abstractFeatureParser
canDoShebangParser
 extends abstractFeatureParser
 description Does this language support shebang executable scripts?
 string title Shebang
 string pseudoExample #! /run
 string reference https://en.wikipedia.org/wiki/Shebang_(Unix)
canReadCommandLineArgsParser
 description Does this language support command line arguments?
 extends abstractFeatureParser
canUseQuestionMarksAsPartOfIdentifierParser
 description Is the question mark (?) allowed as part of an identifier?
 extends abstractFeatureParser
canWriteToDiskParser
 extends abstractFeatureParser
 description Does this language have methods or standard libraries for writing to disk?
 string title Disk Output
 string pseudoExample write("pldb.csv", "...")
hasAbstractTypesParser
 extends abstractFeatureParser
 description Does this language have a keyword for abstract classes or types?
 string title Abstract Types
 string pseudoExample abstract class PLDBFile {}
 string reference https://en.wikipedia.org/wiki/Abstract_type
hasAccessModifiersParser
 extends abstractFeatureParser
 string title Access Modifiers
 description Does this language have access modifiers?
 string pseudoExample class PLDBFile { public title }
 string reference https://en.wikipedia.org/wiki/Access_modifiers
hasAlgebraicTypesParser
 extends abstractFeatureParser
 string title Algebraic Data Type
 description Does this language support algebraic types?
 string pseudoExample garageContents = empty | vehicle
 string reference https://en.wikipedia.org/wiki/Algebraic_data_type
hasAnonymousFunctionsParser
 extends abstractFeatureParser
 string title Anonymous Functions
 description Does the language support anonymous functions, aka Lambdas?
 string aka Lambdas
 string pseudoExample () => printPldb()
 string reference https://en.wikipedia.org/wiki/Anonymous_function
hasArraySlicingSyntaxParser
 extends abstractFeatureParser
 description Does the language have array slicing syntax, such as [0:2]?
hasAssertStatementsParser
 extends abstractFeatureParser
 description Does the language have built in assert statements?
 string title Assert Statements
 string reference https://en.wikipedia.org/wiki/Debug_code#Assert_Statements
 string pseudoExample assert(isTrue)
hasAssignmentParser
 extends abstractFeatureParser
 description Does the language allow assigning values to variables?
 string title Assignment
 string pseudoExample name = "PLDB"
 string tokenKeyword assignmentToken
 string reference https://en.wikipedia.org/wiki/Assignment_(computer_science)
hasAsyncAwaitParser
 extends abstractFeatureParser
 description Does the language have an async/await construct?
 string title Async Await
 string pseudoExample async downloadPldb => await getFiles()
 string reference https://en.wikipedia.org/wiki/Async/await
hasBinaryNumbersParser
 extends abstractFeatureParser
 description Does the language have a type and syntax for binary numbers?
 string title Binary Literals
 string pseudoExample 0b100110100000110011110010010
 string reference https://en.wikipedia.org/wiki/Binary_number
hasBinaryOperatorsParser
 extends abstractFeatureParser
 description Does the language have operators for operating on binary types?
 string title Binary Operators
 string pseudoExample 1 + 1
 string reference https://en.wikipedia.org/wiki/Binary_operation
hasBitWiseOperatorsParser
 extends abstractFeatureParser
 string title Bitwise Operators
 description Does the language have operators for bitwise manipulations?
 string reference https://en.wikipedia.org/wiki/Bitwise_operations_in_C https://en.wikipedia.org/wiki/Bitwise_operation
 string pseudoExample 3 == (2 | 1)
hasBlobsParser
 description Does the language have a blobs concept?
 extends abstractFeatureParser
hasBooleansParser
 extends abstractFeatureParser
 description Does the language have a type and syntax for booleans?
 string title Booleans
 string pseudoExample pldb = true
 string tokenKeyword booleanTokens
 string reference https://en.wikipedia.org/wiki/Boolean_data_type
hasBoundedCheckedArraysParser
 description Are array boundaries checked by the language?
 extends abstractFeatureParser
hasBreakParser
 description Does the language have a keyword for breaking out of a loop?
 extends abstractFeatureParser
hasBuiltInRegexParser
 description Does the language include/import a regular expression language?
 extends abstractFeatureParser
hasCaseInsensitiveIdentifiersParser
 extends abstractFeatureParser
 description Are identifiers in this language case insensitive?
 string title Case Insensitive Identifiers
 string reference https://rosettacode.org/wiki/Case-sensitivity_of_identifiers
 string pseudoExample pLdB = "PLDB"
hasCharactersParser
 extends abstractFeatureParser
 description Does this language have a syntax and type for a "character"?
 string title Characters
 string pseudoExample char character = 'P';
 string reference https://en.wikipedia.org/wiki/Character_(computing)
hasClassesParser
 extends abstractFeatureParser
 description Does the language have a concept of classes?
 string title Classes
 string pseudoExample class PLDBFile {}
 string reference https://en.wikipedia.org/wiki/Class_(computer_programming)
hasClobsParser
 extends abstractFeatureParser
 description Does the language have a specific type for character large object?
 string title Clobs
 string aka Character large objects
 string pseudoExample class PLDBFile {}
 string reference https://en.wikipedia.org/wiki/Character_large_object
hasCommentsParser
 extends abstractFeatureParser
 description Does the language have a syntax and support for comments?
 string title Comments
 string reference https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(syntax)#Comments https://en.wikipedia.org/wiki/Comment_(computer_programming)
 string pseudoExample # Hello PLDB
hasConditionalsParser
 extends abstractFeatureParser
 description Does the language have conditional statements and/or conditional expressions?
 string title Conditionals
 string pseudoExample if (isTrue) printPldb()
 string reference https://en.wikipedia.org/wiki/Conditional_(computer_programming)
hasConstantsParser
 extends abstractFeatureParser
 description Does the language have a way to declare constant compile time variables?
 string title Constants
 string pseudoExample const name = "PLDB"
 string reference https://en.wikipedia.org/wiki/Const_(computer_programming)
hasConstructorsParser
 extends abstractFeatureParser
 description Does the language have a syntax and/or notion of constructors?
 string title Constructors
 string pseudoExample PLDBFile { constructor() {} }
 string reference https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)
hasContinueParser
 description Does the language have a syntax/keyword for continuing a loop?
 extends abstractFeatureParser
hasDecimalsParser
 description Does the language have a decimal data type?
 extends abstractFeatureParser
 string title Decimals
 string pseudoExample 0.80766866
 string reference https://en.wikipedia.org/wiki/Decimal_data_type
hasDefaultParametersParser
 extends abstractFeatureParser
 description Does the language have a way to define default parameters for functions?
 string title Default Parameters Pattern
 string reference https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters
 string pseudoExample say(message = "Hello PLDB")
hasDependentTypesParser
 extends abstractFeatureParser
 description Does a language have types who's definition depends on its value or the value of other types?
 string title Dependent types
 string pseudoExample pldbSortedList // a list where is sorted is true
 string reference https://en.wikipedia.org/wiki/Dependent_type
hasDestructuringParser
 extends abstractFeatureParser
 description Does the language have a syntax for conveniently extracting multiple values from a structure?
 string title Destructuring
 string website https://github.com/facebook/reason
 string reference https://reasonml.github.io/docs/en/destructuring
 string pseudoExample {title, rank} = pldbFile
hasDirectivesParser
 extends abstractFeatureParser
 description Is the language embedded in a tiny compile-time directive language?
 string title Directives
 string pseudoExample use strict;
 string reference https://en.wikipedia.org/wiki/Directive_(programming)
hasDisposeBlocksParser
 extends abstractFeatureParser
 description Does the language have a syntax for dispose blocks to free up resources allocated during execution?
 string title Dispose Blocks Pattern
 string pseudoExample with pldb: do computeRanks()
 string reference https://en.wikipedia.org/wiki/Dispose_pattern
hasDocCommentsParser
 extends abstractFeatureParser
 description Is there a standard mini language written in comments for documenting code?
 string title Doc comments
 string pseudoExample // param1: A comment about the first param
hasDuckTypingParser
 extends abstractFeatureParser
 description Are types defined not by their name, but by the presence of certain methods and properties?
 string title Duck Typing
 string pseudoExample length() // makes me an iterator
 string reference https://en.wikipedia.org/wiki/Duck_typing
hasDynamicPropertiesParser
 extends abstractFeatureParser
 description Does all properties have to be declared or does the language support dynamic properties?
 string title Dynamic Properties
 string pseudoExample pldb.score = 50
hasDynamicSizedArraysParser
 description Do arrays have to have their size specified at compile time or can they be dynamically sized?
 extends abstractFeatureParser
hasDynamicTypingParser
 description Are types of variables fixed or can they change during runtime?
 extends abstractFeatureParser
hasEnumsParser
 extends abstractFeatureParser
 description Does the language have a syntax and type for enums?
 string title Enums
 string reference https://en.wikipedia.org/wiki/Enumerated_type
 string pseudoExample colorsEnum { "red", "white", "blue"}
hasEscapeCharactersParser
 description Does the language have any notion of escape characters?
 extends abstractFeatureParser
hasExceptionsParser
 extends abstractFeatureParser
 description Does the language have a concept and syntax for exceptions?
 string title Exceptions
 string pseudoExample throw new Error("PLDB uh oh")
 string reference https://en.wikipedia.org/wiki/Exception_handling
hasExplicitTypeCastingParser
 extends abstractFeatureParser
 description Does the language have a syntax for type casting?
 string title Type Casting
 string pseudoExample (float)pldbRank;
 string reference https://en.wikipedia.org/wiki/Type_conversion
hasExportsParser
 description Does the language have a syntax for explicitly exporting items from a module or file?
 extends abstractFeatureParser
hasExpressionsParser
 extends abstractFeatureParser
 description Does the language have a concept of expressions?
 string title Expressions
 string pseudoExample (1 + 2)
 string reference https://en.wikipedia.org/wiki/Expression_(computer_science)
hasFirstClassFunctionsParser
 extends abstractFeatureParser
 description Does the language have functions that can be passed as arguments to other functions, can be returned by other functions, and can be assigned to variables or stored in data structures?
 string title First-Class Functions
 string pseudoExample [2.1].map(Math.round)
 string reference https://en.wikipedia.org/wiki/First-class_function
hasFixedPointParser
 extends abstractFeatureParser
 description Does the language have a type and syntax for fixed point numbers, such as currencies with 2 decimal points?
 string title Fixed Point Numbers
 string pseudoExample 80766866.00
 string reference https://en.wikipedia.org/wiki/Fixed-point_arithmetic
hasFloatsParser
 extends abstractFeatureParser
 description Does the language have a syntax and type for floating points?
 string title Floats
 string reference https://evanw.github.io/float-toy/ https://en.wikipedia.org/wiki/Floating-point_arithmetic
 string pseudoExample 80766866.0
hasFnArgumentsParser
 description Do functions accept arguments?
 extends abstractFeatureParser
hasForEachLoopsParser
 description Does the language have a concept and syntax for for-each loops?
 extends abstractFeatureParser
hasForLoopsParser
 description Does the language have a concept of and syntax for for-loops?
 extends abstractFeatureParser
hasFunctionCompositionParser
 extends abstractFeatureParser
 description Can you pass functions into other functions and get new combined functions?
 string title Function Composition
 string pseudoExample o = (f, g) => x => f(g(x))
 string reference https://en.wikipedia.org/wiki/Function_composition_(computer_science)
hasFunctionOverloadingParser
 extends abstractFeatureParser
 description Can you have multiple functions with the same name but different parameters?
 string title Function Overloading
 string reference https://en.wikibooks.org/wiki/Introduction_to_Programming_Languages/Overloading https://en.wikipedia.org/wiki/Function_overloading
 string aka Ad hoc polymorphism
 string pseudoExample add(string: str, string2: str)
hasFunctionsParser
 extends abstractFeatureParser
 description Does the language have a concept of and syntax for functions?
 string title Functions
 string aka routines
 string aka procedures
 string aka methods
 string pseudoExample function computePLDBRanks() {}
 string reference https://en.wikipedia.org/wiki/Subroutine
hasGarbageCollectionParser
 extends abstractFeatureParser
 description Does the language have a garbage collector or must memory of constructs be managed manually?
 string title Garbage Collection
 string pseudoExample var iDontNeedToFreeThis
 string reference https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)
hasGeneratorsParser
 extends abstractFeatureParser
 description Does the language have a concept of loops that yield?
 string title Generators
 string pseudoExample yield 2
 string reference https://en.wikipedia.org/wiki/Generator_(computer_programming)
hasGenericsParser
 extends abstractFeatureParser
 description Does the language have generics?
 string title Generics
 string pseudoExample function identity<T>(arg: T): T
 string reference https://en.wikipedia.org/wiki/Generic_programming
hasGlobalScopeParser
 description Is there at least one top level scope?
 extends abstractFeatureParser
hasGotosParser
 extends abstractFeatureParser
 description Does the language have a concept of and syntax for gotos?
 string title Gotos
 string pseudoExample goto 10
 string reference https://en.wikipedia.org/wiki/Goto
hasHereDocsParser
 extends abstractFeatureParser
 description Does the language have a syntax for multiline text blocks?
 string title Here Document
 string reference https://en.wikipedia.org/wiki/Here_document
 string pseudoExample \`A big multliline text block\`
hasHexadecimalsParser
 extends abstractFeatureParser
 description Does the language have a syntax for hexadecimals?
 string title Hexadecimals
 string aka Base16
 string aka hex
 string pseudoExample 0x4D06792
 string reference https://en.wikipedia.org/wiki/Hexadecimal
hasHomoiconicityParser
 extends abstractFeatureParser
 description Is the language also a valid data structure in that language?
 string title Homoiconicity
 string pseudoExample (list ())
 string reference https://en.wikipedia.org/wiki/Homoiconicity
hasIdsParser
 description Does the language have a concept of unique identifiers?
 extends abstractFeatureParser
hasIfElsesParser
 description Does the language have if-else statements or expressions?
 extends abstractFeatureParser
hasIfsParser
 description Does the language have "if" statements or expressoins?
 extends abstractFeatureParser
hasImplicitArgumentsParser
 extends abstractFeatureParser
 // todo: should we remove this one? I would have thought it was referring to something like an "arguments" implicit parameter
 description Does the language have a concept of contextual or implicit parameters?
 string title Implicit Arguments
 string reference https://docs.scala-lang.org/tour/implicit-parameters.html
 string pseudoExample shout(implicit message: string)
hasImplicitTypeConversionsParser
 extends abstractFeatureParser
 description Does the language automatically convert types as needed?
 string title Implicit Type Casting
 string reference https://en.wikipedia.org/wiki/Type_conversion
 string pseudoExample console.log("hello " + 2)
hasImportsParser
 extends abstractFeatureParser
 description Does this language have a syntax for importing other files?
 string title File Imports
 string pseudoExample import pldb
 string tokenKeyword includeToken
hasIncrementAndDecrementOperatorsParser
 extends abstractFeatureParser
 description Does this language have increment and decrement operators?
 string title Increment and decrement operators
 string pseudoExample i++
 string reference https://en.wikipedia.org/wiki/Increment_and_decrement_operators
hasInfixNotationParser
 extends abstractFeatureParser
 description Does this language use operators between operands?
 string title Infix Notation
 string pseudoExample 1 + 2
 string reference https://en.wikipedia.org/wiki/Infix_notation
hasInheritanceParser
 extends abstractFeatureParser
 description Does this language have class inheritance?
 string title Inheritance
 string pseudoExample class PLDBFile extends File
 string reference https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)
hasIntegersParser
 extends abstractFeatureParser
 description Does this language have a syntax and type for integers?
 string title Integers
 string pseudoExample 80766866
 string reference https://en.wikipedia.org/wiki/Integer_(computer_science)
hasInterfacesParser
 extends abstractFeatureParser
 description Does this language have a concept of interfaces?
 string title Interfaces
 string pseudoExample interface PLDBFile
 string reference https://en.wikipedia.org/wiki/Protocol_(object-oriented_programming)
hasIteratorsParser
 extends abstractFeatureParser
 description Does this language have iterators?
 string title Iterators
 string pseudoExample for lang in pldb()
 string reference https://en.wikipedia.org/wiki/Iterator
hasLabelsParser
 extends abstractFeatureParser
 description Does the language have a way to label locations within the source code?
 string title Labels
 string pseudoExample mainFn:
 string reference https://en.wikipedia.org/wiki/Label_(computer_science)
hasLazyEvaluationParser
 extends abstractFeatureParser
 description Does the language wait to evaluate expressions until needed?
 string title Lazy Evaluation
 string pseudoExample print(range(1000000)[2])
 string reference https://en.wikipedia.org/wiki/Lazy_evaluation
hasLineCommentsParser
 extends abstractFeatureParser
 description Does the language have line comments?
 string title Line Comments
 string reference https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(syntax)#Comments
 string pseudoExample # Hello PLDB
 string tokenKeyword lineCommentToken
hasListsParser
 extends abstractFeatureParser
 description Does the language have lists?
 string title Lists
 string aka array
 string aka vector
 string aka sequence
 string pseudoExample [2, 3, 10]
 string reference https://en.wikipedia.org/wiki/List_(abstract_data_type)
hasMacrosParser
 extends abstractFeatureParser
 description Does the language have a compile-time macro pass?
 string title Macros
 string pseudoExample #define pldbItems 4000
 string reference https://en.wikipedia.org/wiki/Macro_(computer_science)
hasMagicGettersAndSettersParser
 extends abstractFeatureParser
 description Does the language have a way to handle undefined getters and setters?
 string title Magic Getters and Setters
 string reference https://www.php.net/manual/en/language.oop5.overloading.php#object.get
 string pseudoExample get(name) => obj[name]
hasManualMemoryManagementParser
 extends abstractFeatureParser
 description Does the language have manual memory management?
 string title Manual Memory Management
 string pseudoExample malloc(4);
 string reference https://en.wikipedia.org/wiki/Manual_memory_management
hasMapFunctionsParser
 extends abstractFeatureParser
 description Does the language support running map over a list?
 string title Map Functions
 string pseudoExample pldbFiles.map(downloadFilesFn)
 string reference https://en.wikipedia.org/wiki/Map_(higher-order_function)
hasMapsParser
 extends abstractFeatureParser
 description Does the language have a map (aka hashtable) data structure?
 string title Maps
 string aka dict
 string aka dictionary
 string aka object
 string aka record
 string aka struct
 string aka hashtable
 string aka keyed list
 string aka associative array
 string pseudoExample {name: "PLDB"}
 string reference https://en.wikipedia.org/wiki/Associative_array
hasMemberVariablesParser
 extends abstractFeatureParser
 description Does the language have member variables?
 string aka properties
hasMessagePassingParser
 extends abstractFeatureParser
 description Does the language support message passing?
 string title Message Passing
 string pseudoExample "get pldb"
 string reference https://en.wikipedia.org/wiki/Message_passing
hasMethodChainingParser
 extends abstractFeatureParser
 description Does the language support method chaining?
 string title Method Chaining
 string pseudoExample pldbFile.toString().length
 string reference https://en.wikipedia.org/wiki/Method_chaining
hasMethodOverloadingParser
 description Does the language support method overloading?
 extends abstractFeatureParser
hasMethodsParser
 extends abstractFeatureParser
 description Does the language have methods on classes?
 string title Methods
 string pseudoExample pldbFile.downloadWebsite()
 string reference https://en.wikipedia.org/wiki/Method_(computer_programming)
hasMixinsParser
 extends abstractFeatureParser
 description Does the language allow including methods from a class without inheriting from that class?
 string title Mixins
 string pseudoExample extends pldbFile, diskFile
 string reference https://en.wikipedia.org/wiki/Mixin
hasModulesParser
 extends abstractFeatureParser
 description Does the language have a concept of modules for organizing and packaging code?
 string title Module Pattern
 string pseudoExample module PLDB {}
 string reference https://en.wikipedia.org/wiki/Module_pattern
hasMonadsParser
 extends abstractFeatureParser
 description Does the language have monads?
 string title Monad
 string pseudoExample g >>= f
 string reference https://en.wikipedia.org/wiki/Monad_(functional_programming)
hasMultiLineCommentsParser
 extends abstractFeatureParser
 description Does the language have multi-line comments?
 string title MultiLine Comments
 string reference https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(syntax)#Comments
 string pseudoExample /* Hello PLDB */
 string tokenKeyword multiLineCommentTokens
hasMultilineStringsParser
 extends abstractFeatureParser
 description Does the language support multiline strings?
 string title Multiline Strings
 string pseudoExample hello = """Hello\\nPLDB"""
hasMultipleDispatchParser
 extends abstractFeatureParser
 description Does the language support multiple dispatch?
 string title Multiple Dispatch
 string pseudoExample collide_with(x::Spaceship, y::Spaceship)
 string reference https://en.wikipedia.org/wiki/Multiple_dispatch
hasMultipleInheritanceParser
 extends abstractFeatureParser
 description Does the language allow multiple inheritance?
 string title Multiple Inheritance
 string pseudoExample extends parentWhichExtendsSomethingElse
 string reference https://en.wikipedia.org/wiki/Multiple_inheritance
hasNamespacesParser
 extends abstractFeatureParser
 description Does the language have a namespace construct?
 string title Namespaces
 string pseudoExample namespace PLDB {}
hasNullParser
 extends abstractFeatureParser
 description Does the language have a null value?
 string title Null
 string reference https://en.wikipedia.org/wiki/Null_pointer
 string pseudoExample uhOh = null
hasOctalsParser
 extends abstractFeatureParser
 description Does the language have a syntax for octal numbers?
 string title Octals
 string aka Base8
 string aka oct
 string pseudoExample 0o464063622
 string reference https://en.wikipedia.org/wiki/Octal
hasOperatorOverloadingParser
 extends abstractFeatureParser
 description Does the language allow operator overloading?
 string title Operator Overloading
 string reference https://en.wikibooks.org/wiki/Introduction_to_Programming_Languages/Overloading https://en.wikipedia.org/wiki/Operator_overloading
 string pseudoExample def __add__(): doSomethingDifferent()
hasOperatorsParser
 extends abstractFeatureParser
 description Does the language have operators?
 string title Operators
 string reference https://en.wikipedia.org/wiki/Operator_(computer_programming)
 string pseudoExample 1 + 1
hasPairsParser
 extends abstractFeatureParser
 description Does the language have a pair structure?
 string title Pairs
 string pseudoExample (pl . db)
hasPartialApplicationParser
 extends abstractFeatureParser
 description Does the language support partial application?
 string title Partial Application
 string pseudoExample add5 = num => addNumbers(10, num)
 string reference https://en.wikipedia.org/wiki/Partial_application
hasPatternMatchingParser
 extends abstractFeatureParser
 description Does the language support pattern matching?
 string title Pattern Matching
 string pseudoExample fib 0 = 1; fib 1 = 1
 string reference https://en.wikipedia.org/wiki/Pattern_matching
hasPipesParser
 extends abstractFeatureParser
 description Does the language have a pipe operator?
 string title Pipes
 string pseudoExample ls pldb | wc
 string reference https://en.wikipedia.org/wiki/Pipeline_(software)
hasPointersParser
 extends abstractFeatureParser
 // question: are there languages that have pointers to a location in an l1/lN cache?
 description Does the language have a structure that is a location in memory?
 string title Pointers
 string pseudoExample int *pldb
 string reference https://en.wikipedia.org/wiki/Pointer_(computer_programming)
hasPolymorphismParser
 extends abstractFeatureParser
 description Does the language have polymorphism?
 string title Polymorphism
 string pseudoExample a + "b"; 1 + 2
 string reference https://en.wikipedia.org/wiki/Polymorphism_(computer_science)
hasPostfixNotationParser
 extends abstractFeatureParser
 description Does the language allow operators to be placed at the end of the expression?
 string title Postfix Notation
 string pseudoExample 2 3 4 + 2 -
 string reference https://en.wikipedia.org/wiki/Reverse_Polish_notation
hasPrefixNotationParser
 extends abstractFeatureParser
 description Does the language allow operators to be placed at the beginning of the expression?
 string title Prefix Notation
 string pseudoExample + 1 2
 string reference https://en.wikipedia.org/wiki/Polish_notation
hasPrintDebuggingParser
 extends abstractFeatureParser
 description Does the language have a built in function that allows one to print debug?
 string title Print() Debugging
 string reference https://en.wikipedia.org/wiki/Debug_code#Print_debugging
 string pseudoExample print "Hello PLDB"
 string tokenKeyword printToken
hasProcessorRegistersParser
 extends abstractFeatureParser
 description Does the language have named symbols for a processor's registers?
 string title Processor Registers
 string pseudoExample eax 2
 string reference https://en.wikipedia.org/wiki/Processor_register
hasRangeOperatorsParser
 extends abstractFeatureParser
 description Does the language have a syntax for creating ranges?
 string title Range Operator
 string reference https://docstore.mik.ua/orelly/perl4/prog/ch03_15.htm
 string pseudoExample 1 ... 10
hasReferencesParser
 extends abstractFeatureParser
 description Does the language have a structure for holding a reference to an existing object?
 string title References
 string pseudoExample fn(objPointer)
 string reference https://en.wikipedia.org/wiki/Reference_(computer_science)
hasRefinementTypesParser
 extends abstractFeatureParser
 description Does the language have a way to attach a predicate to a type?
 string title Refinement Types
 string pseudoExample evenInt where int % 2 = 0
 string reference https://en.wikipedia.org/wiki/Refinement_type
hasRegularExpressionsSyntaxSugarParser
 extends abstractFeatureParser
 description Does the language have special syntax for regular expressions?
 string title Regular Expression Syntax Sugar
 string reference https://pldb.com/concepts/regex.html
 string pseudoExample /pldb/
hasRequiredMainFunctionParser
 description Does the language require a function named main (or similar)?
 extends abstractFeatureParser
hasReservedWordsParser
 description Does a concept of reserved words exists, for example, not being able to use certain keywords as variable names.?
 extends abstractFeatureParser
hasRunTimeGuardsParser
 extends abstractFeatureParser
 description Does the language support run-time guards?
 string title Runtime Guards
 string pseudoExample f x | x > 0 = 1 | otherwise = 0
 string reference https://en.wikipedia.org/wiki/Guard_(computer_science)
hasSExpressionsParser
 description Does the language have S Expressions?
 extends abstractFeatureParser
 string title S-Expressions
 string pseudoExample (+ 1 1)
 string reference https://en.wikipedia.org/wiki/S-expression
hasScientificNotationParser
 extends abstractFeatureParser
 description Does the language have a syntax for Scientific Notation?
 string title Scientific Notation
 string aka E Notation
 string pseudoExample 8076686.6e1
 string reference https://en.wikipedia.org/wiki/Scientific_notation
hasSelfOrThisWordParser
 description Does a language have a keyword or syntax to refer to the current instance?
 extends abstractFeatureParser
hasSemanticIndentationParser
 extends abstractFeatureParser
 description Does the language use semantic indentation?
 string aka off-side rule
 string title Semantic Indentation
 string reference https://pldb.com/posts/which-programming-languages-use-indentation.html
 string pseudoExample line0 if true line1  print "Hello PLDB"
hasSetsParser
 extends abstractFeatureParser
 description Does the language come with a Set data structure?
 string title Sets
 string pseudoExample {"pldb", "PLDB"}
 string reference https://en.wikipedia.org/wiki/Set_(abstract_data_type)
hasSingleDispatchParser
 extends abstractFeatureParser
 description Does the method called depended on a single operand?
 string title Single Dispatch
 string reference https://en.wikipedia.org/wiki/Dynamic_dispatch#Single_and_multiple_dispatch
 string pseudoExample person.run()
hasSingleTypeArraysParser
 extends abstractFeatureParser
 description Does the language have a list data structure that only can hold items of the same type?
 string title Single-Type Arrays
 string reference https://en.wikipedia.org/wiki/Array_data_structure
 string pseudoExample const pldbRanks: int[]
hasSourceMapsParser
 extends abstractFeatureParser
 description Does the language support the generation of source maps?
 string title Source Maps
 string pseudoExample {file: 'pldb.min.js',sources: ['pldb.js'], mappings: 'CAAC,IAAI,IAAM'}
hasStatementTerminatorCharacterParser
 description Does the language have a statement terminator character such as ";"?
 extends abstractFeatureParser
hasStatementsParser
 extends abstractFeatureParser
 description Does the language have a concept of statements?
 string title Statements
 string pseudoExample print "Hello PLDB"
 string reference https://en.wikipedia.org/wiki/Statement_(computer_science)
hasStaticMethodsParser
 extends abstractFeatureParser
 description Can a class have static methods?
 string title Static Methods
 string reference https://www.geeksforgeeks.org/static-methods-vs-instance-methods-java/
 string pseudoExample static downloadPldb() {}
hasStaticTypingParser
 extends abstractFeatureParser
 description Does the language have static typing at compile time?
 string title Static Typing
 string reference https://en.wikipedia.org/wiki/Type_system#Static_type_checking
 string pseudoExample int pldbRank = 100
hasStreamsParser
 extends abstractFeatureParser
 description Does the language have a concept of streams?
 string title Streams
 string pseudoExample echo 123 | 123.txt
 string reference https://en.wikipedia.org/wiki/Stream_(computing)
hasStringConcatOperatorParser
 description Is there an operator for concatenating strings?
 extends abstractFeatureParser
hasStringsParser
 extends abstractFeatureParser
 description Does the language have a strings data structure?
 string title Strings
 string pseudoExample "Hello PLDB"
 string tokenKeyword stringToken
 string reference https://en.wikipedia.org/wiki/String_(computer_science)
hasStructsParser
 extends abstractFeatureParser
 description Does the language have a structs structure?
 string title Structs
 string pseudoExample struct pldbFile { int rank; char *title; };
 string reference https://en.wikipedia.org/wiki/Struct_(C_programming_language)
hasSwitchParser
 extends abstractFeatureParser
 description Does the language have switch statements or expressions?
 string title Switch Statements
 string pseudoExample switch animal: case dog-buy; case cat-sell;
 string reference https://en.wikipedia.org/wiki/Switch_statement
hasSymbolTablesParser
 extends abstractFeatureParser
 description Does the compiler use symbol tables internally?
 string title Symbol Tables
 string pseudoExample SymbolName|Type|Scope;bar|function,double|extern
 string reference https://en.wikipedia.org/wiki/Symbol_table
hasSymbolsParser
 description Does the language have a concept of symbols?
 extends abstractFeatureParser
hasTemplatesParser
 extends abstractFeatureParser
 description Does the language support templates?
 string title Templates
 string pseudoExample template TCopy(T) {}
 string reference https://en.wikipedia.org/wiki/Template_metaprogramming
hasTernaryOperatorsParser
 extends abstractFeatureParser
 description Does the language have ternary operators?
 string title Ternary operators
 string pseudoExample true ? 1 : 0
 string reference https://en.wikipedia.org/wiki/Ternary_operation
hasThreadsParser
 extends abstractFeatureParser
 description Does the language support a concept of threads?
 string title Threads
 string pseudoExample thread1(); thread2();
 string reference https://en.wikipedia.org/wiki/Thread_(computing)
hasTimestampsParser
 description Does the language have a builtin timestamps data structure?
 extends abstractFeatureParser
hasTraitsParser
 extends abstractFeatureParser
 description Does the language support traits?
 string title Traits
 string pseudoExample use redBorder
 string reference https://en.wikipedia.org/wiki/Trait_(computer_programming)
hasTriplesParser
 extends abstractFeatureParser
 description Does the language have a structure for subject–predicate–object expressions?
 string title Triples
 string pseudoExample Javascript isListedIn PLDB
 string reference https://en.wikipedia.org/wiki/Semantic_triple
hasTryCatchParser
 description Does the language have a try/catch construct?
 extends abstractFeatureParser
hasTypeAnnotationsParser
 extends abstractFeatureParser
 description Does the language have a syntax for annotating the types of variables?
 string title Type Annotations
 string pseudoExample score: number
hasTypeInferenceParser
 extends abstractFeatureParser
 description Can the parser infer the type of a variable at compile time without an annotation?
 string title Type Inference
 string reference https://en.wikipedia.org/wiki/Type_inference
 string pseudoExample imAString = "pldb"
hasTypeParametersParser
 extends abstractFeatureParser
 description Does the language support a concept of type parameters?
 string title Type Parameters
 string pseudoExample function identity<T>(arg: T): T {return arg}
 string reference https://en.wikipedia.org/wiki/TypeParameter
hasTypedHolesParser
 extends abstractFeatureParser
 description Does the language have a syntax for typed holes?
 string title Typed Holes
 string reference https://wiki.haskell.org/GHC/Typed_holes
 string pseudoExample 2 + _ => 2 + [int|float]
hasUnaryOperatorsParser
 extends abstractFeatureParser
 description Does the language have any unary operators like ++ or --?
 string title Unary Operators
 string pseudoExample count++
 string reference https://en.wikipedia.org/wiki/Unary_operation
hasUnicodeIdentifiersParser
 extends abstractFeatureParser
 description Does the language support Unicode identifiers?
 // some support only ASCII
 string title Unicode Identifers
 string pseudoExample δ = 0.00001
hasUnionTypesParser
 extends abstractFeatureParser
 description Does the language support union types?
 string title Union Types
 string pseudoExample any = string | number
 string reference https://en.wikipedia.org/wiki/Union_type
hasUnitsOfMeasureParser
 extends abstractFeatureParser
 description Does the language support units of measure?
 string title Units of Measure
 string pseudoExample 42cm
 string reference https://en.wikipedia.org/wiki/Unit_of_measurement
hasUserDefinedOperatorsParser
 description Does the language allow for defining your own operators?
 extends abstractFeatureParser
hasValueReturnedFunctionsParser
 description Can functions return a value?
 extends abstractFeatureParser
hasVariableSubstitutionSyntaxParser
 extends abstractFeatureParser
 description Do you use different syntax when assigning versus referencing a variable?
 string title Variable Substitution Syntax
 string pseudoExample name = "PLDB"; print $name
hasVariadicFunctionsParser
 description Does the language support functions that accept a variable number of parameters?
 extends abstractFeatureParser
 string title Variadic Functions
 string pseudoExample args.map(doSomething)
 string reference https://en.wikipedia.org/wiki/Variadic_function
hasVirtualFunctionsParser
 description Does the language have virtual functions?
 extends abstractFeatureParser
 string title Virtual function
 string pseudoExample virtual FetchPLDBFile();
 string reference https://en.wikipedia.org/wiki/Virtual_function
hasVoidFunctionsParser
 description Does the language have void functions that return nothing?
 extends abstractFeatureParser
hasWhileLoopsParser
 description Does the language have while loops?
 extends abstractFeatureParser
 string title While Loops
 string pseudoExample while (pldb.pop()) loop()
 string reference https://en.wikipedia.org/wiki/While_loop
hasZeroBasedNumberingParser
 description Does the language start counting from 0, rather than 1?
 extends abstractFeatureParser
 string title Zero-based numbering
 string reference https://en.wikipedia.org/wiki/Zero-based_numbering
 string pseudoExample firstItem = pldb[0]
hasZippersParser
 extends abstractFeatureParser
 description Does the language have zippers built in or as a library, which are roughly a pointer with context on a tree?
 string title Zippers
 string reference https://wiki.haskell.org/Zipper https://en.wikipedia.org/wiki/Zipper_(data_structure)
 string pseudoExample pldbCursor.moveLeft()
isCaseSensitiveParser
 extends abstractFeatureParser
 description Is this language case sensitive?
 string title Case Sensitivity
 string reference https://en.wikipedia.org/wiki/Case_sensitivity
 string pseudoExample pldb != PLDB
isLispParser
 extends abstractFeatureParser
 string title Lispy
 description Is this in the Lisp family of languages?
 string reference https://en.wikipedia.org/wiki/Lisp_(programming_language)
 string pseudoExample (+ 1 2)
letterFirstIdentifiersParser
 extends abstractFeatureParser
 description Must identifiers start with a letter?
 string title Letter-first Identifiers
 string pseudoExample pldb100 = "OK" // 100pldb = "ERROR"
mergesWhitespaceParser
 extends abstractFeatureParser
 description Does this language merge whitespace, so N spaces is treated the same as a single space?
 string title Merges Whitespace
 string reference http://wiki.c2.com/?SyntacticallySignificantWhitespaceConsideredHarmful
 string pseudoExample result = 1    +    2
supportsBreakpointsParser
 extends abstractFeatureParser
 description Does this language support breakpoints?
 string title Breakpoints
 string pseudoExample debugger;
 string reference https://en.wikipedia.org/wiki/Breakpoint
isLanguageParser
 boolean isComputed true
 extends abstractBooleanColumnParser
 // todo: bug the below line should be included via inheritance from WWC.
 boolean suggestInAutocomplete false
 description Does PLDB categorize this entity as a language?
isOpenSourceParser
 boolean alwaysRecommended true
 description Is this an open source project?
 extends abstractBooleanColumnParser
isPublicDomainParser
 boolean alwaysRecommended true
 description Is this public domain?
 extends abstractBooleanColumnParser
gdbSupportParser
 extends abstractBooleanColumnParser
 description Is the language supported by the GNU Debugger?
 string sourceDomain sourceware.org
githubCopilotOptimizedParser
 description Is this language optimized for GitHub copilot, as found on this list https://docs.github.com/en/copilot/overview-of-github-copilot/about-github-copilot?
 extends abstractBooleanColumnParser
isDeadParser
 description Has the creator or maintainer announced it officially dead? Include a link to proof of the announcement.
 extends abstractBooleanColumnParser
 catchAllParser urlCitationParser
abstractParadigmParser
 cells columnNameCell boolCell
 extends abstractBooleanColumnParser
visualParadigmParser
 extends abstractParadigmParser
 description Is this a visual programming thing? Sometimes called "no code" or "low code"?
usesSemanticVersioningParser
 extends abstractBooleanColumnParser
 description Does the official release of the language use semantic versioning?
abstractOneWordGuidColumnParser
 string typeForCsvDocs guid
 cells columnNameCell externalGuidCell
 extends abstractTrueBaseColumnParser
 description Use when you have a column that serves as a Globally Unique Identifier (GUID) where the GUID does not contain spaces.
codeMirrorParser
 extends abstractOneWordGuidColumnParser
 description What is a URL to a CodeMirror syntax highlighting package for this language?
 // Many can be found here: https://github.com/codemirror/codemirror5/tree/master/mode/LANGUAGE
 string sourceDomain codemirror.net
monacoParser
 extends abstractOneWordGuidColumnParser
 description What is a URL to a Monaco syntax highlighting package for this language?
 example
  javascript
   monaco javascript
 string sourceDomain microsoft.github.io/monaco-editor/
tryItOnlineParser
 extends abstractOneWordGuidColumnParser
 description What is a link to try this language on https://tio.run?
 string sourceDomain tio.run
ubuntuPackageParser
 extends abstractOneWordGuidColumnParser
 description What is the name of an Ubuntu package for this language from https://packages.ubuntu.com/, if any?
 string sourceDomain ubuntu.com
abstractMultiwordGuidColumnParser
 string typeForCsvDocs guid
 description Use when you have a column that serves as a Globally Unique Identifier (GUID) where the GUID can contain spaces.
 catchAllCellType externalGuidCell
 extends abstractTrueBaseColumnParser
compilerExplorerParser
 extends abstractMultiwordGuidColumnParser
 description What is this language's name on https://godbolt.org?
 string sourceDomain godbolt.org
 contentKey id
 inScope exampleParser
githubBigQueryParser
 description What is the name of this language in the Google BigQuery Public Datasets about GitHub repos found at https://cloud.google.com/blog/topics/public-datasets/github-on-bigquery-analyze-all-the-open-source-code?
 extends abstractMultiwordGuidColumnParser
 contentKey id
 string sourceDomain cloud.google.com
 usersParser
  description How many unique users have a repo using this language according to Google BigQuery?
  extends abstractPopulationCountColumnParser
 reposParser
  description How many repos for this language are listed in Google's BigQuery Public GitHub Dataset snapshot?
  extends abstractCountColumnParser
githubLanguageParser
 description What is the name of this language on GitHub's list of supported languages defined here https://raw.githubusercontent.com/github/linguist/master/lib/linguist/languages.yml?
 extends abstractMultiwordGuidColumnParser
 inScope filenamesParser fileExtensionsParser
 contentKey id
 string sourceDomain github.com
 reposParser
  boolean fromCrawler true
  extends abstractCountColumnParser
  description How many repos for this language does GitHub report?
 wrapParser
  extends abstractBooleanColumnParser
  description Does GitHub override it's default of not wrapping lines when displaying this language?
 trendingProjectsCountParser
  boolean fromCrawler true
  extends abstractCountColumnParser
  description How many trending repos for this language does GitHub report?
 trendingProjectsParser
  // todo Figure out typings.
  extends abstractDelimitedValuesBlobColumnParser
  boolean fromCrawler true
  description What are trending projects in this language GitHub?
  example
   author name avatar url language languageColor stars forks currentPeriodStars description
   PavelDoGreat WebGL-Fluid-Simulation https://github.com/PavelDoGreat.png https://github.com/PavelDoGreat/WebGL-Fluid-Simulation JavaScript #f1e05a 6010 473 2246 "Play with fluids in your browser (works even on mobile)"
 groupParser
  extends abstractMultiwordGuidColumnParser
  description What is the name of the parent language group according to GitHub?
 aliasesParser
  extends abstractStringListColumnParser
  description What are additional aliases, excluding name.downcase which are implicitly included?
  listDelimiter  or 
 interpretersParser
  extends abstractStringListColumnParser
  description What are the associated interpreters?
 aceModeParser
  extends abstractWordColumnParser
  description What is the name of the Ace Mode used for highlighting whenever a file is edited, matching one of the filenames in http://git.io/3XO_Cg, or "text" for everything else?
 codemirrorModeParser
  extends abstractWordColumnParser
  description What is the name name of the CodeMirror Mode used for highlighting whenever a file is edited, from the list here https://git.io/vi9Fx?
 codemirrorMimeTypeParser
  extends abstractWordColumnParser
  description What is the name of the file mime type used for highlighting whenever a file is edited, from the list here https://git.io/f4SoQ?
 tmScopeParser
  extends abstractMultiwordGuidColumnParser
  description What is the TextMate scope that represents this programming language, matching one of the scopes listed in the grammars.yml file, or "none" if there is no grammar for this language?
 typeParser
  extends abstractEnumColumnParser
  description Which of the types best describes this: data, programming, markup, prose, or nil?
leachim6Parser
 extends abstractMultiwordGuidColumnParser
 description What is a URL to this language in leachim6's hello-world project?
 string sourceDomain github.com/leachim6/hello-world
 contentKey id
 inScope fileExtensionsParser exampleParser
 filepathParser
  description What is the filepath to this language in leachim6's hello-world project?
  extends abstractStringColumnParser
projectEulerParser
 extends abstractMultiwordGuidColumnParser
 description Is this language one of the ones listed on https://projecteuler.net/?
 string sourceDomain projecteuler.net
 contentKey id
 memberCountParser
  description How many project euler members use this language?
  extends abstractAnnualPopulationCountMapParser
pygmentsHighlighterParser
 extends abstractMultiwordGuidColumnParser
 description What is a url to a Pygments syntax highlighting class for this language https://pygments.org/?
 string sourceDomain pygments.org
 inScope fileExtensionsParser
 contentKey id
 filenameParser
  description What is the Python filename implementing the highlighting for this language?
  extends abstractTrueBaseColumnParser
  cells columnNameCell fileNameCell
pyplParser
 extends abstractMultiwordGuidColumnParser
 description What is this language's id on https://pypl.github.io?
 string sourceDomain pypl.github.io
quineRelayParser
 extends abstractMultiwordGuidColumnParser
 description What is the name of this language in the Quine Relay project from here https://github.com/mame/quine-relay?
 string sourceDomain github.com/mame/quine-relay
tiobeParser
 extends abstractMultiwordGuidColumnParser
 description What is the ID of this language in Tiobe's ranking of programming languages here: https://www.tiobe.com/tiobe-index/?
 string sourceDomain tiobe.com
 contentKey id
 currentRankParser
  description What is the current Tiobe rank of this language?
  extends abstractIntColumnParser
abstractStringColumnParser
 string typeForCsvDocs string
 catchAllCellType stringCell
 extends abstractTrueBaseColumnParser
idParser
 description What is the name of this file without the extension?
 extends abstractStringColumnParser
 boolean isComputed true
 boolean suggestInAutocomplete false
getSourceParser
 boolean isComputed true
 extends abstractStringColumnParser
 // todo: bug the below line should be included via inheritance from WWC.
 boolean suggestInAutocomplete false
 description What is a one line shell command to download the source code for this language?
descriptionParser
 boolean alwaysRecommended true
 extends abstractStringColumnParser
 description What is a short description of this language?
abstractStringListColumnParser
 string typeForCsvDocs string[]
 description A list of strings separated by the \`listDelimiter\`. The default \`listDelimiter\` is space.
 extends abstractStringColumnParser
 listDelimiter  
keywordsParser
 description What are all the keywords in this language?
 extends abstractStringListColumnParser
 catchAllCellType tokenCell
abstractCommonTokenParser
 description Most general purpose programming languages implement a set of common tokens for common features like these.
 catchAllCellType tokenCell
 extends abstractStringListColumnParser
 single false
lineCommentTokenParser
 extends abstractCommonTokenParser
 description What is the token(s) that can be placed anywhere on a line and starts a comment that cannot be stopped except by a line break character or end of file?
 example
  javascript
   lineCommentToken //
multiLineCommentTokensParser
 extends abstractCommonTokenParser
 description What is the start delimiter and end token (which can be the same) for comments that can span multiple lines?
 example
  javascript
   multiLineCommentTokens /* */
printTokenParser
 extends abstractCommonTokenParser
 description What token(s) is used to print a message?
 example
  javascript
   printToken console.log
stringTokenParser
 extends abstractCommonTokenParser
 description What token(s) is used to delimit a string?
 example
  javascript
   stringToken "
assignmentTokenParser
 extends abstractCommonTokenParser
 description What token(s) is used for assignment to an identifier?
 example
  javascript
   assignmentToken =
booleanTokensParser
 extends abstractCommonTokenParser
 description What token(s) is used for true and false?
 example
  javascript
   booleanTokens true false
includeTokenParser
 extends abstractCommonTokenParser
 description What token(s) is used for including another file?
 example
  nodejs
   includeToken require
fileExtensionsParser
 extends abstractStringListColumnParser
 catchAllCellType fileExtensionCell
 description What are the file extensions for this language?
filenamesParser
 extends abstractStringListColumnParser
 catchAllCellType fileNameCell
 description What are the filenames commonly associated with this language?
creatorsParser
 extends abstractStringListColumnParser
 boolean alwaysRecommended true
 description What are the name(s) of the original creators of the language delimited by " and "?
 catchAllCellType creatorNameCell
 listDelimiter  and 
originCommunityParser
 description In what community(ies) did the language first originate?
 boolean alwaysRecommended true
 // todo Make origin community name the url for the community? instead of the name? Not sure.
 listDelimiter  && 
 example
  originCommunity Microsoft && /r/programminglanguages && news.ycombinator.com
 extends abstractStringListColumnParser
abstractTrueBaseLinksColumnParser
 description Links to other files in the TrueBase.
 catchAllCellType trueBaseIdCell
 string typeForCsvDocs trueBaseId[]
 extends abstractStringListColumnParser
 javascript
  get trueBaseIds() {
   return this.getWordsFrom(1)
  }
  updateTruebaseIds(oldTrueBaseId, newTrueBaseId) {
   this.setContent(
    this.getWordsFrom(1)
     .map((word) => (word === oldTrueBaseId ? newTrueBaseId : word))
     .join(" ")
   )
  }
forLanguagesParser
 description Which languages is this repository for?
 extends abstractTrueBaseLinksColumnParser
abstractRelationshipParser
 extends abstractTrueBaseLinksColumnParser
 // todo: remove need for sortKey in Grammar
 string sortKey abstractRelationshipParser
relatedParser
 extends abstractRelationshipParser
 description What languages are related?
 // This serves as a catch all, and it is better to use a more specific relationship node such as "supersetOf".
runsOnVmParser
 extends abstractRelationshipParser
 description What virtual machine(s) does this language run on? 
influencedByParser
 description What languages influenced this one?
 extends abstractRelationshipParser
successorOfParser
 description Was this language launched as the successor of another?
 extends abstractRelationshipParser
subsetOfParser
 description Is this language a subset of another?
 extends abstractRelationshipParser
implementationOfParser
 description Is this language an implementation of another?
 extends abstractRelationshipParser
renamedToParser
 description What is the new name of this language?
 extends abstractRelationshipParser
supersetOfParser
 description Is this language a superset of another?
 // If you specify this link then the superset language will inherit all features of subset language.
 extends abstractRelationshipParser
writtenInParser
 description What language(s) is the main implementation written in?
 extends abstractRelationshipParser
extensionOfParser
 description What language is this language an extension of?
 extends abstractRelationshipParser
forkOfParser
 description What language is this language a fork of?
 extends abstractRelationshipParser
compilesToParser
 description Which language(s) does this language primarily compile to?
 extends abstractRelationshipParser
inputLanguagesParser
 description Which language(s) does this take as input? For compilers, what languages does this compile compile?
 extends abstractRelationshipParser
titleParser
 description What is the official title of the language?
 extends abstractStringColumnParser
 required
standsForParser
 description If the language name is an acronym what does/did it stand for?
 extends abstractStringColumnParser
akaParser
 description What is this also known as?
 extends abstractStringColumnParser
 single false
oldNameParser
 description What is the old name of this language?
 extends abstractStringColumnParser
abstractNumericColumnParser
 string typeForCsvDocs number
 extends abstractTrueBaseColumnParser
abstractIntColumnParser
 string typeForCsvDocs integer
 cells columnNameCell intCell
 extends abstractNumericColumnParser
hoplIdParser
 boolean isComputed true
 extends abstractIntColumnParser
 // todo: bug the below line should be included via inheritance from WWC.
 boolean suggestInAutocomplete false
 description What is the HOPL id of this language?
abstractComputedSumColumnParser
 boolean isComputed true
 boolean suggestInAutocomplete false
 extends abstractIntColumnParser
bookCountParser
 extends abstractComputedSumColumnParser
 // todo: bug the below line should be included via inheritance from WWC.
 boolean suggestInAutocomplete false
 description What is the count of booked we have published about this thing?
paperCountParser
 extends abstractComputedSumColumnParser
 // todo: bug the below line should be included via inheritance from WWC.
 boolean suggestInAutocomplete false
 description What is the count of papers we have published about this thing?
exampleCountParser
 extends abstractComputedSumColumnParser
 // todo: bug the below line should be included via inheritance from WWC.
 boolean suggestInAutocomplete false
 description How many examples do we have written in this language?
factCountParser
 extends abstractComputedSumColumnParser
 // todo: bug the below line should be included via inheritance from WWC.
 boolean suggestInAutocomplete false
 description How many answers do we have about this thing?
abstractCountColumnParser
 description A positive count of something. People, for example. Min is 0.
 cells columnNameCell countCell
 extends abstractIntColumnParser
abstractComputedEstimateColumnParser
 boolean isComputed true
 boolean suggestInAutocomplete false
 extends abstractCountColumnParser
numberOfUsersEstimateParser
 extends abstractComputedEstimateColumnParser
 // todo: bug the below line should be included via inheritance from WWC.
 boolean suggestInAutocomplete false
 description What is our estimate of number of users of this language?
numberOfJobsEstimateParser
 extends abstractComputedEstimateColumnParser
 // todo: bug the below line should be included via inheritance from WWC.
 boolean suggestInAutocomplete false
 description What is our estimate of the number of jobs in this language?
centralPackageRepositoryCountParser
 extends abstractCountColumnParser
 description How many central package repositories does this language have?
packageInstallCountParser
 description How many packages have been downloaded?
 extends abstractCountColumnParser
packageCountParser
 description How many packages are in the repository?
 // A package is some code with a name and a namespace, shipped as an atomic unit, with an owner(s).
 extends abstractCountColumnParser
abstractPopulationCountColumnParser
 extends abstractCountColumnParser
packageAuthorsParser
 extends abstractPopulationCountColumnParser
 description How many people contribute packages to this cpm?
abstractComputedRankColumnParser
 boolean isComputed true
 boolean suggestInAutocomplete false
 extends abstractIntColumnParser
rankParser
 extends abstractComputedRankColumnParser
 // todo: bug the below line should be included via inheritance from WWC.
 boolean suggestInAutocomplete false
 description How does this thing rank amongst all entities in this TrueBase?
languageRankParser
 extends abstractComputedRankColumnParser
 // todo: bug the below line should be included via inheritance from WWC.
 boolean suggestInAutocomplete false
 description How does this language rank amongst all languages in PLDB?
abstractYearColumnParser
 cells columnNameCell yearCell
 extends abstractIntColumnParser
lastActivityParser
 extends abstractYearColumnParser
 // todo: bug the below line should be included via inheritance from WWC.
 boolean suggestInAutocomplete false
 boolean isComputed true
 description In our data on this entity, what year is the most recent activity?
appearedParser
 description What year was the language publicly released and/or announced?
 extends abstractYearColumnParser
 required
wordRankParser
 description Where does this word rank in terms of common English words?
 // where "the" is 1.
 extends abstractIntColumnParser
abstractFloatColumnParser
 cells columnNameCell floatCell
 extends abstractNumericColumnParser
abstractPercentageColumnParser
 cells columnNameCell percentCell
 extends abstractNumericColumnParser
countryParser
 uniqueLine
 description What country was this language first developed in?
 boolean alwaysRecommended true
 catchAllCellType countryNameCell
 extends abstractTrueBaseColumnParser
 single false
dblpParser
 boolean fromCrawler true
 extends abstractTrueBaseColumnParser
 description What are publications about this language from https://dblp.org/?
 string sourceDomain dblp.org
 hitsParser
  extends abstractCountColumnParser
  description How many matching publications?
 publicationsParser
  extends abstractDelimitedValuesBlobColumnParser
  description An inline PSV table of hits.
abstractStringBlobColumnParser
 string typeForCsvDocs multilineString
 extends abstractTrueBaseColumnParser
 baseParser blobParser
 javascript
  get columnValue() {
   return this.childrenToString()
  }
abstractCodeColumnParser
 extends abstractStringBlobColumnParser
 baseParser blobParser
equationParser
 description What is a LaTeX encoding of this equation?
 extends abstractCodeColumnParser
exampleParser
 description What is a representative snippet for this language?
 extends abstractCodeColumnParser
 single false
helloWorldCollectionParser
 description What is the name of this project in the Hello World Collection?
 extends exampleParser
 cruxFromId
 cells columnNameCell
 catchAllCellType helloWorldCollectionIdCell
 string sourceDomain helloworldcollection.de
funFactParser
 cells columnNameCell urlCell
 description What is a code block or some text containing a fun or unusual fact about the language?
 extends abstractCodeColumnParser
abstractDelimitedValuesBlobColumnParser
 description A CSV, TSV, or other delimited blob of text.
 // todo: figure out how we want to dump these in CSV export.
 extends abstractStringBlobColumnParser
goodreadsParser
 boolean fromCrawler true
 extends abstractDelimitedValuesBlobColumnParser
 description What are books about this language from Goodreads?
 string sourceDomain goodreads.com
hackerNewsDiscussionsParser
 boolean fromCrawler true
 extends abstractDelimitedValuesBlobColumnParser
 description What are URLS to Hacker News posts discussing this language?
 string sourceDomain news.ycombinator.com
isbndbParser
 boolean fromCrawler true
 extends abstractDelimitedValuesBlobColumnParser
 description What are books about this language from ISBNdb?
 string sourceDomain isbndb.com
semanticScholarParser
 boolean fromCrawler true
 extends abstractDelimitedValuesBlobColumnParser
 description What are papers about this language from Semantic Scholar?
 string sourceDomain semanticscholar.org
abstractEnumColumnParser
 string typeForCsvDocs enum
 cells columnNameCell enumCell
 extends abstractTrueBaseColumnParser
fileTypeParser
 description What is the file encoding for programs in this language?
 cells columnNameCell fileTypeWordCell
 extends abstractEnumColumnParser
nativeLanguageParser
 cells columnNameCell nativeLanguageWordCell
 description What is the native human language for this language, if not English?
 extends abstractEnumColumnParser
announcementMethodParser
 description How was the language first announced?
 extends abstractEnumColumnParser
 cells columnNameCell announcementMethodCell
typeParser
 description Which category in PLDB's subjective ontology does this entity fit into?
 cells columnNameCell typeCell
 required
 extends abstractEnumColumnParser
abstractHashMapColumnParser
 string typeForCsvDocs multilineStringMap
 extends abstractTrueBaseColumnParser
 javascript
  get columnValue() {
   return this.childrenToString()
  }
abstractAnnualPopulationCountMapParser
 catchAllParser annualPopulationCountParser
 description A map of counts, one per year.
 extends abstractHashMapColumnParser
indeedJobsParser
 description How many job descriptions match this query for this language on indeed.com?
 catchAllCellType stringCell
 extends abstractAnnualPopulationCountMapParser
 contentKey query
 string sourceDomain indeed.com
linkedInSkillParser
 description How many people list this skill on LinkedIn?
 extends abstractAnnualPopulationCountMapParser
 catchAllCellType stringCell
 contentKey id
 string sourceDomain linkedin.com
abstractAnnualRankMapParser
 catchAllParser annualRankParser
 description A map of ranks, one per year.
 extends abstractHashMapColumnParser
repoStatsParser
 description What is the URL of the official GitHub repo for the project if it is hosted there?
 extends abstractHashMapColumnParser
 inScope descriptionParser
 firstCommitParser
  extends abstractYearColumnParser
  description What year the first commit made in this git repo?
 commitsParser
  extends abstractCountColumnParser
  description How many commits to the repo?
 committersParser
  extends abstractCountColumnParser
  description How many committers to the repo?
 filesParser
  extends abstractCountColumnParser
  description How many files in the repo?
stackOverflowSurveyParser
 extends abstractHashMapColumnParser
 description What is the summary of this language from the StackOverflow annual developer survey found here https://insights.stackoverflow.com/survey?
 string sourceDomain insights.stackoverflow.com
 stackOverflowSurveyYearParser
  description What are the survey results for a particular year?
  cells yearCell
  pattern \\d+
  uniqueFirstWord
  usersParser
   extends abstractPopulationCountColumnParser
   description How many developers reported using this language?
  medianSalaryParser
   description What is the median salary reported by developers using this language?
   extends abstractIntColumnParser
  fansParser
   description How many developers reported wanting to learn this language?
   extends abstractPopulationCountColumnParser
  percentageUsingParser
   description What percentage of survey respondents report using this language?
   // todo add a percentage column type that extends from float
   extends abstractFloatColumnParser
versionsParser
 description What are the release years and versions of this language?
 extends abstractHashMapColumnParser
 catchAllParser versionParser
abstractWordColumnParser
 description A single word.
 cells columnNameCell wordCell
 string typeForCsvDocs word
 extends abstractTrueBaseColumnParser
domainNameParser
 description What is the domain for this language's website if it has its own?
 cells columnNameCell domainNameCell
 extends abstractWordColumnParser
 contentKey name
 registeredParser
  extends abstractYearColumnParser
  description When was this domain first registered?
 awisRankParser
  extends abstractAnnualRankMapParser
  description What is the Alexa Web Information Service (AWIS) domain ranking?
  string sourceDomain aws.amazon.com
featureExampleCodeParser
 description What is an example that demonstrates usage of this feature?
 // Ideally includes any necessary boilerplate to be runnable.
 baseParser blobParser
annualRankParser
 cells yearCell rankCell
 uniqueFirstWord
pldbParser
 root
 description A truebase about programming languages and related concepts.
 catchAllParser trueBaseErrorParser
 // todo Should not have to manually list each node type here, but should be able to mark some tag as inscope. Should be fixed upstream in Jtree.
 inScope blankLineParser abstractTrueBaseColumnParser
 cells fileNameCell
 string fileExtension pldb
 example
  title TunaScript
  type pl
  appeared 2017
  creators Sam Lam
  example
   Hello world
 sortTemplate title appeared type isDead isPublicDomain screenshot photo demoVideo creators description website webRepl documentation devDocumentation ebook emailList spec reference cheatSheetUrl standsFor oldName renamedTo aka fileExtensions country nativeLanguage originCommunity domainName equation firstAnnouncement announcementMethod usesSemanticVersioning releaseNotesUrl proposals roadmap versions  abstractRelationshipParser  visualParadigm  abstractFeatureParser  lineCommentToken multiLineCommentTokens printToken assignmentToken stringToken booleanTokens includeToken keywords  example  gource abstractGitRepoUrlColumnParser  repoStats  funFact  wikipedia  githubLanguage githubBigQuery  antlr monaco codeMirror pygmentsHighlighter linguistGrammarRepo languageServerProtocolProject  projectEuler helloWorldCollection leachim6 rosettaCode quineRelay  compilerExplorer rijuRepl replit tryItOnline  indeedJobs linkedInSkill stackOverflowSurvey annualReportsUrl officialBlogUrl eventsPageUrl faqPageUrl downloadPageUrl  abstractChatUrlColumnParser subreddit meetup conference  hackerNewsDiscussions redditDiscussion  tiobe hopl esolang pypl  packageRepository packageCount packageAuthors packageInstallCount forLanguages  twitter ubuntuPackage gdbSupport jupyterKernel fileType wordRank isOpenSource githubCopilotOptimized centralPackageRepositoryCount  goodreads  isbndb  semanticScholar 
versionParser
 description What is the version and release year?
 // perhaps in the future we could get more specific to month. Maybe even include what new features were added.
 cells yearCell versionCell
blankLineParser
 description Blank lines are okay.
 cells blankCell
 compiler
  stringTemplate 
 pattern ^$
 tags doNotSynthesize
 boolean shouldSerialize false
trueBaseErrorParser
 baseParser errorParser
urlCitationParser
 description Can serve as a catch all for linking to a source for columns.
 cells urlCell
annualPopulationCountParser
 cells yearCell populationCountCell
 uniqueFirstWord`)
        get handGrammarProgram() {
          return this.constructor.cachedHandGrammarProgramRoot
      }
static rootParser = pldbParser
    }

class versionParser extends GrammarBackedNode {
      get yearCell() {
      return parseFloat(this.getWord(0))
    }
get versionCell() {
      return this.getWord(1)
    }
    }

class blankLineParser extends GrammarBackedNode {
      get blankCell() {
      return this.getWord(0)
    }
get shouldSerialize() { return false }
    }

class trueBaseErrorParser extends GrammarBackedNode {
      getErrors() { return this._getErrorParserErrors() }
    }

class urlCitationParser extends GrammarBackedNode {
      get urlCell() {
      return this.getWord(0)
    }
    }

class annualPopulationCountParser extends GrammarBackedNode {
      get yearCell() {
      return parseFloat(this.getWord(0))
    }
get populationCountCell() {
      return parseFloat(this.getWord(1))
    }
    }

window.pldbParser = pldbParser
};

{


class tqlParser extends GrammarBackedNode {
      createParserCombinator() {
  return new TreeNode.ParserCombinator(catchAllErrorParser, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"#" : commentParser,
"where" : whereParser,
"includes" : includesTextParser,
"doesNotInclude" : doesNotIncludeTextParser,
"missing" : columnIsMissingParser,
"notMissing" : columnIsNotMissingParser,
"matchesRegex" : matchesRegexParser,
"reverse" : reverseParser,
"limit" : limitParser,
"addColumn" : addColumnParser,
"compare" : compareParser,
"select" : selectParser,
"selectAll" : selectAllParser,
"rename" : renameParser,
"sortBy" : sortByParser,
"title" : titleParser,
"description" : descriptionParser}), [{regex: /^$/, parser: blankLineParser}])
  }
get tests() {
  const tests = this.filter(node => node.toPredicate).map(node => {
      const predicate = node.toPredicate()
      return node.flip ? (file) => !predicate(file)  : predicate
  })
  return tests
}
filterFolder(trueBaseFolder) {
  const {tests} = this
  const predicate = file => tests.every(fn => fn(file))
  return trueBaseFolder.filter(file => predicate(file))
}
static cachedHandGrammarProgramRoot = new HandGrammarProgram(`// Cells
keywordCell
 highlightScope keyword
comparisonCell
 enum < > = != includes doesNotInclude oneOf
stringCell
 highlightScope string
trueBaseIdCell
 description A global identifier for this entity in a TrueBase. Currently a very restricted character set to ensure compatibility between a wide variety of URLs and filesystems.
 highlightScope constant
 enum 05ab1e 1-pak 1620sps 1c-enterprise 2-pak 20-gate 2lisp 2obj 3-lisp 3apl 3d-logo 3dcomposer 3ds 3mf 3rip 4g-standard 4th-dimension 51forth 6gunz 8th a-0-system a-sharp a51 aadl aaf aarch64 aardappel aardvark abacus-machine abal abap abbreviated-test-language-for-all-systems abc-80 abc-algol abc abcl-cp abcl-f abcl-lang abcl abcpp abel able abnf abs abset abstract-state-machine-language abstracto absys ac-toolbox accent ace acl acl2 acme acore acorn-atom acorn-lang acorn acornsoft-logo acos acsi-matic acsl act-iii act-one actalk action-code-script action actionscript active-language-i active-u-datalog activevfp activity-pub actor actors actus ad-hoc ada-95 ada-9x ada-tl ada adabtpl adagio adam-standard adam adamant adaplex address adenine-programming-language adept ades-ii ades aditi adlib adobe-font-metrics ads-b-standard advanced-continuous-simulation-language advice-taker aed aepl aesop afnix afs agda agent-k agentspeak agl agora ags-script aheui aida aids ail aime aiml aimms air airtable-app ais aith akl al aladin alambik alan alba albatross alcor aldat aldes aldor aldwych ale alec alef aleph alf alfred algae algebraic-compiler algebraic-modeling-language algem algernon algo algobox algol-58 algol-60 algol-68-r algol-68-rt algol-68 algol-e algol-n algol-w algol-x algol algy alice aljabr allegro-common-lisp allo alloy alma-0 alma-007 alma-o alma almir almquist-shell alohanet alonzo alpaca alpak alpha-programming-language alphabasic alphapop alphard-programming-language alphard alpine-abuild alps altac altair-basic altibase altran alumina amalthea amanda amazon-dynamodb amazon-rds amber ambienttalk ambit-g ambit-l ambit ambush amiga-e amiga-programming-languages amigabasic amos amperes-circuital-equation ampl amppl-i amppl-ii amqp amtran-70 amtran amulet ana analytical-engine-machine and-or andante andorra-i andorra android angelscript angr anna ans-mumps ansi-basic ant-build-system ante-esolang ante antha antlr apache-cassandra apache-derby apache-hbase apache-phoenix apache-velocity apache apacheconf apar aparel ape100 apescript apex api-blueprint apl-gpss apl-hp apl-z80 apl apl2 aplette aplgol-2 aplgol aplo aplus aplusplus aplx apollo-guidance-computer apostle appcode-editor appl-a apple-1-machine apple-basic apple-prodos applescript applesoft-basic applog april aprol apse apt-pm apt aqasm aql aquarius-prolog arabic-numerals arablan arango-db arbortext-command-language arc-assembly arc-isa arc archi archieml arctic arden-syntax arduino arend aretext arexx arezzo-notation argdown argon argos argus arith-matic arjuna ark-lang ark arkscript arm-templates arm armani arret arrow-format arrow arta artspeak arturo arvelie-format ascii-armor ascii asciidoc asciidots asciimath asdf asf-sdf ashmedai asic-programming-language asmjs asn-1 asp.net asp aspectcpp aspectj aspen aspol assembly-language assemblyscript associons asspegique astatine asterisk asterius-compiler astlog astro astroml asymptote atari-basic atari-microsoft-basic atari-st-basic atlas-autocode atlas atmel-avr atol atom-editor atom atomese atomo atomos atomspace ats attic-numerals attoparsec atx aubit-4gl augeas augment aui aur-pm aurora austral autasim autocad-app autocode autocoder-ii autocoder-iii autocoder autoconf autodraft autogrp autohotkey autoit autolisp autoloft automast automator autopromt avail avalon-common-lisp averest avi-synth avr avro awk awl aws axcess axiom-computer-algebra-system axiom axt-format aztec-c azure b-line b b3-ir b32-business-basic b4tran babel baby-modula-3 babylonian-numerals back badlanguage bag-format balanced-ternary-notation balg balgol balinda-lisp ballerina-central-pm ballerina balm balsa baltazar baltik bam-format bamboo bancstar-programming-language bare barrel bartok base64 baseball basel bash basic-11 basic-256 basic-ap basic-e basic-pdp-1-lisp basic-plus basic-programming basic-stamp basic basic09 basic4android basic4gl basic4ppc basicode basicx basil basis-universal-format batari-basic batch battlestar bawk bayer-expressions bayes-equation baysick bazel bbc-basic bbcode bbj bbn-lisp bbx bc-neliac bc bcpl bcx bdl beads-lang beagle beam-bytecode beam-vm beanshell beatnik beautiful-report-language bebasic bed-format bedsocs bee beebasic beef-lang beef beflix befunge behavior-markup-language bel-lang bel ber berkeley-db-lib berkeleydb berry besys beta-basic beta-project beta-prolog beta bgraf2 bhsl bibtex bicep biferno bigloo bigmac bigwig-format bigwig-programming-language bigwig binary-equation binary-ninja binary-notation binaryen bind-app bioconductor-pm biomod bioscript biossim biplan bird birkbeck-assembly bison bisonpp bistro-programming-language bitarray bitbake bitc bizubee bjou bla blackcoffee blacklight blade-lang blade blake-hash-function blank blaze-2 blaze blazex blc blender-app bliss blitz3d blitzbasic blitzmax blitzplus blockly blockml bloom blooms bloop blox blue-programming-language blue blueprints bluespec blur-markup-language blz bmd bml bmp-format bnf boa bob bog boil bolin bolt bon-programming-language boo boogie boomerang-decompiler boost-lib booster borneo boron bosque bossam bounce-lang bounce bourne-shell boxer boxx bpel bpkg-pm bpl bpmn bpn2 bqn brackets-editor brain-flak brainfuck breccia bridgetalk brightscript-lang brisk brl bro broccoli-1 broccoli-2 broccoli brooks-programming-language brouhaha brown-university-interactive-language bscript-interpreter bscript bsml bsp bucardo bucklescript buddyscript bugsys bullfrog bun bush business-application-language business-basic business-object-notation business-process-modeling-language business-rule-language butterfly-common-lisp buzz bx bytecode-modeling-language bytelisp bython bywater-basic c-- c-al c-cubed c-flat c-for-all c-headers c-shell c-smile c-talk c c2 c3 ca-realizer ca-telon ca65-assembly cabal cache-basic cache-objectscript cactus cadence-skill cado-systems-technical-information cafeobj caffeine cages caisys cajole cal calc-var calc calc4 cali-lang caltech-intermediate-form calypso cam camac camal camil caml candor candy-codes candy cane canon-capsl cantor capn-proto capsl capsule capybara caramel carbon carp carpet carth cartocss casio-basic cassandre cat catala catalysis categorical-query-language cayenne cayley cbasic cbor ccal ccd ccel ccr ccs cda cddl cdf cdl cdlpp cecil cedar-fortran cedar ceemac celip cell cellsim celsius-webscript ceprol cesil ceu ceylon cfengine cfml cfscript cg cgol ch chain-format chain-programming-language chained-arrow-notation chaiscript champ chaos-lang chapel chappe-code charcoal charity charly charmpp charrette-ada chartio-app charybdis chatterbot checked-c checkout cheetah chef chemtrains cheri chevrotain chibicc chicken-lang chicken chicon chika chill chimera chinese-basic chip-8 chip-programming-language chipmunk-basic chirp chisel chocolatey-pm chomski chrome-programming-language chronolog chronologmc chronologz chrysalisp chuck ciao-programming-language ciel cif cigale cil cilk cimfast cims-pl-i cir circa circal circle-lang cirru cish cito citrine cityhash-hash-function cixl cl-i claire clamp clanger clarion clarity claro clascal clash class classic-ada classic clausal-lang clay clean cleanlang clear cleo cleogo cleopatra cli-assembly click clickpath clike clion-editor clipper clips clisp clist clix cloc cloe clojars-pm clojure clojurescript clos closure-templates cloud-firestore-security-rules clover clox clp-star clpr clu clx cmake cmix cmn cms-2 cms-exec cms-pipelines cmu-common-lisp co-dfns co2 cobloc cobol-net cobol cobolscript cobra coco-r coco cocoapods-pm coconut coda-editor code-blocks-editor codecept codeflow codegear-delphi codelite-editor codemirror codeql codil coff coffee-cinema-4d coffeepp coffeescript cogmap cogo coherence coherent-parallel-c coi-protocol cokescript col colascript colasl cold-k coldfusion-components coldfusion collada color-basic colorforth comal combined-log-format comby comfy comit comm commen commodore-basic common-lisp common-log-format common-workflow-language commonloops commonmark compact-application-solution-language compiler-compiler complex-prolog component-pascal computer-compiler computest comskee comsl comsol-script comtran cona conan-center-pm conan-pm conc concept-script conceptual concert-c concise-encoding concordance concur concurnas concurr concurrent-cpp concurrent-metatem concurrent-ml concurrent-pascal concurrent-prolog cone confluence congolog conlan conll-u conman connection-machine-lisp connection-machine conniver consim constraintlisp constraints consul context-diff contracts.coffee contrans converge convert cooc cool coordinate-format copas cope copilot coq cor coral-64 coral-lang coral coralpp corbascript corc corelscript corescript corman-common-lisp cornell-university-programming-language corvision cosh cosmicos cosmo cosmos cotton couchbase-mobile couchbase couchdb coulombs-equation cowsel cp cpan-pm cperl cpl cpp cql cqlf cqlpp crack cram-format cran-pm cranelift-ir crates-pm creative-basic crema creole crmsh croc croma crush cryptol crystal cs-script csa csharp csl csmp cson csound csp-oz-dc csp-oz csp cspydr css-doodle css cssa cst csv csvpp csvw ct ctalk-lang ctalk ctan-pm ctr cubase cube cuda cuecat cuelang culler-fried-system cullinet cuneiform cupid cupit-2 curl curly curry curv cuscus cusip cvl cweb cx cyber cybil cycl cyclone cycript cymbal cypher cyphertext cython cytosol d-data-language-specification d d2 d3 d4-programming-language d4 dad dafny dag daisy-systems dak dale dalvik-bytecode daml-oil daml damn daonode dap-algol dap-fortran daplex darcs-patch darkbasic darklang dart-pm dart dartcvl dartmouth-basic das dashrep dasl dasm dat-protocol data-access-language data-general-business-basic data-text databus dataflex datafun datalisp datalog datan datapackage datapoint-dasl datascript datatrieve dataweave datev datomic dax dbase dbml dc dcalgol dcat dda ddfcsv ddfql ddml de-bruijn-index-notation deacon deb debl debuma dec64 decision-model-notation declare dedukti deesel definite-clause-grammar-notation del delirium delphi delta-prolog dem demeter demos dendral deno dependent-ml dern descartes descript descriptran desktop desmos detab-65 detab-x detap deva device-independent-file-format devicetree devil dex dexterity dexvis dfl dfns dgraph dhall diagram dialog diamag diana dibol dice diet diff differential-datalog digital-command-language digraf dinkc dinnerbell dino dio dipe-r diplans disc dispel displayport-standard distributed-processes distributed-smalltalk ditran ditroff-ffortid ditroff dixy django djangoql djot dkim-standard dllup dlp dlvm dm-1 dm dmap dml dna dns docker dockerfile docopt doe-macsyma dog dogescript doh doi dojo dokuwiki dolittle dollar-sign dolphin domino doml doodle dopl dot-product-equation dot-ql dot dowl dpp dprl draco-programming-language draconian dragonbasic dragoon drakon dreamlisp dribble drl drol drupal dscript dsd dsl-90 dslx dss dsym dtd dtrace dts dual dub-pm duel duro durra dvi-standard dwg dxf dylan dynamo-pm dynamo-visual-language dynamo dystal dyvil e eagle earl-grey eas-e ease easl easy-english easy easybuild easylanguage easytrieve ebg ebnf ec ecl eclectic-csp eclipse-command-language eclipse-editor ecmascript eco-editor ecological-metadata-language ecr ecsharp ect ed-editor eden edge-side-includes edgedb edgelisp edgeql edh edina edinburgh-imp edinburgh-lcf edison edje-data-collection edn edsac-initial-orders edscript edsim educe-star educe eex eff efl egel egison egl egs4 eiffel ejs el1 elan elastic-query-dsl election-markup-language electre elegance elegant elena elf elfe elixir ella-programming-language ellie elliott-algol ellpack elm-packages-pm elm elmol elpa-pm elpi elvish elymas em emacs-editor emacs-lisp emberjs-framework emberscript emerald-lang emerald emesh emfatic emily emma emojicode emoticon empirical emu encore energese-notation energy-momentum-equation english-programming-language eno enso-lang enso enterprise-mashup-markup-language entropy envoy-app epigram epilog epsilon eql eqlog eqn eqs equate erb erg erlang errol esc-p escapade-programming-language eskew esoteric-reaction esp espol esterel eta etc ethereum-vm ethernet etoys etruscan-numerals etude euboea euclid euclidean-geometry euler eulers-equation eulisp eumel euphoria eurisko eva eve everparse3d ex-editor exapt excel-app exec-2 executable-json exel exfat exkited expect explan explor explorer express expresso ext ext2 ext3 ext4 extempore extended-ml extended-pascal extensible-embeddable-language extran ez ezhil f-prime f-script f-sharp f fable-lang fable fac facelets fact-lang fact factor fad falcon false family-basic fancy fantom fap far faradays-induction-equation farcaster fardlang fast-fourier-transform-equation fasta-format fastq-format fasttrack-scripting-host fat faust fawlty fay fcl fcpu fe feel felix femtolisp fen-notation fenix-project fennel ferite fern ferret fetlang feynman-diagram ffmpeg fhir fibonacci-notation fibonacci fickle figlet-font filebench-wml filetab-d filetab filterscript firebase firefox firrtl fish fishlang fizz fjolnir fjs fl flacc flagship flame-ir flang flapjax flare flatbuffers flatline flavors fleck flengpp flex-lang flex flexbuffers flexml flic flix floorplan flora floral floscript flow-matic flow flow9 flowchart-fun flowcode flowgorithm flowlog flownet flownote flua flutter-framework flux-lang flux fm-standard fmj fml-lang fml fo foaf focal focus foil foogol foral-lp foral forall forest-database forest-lang forgebox-pm fork-lang fork fork95 formac formality formatted-table forml forms-3 formula forte-4gl forth forthnet-pm forthscript fortran-77 fortran-8x fortran-90 fortran-cep fortran-d fortran-ii fortran-iii fortran-iv fortran-m fortran fortransit fortress fossil-scm foundry fox foxpro fp fp2 fp3 fpgac fpp fractran frame framework-office-suite fran frank-lang frank free-pascal freebasic freebsd freefem freemarker frege frenetic fresco frink frost frtime fructure-editor fsl fstar ftp fun function-block-diagram funl futhark futurebasic futurescript fuzuli fuzzyclips fx-87 fxml fxscript g-2 g-code g-expressions g-fu g-portugol gaea gaiman galaksija-basic galileo gambas game-maker-language game-oriented-assembly-lisp game gamemonkey-script gamerlanguage gaml gams gap gargoyle garp gas gasp-ii gasp gat gauche gauss-flux-equation gauss-magnetism-equation gaussfit gcc-machine-description gcc gcla-ii gcp gdata gdb gdl gdpl gdscript geany-editor gecko gedanken gedit-editor gel gellish gello gem gema gemini-protocol general-algebraic-modeling-system generate-ninja generic-haskell generic genero genexus genie genius-extension-language genshi-text genshi genstat gentee gentoo-ebuild gentran-90 gentran geo-ml geogebra geojson george gerald gerber-image gerbil germinal gettext gfa-basic gff-format gfoo gforth gfs ghc gherkin ghidra-decompiler ghostscript gif-format gimple gintonic giotto gist git-config git gitignore gks glbasic gleam glicol glide glish glitch-editor glms gloss glpk-lib glsl glu glue-nail gluon glush glyph-bitmap-distribution-format glyph gnome-basic gns gnu-e gnu-rtl gnuplot go-bang go goal goby godel godot-game-engine gofer gogs-editor gold golfscript golo golog google-apps-script google-cloud-mysql google-cloud google-data-studio-app google-sheets-app goose gopher-protocol goql gorillascript gospel gosu gp gpds gpgs gps gpss-360 gpss-85 gpss-fortran gpss gql graal grace grad-assistant gradle grain grammar grammatical-framework graph-it graph-modeling-language grapheasy graphics-basic graphlog graphml graphos graphql-plus-minus graphql-sdl graphql graqula grass gravity-equation gravity greek-numerals green greenplum gremlin gren grep grid-notation gridstudio-editor grin grml groff groove groovy-server-pages groovy grouplog grunt gsbl gsql gtf-format guide guido-music-notation guile guix gura guru gvl gw-basic gwion gwl gxl gypsy gzip h-lang habit hac hack hackage-pm hackett hackppl hacspec haggis hakaru hal-format hal-s halide ham hamdown haml hamler hancock handel-c handlebars hank harbour hare harlan harvey harwell-boeing-format hascript hashlink haskell-sharp haskell hasklig hasl haste haxe haxelibs-pm haystaq hazel hbasic hcard hccb hcl hdf hdfs hdmi-standard hdt heap.coffee hecl hedy heic helang helena helium hello helper henk heraklit herbrand hermes heron-lang heron hex-pm hex-rays hexagon hexagony hfs-plus hfs hhvm hi-visual high-tech-basic highlightjs hilbert hilltop-lang hilvl hina hiq hivemind hiveql hjson hl7 hla hlasm hlsl hlvm hmmm hmsl hobbes hocon hodor hol holcf holo holonforth holyc homa homebrew-pm homespring honu hook hoon hoot-smalltalk hop hope hopscotch horse64 hotcocoalisp hotdog hp-basic-for-openvms hp-gl hp-pascal hp-time-shared-basic hpp hprl hr-code hrqr hsaml-format hscript hsl hsml hspec htel html htmx http-2 http-3 http httplang huginn hugo hujson humanhash-hash-function hummingbird-quickscript hurl hush huwcode hxml hy hybrid hycom hypac hyper-basic hypercard hyperflow hyperfun hyperlisp hyperlog hyperscript-lang hyperscript hypertalk hyphy hytime hytran i-expressions i ia-32 ial iam ib-templog ibex ibm-1401-symbolic-programming-system ibm-basic ibm-basica ibm-db2 ibm-gml ibm-i-control-language ibm-logo ibm-rational-sqabasic ibm-rpg ibm-system-38-language ibuki-cl icalendar-format icarus icd icedcoffeescript ices-system icetran ici icml icon icot id idio idl-sl idl idris ids idyll ifo ifps igor-pro iif iikuse iitran ikarus ilbm ilu ilx imac-machine image imaginary-number-equation imandra imap-protocol imba imf imp-lang imp imp72 impala impl ina-jo inc inchi incipit indental infer infiniband-standard influxdb infolog inform information-algebra information-processing-language information-theory-equation informix infusion-framework ingres ini ink-lang ink inko inmagic inno-setup inquire inscan insight insitux instruction-list integer-basic integral-equation intellijidea-editor interactive interbase intercal intercellas interchange-file-format intercons interleaved-notation interlisp-vax interlisp interpress interscript intersystems-cache intuitionistic invokator io iode ioke ion-schema ion ios iota-and-jot iota ip-pascal ipad-machine ipf ipfs iphone-machine ipl-v iptables-rope iptscrae ipv4 iqf iqr irc-log ircis isabelle-91 isabelle-hol isabelle isac isbl isbn iscript isetl isis islisp iso-8601 ispl isq iswim it iterm2 itl ivtran ivy ixml izibasic j jacal jacl jade jai jakt jal-compiler jammy janet jank janus-lang janus-programming-language jargon jasmin jasmine jasper jass java-bytecode java-ee-version-history java-properties java-server-pages java javacc javafx-script javaml javascript javascriptcore jaws-scripting-language jayfor jazz jbc jcard jcl jcof jean jedit-editor jedlang jeebox jeeves jekyll jelly jesth jet-propulsion-laboratory-display-information-system jevko jflex jfugue ji jingo jinja jinx jis-x-0201 jison-lex jison jisp jiyu jlang jmap jmespath jmp jmsl joe-e join-java joker jolie jonprl josie joss-ii joss joule jovial joy joyce joycep jpeg-format jpl jplace jpp jq jql jquery jr jruby jscript jsf jsgf jsharp jsil-compiler jsl jslt jsml json-graph-format json-graph-spec json-lambda json-ld json-schema json-script json-stat json-url json-with-comments json json5 jsoniq jsonnet jsparagus jspp jsx jsyn judoscript juicy jule julia-lang julia juliahub-pm juniper juno jupyter-editor jupyter-notebook just juttle juvix jvm jython k-framework k kaffeine kaggle-app kai kail kaitai kakoune-editor kal kaleidoquery kaleidoscope kaleidoscope90 kaleidoscope91 kalyn kamby kami kamilalisp kaml karel karl kasaya kate-editor kate katex kaukatcr kavascript kawa-scheme-implementation kayia kb kee kefir kei kek-nodal keli keras kerf kermeta kernel-e kernel kew keykit keysight-vee khepri ki kicad kid kiev kilo-lisp kima king-kong kiss kit kitlang kitten kivy-lang kixtart kl-one kl0 kl1 klaim klerer-may-system klipa klisp klong kml knight knitr knowledge-interchange-format ko koara kodu-game-lab kogut koi koka komodo-editor kona konna konsolscript korn-shell kotlin kqml krc kris krl-0 krl krs krypton ktexteditor-editor kubernetes kuin kuka kumir kuroko kvikkalkul kvsapi kylix kyma l l2 l6 labtran labview ladder-logic lagoona lain lambcalc lambda-obliv lambda-prolog lambda-zero lambda lamderp lamdu-editor lamdu lamina lammps-format lanai language-for-class-description language-h language-server-protocol laning-and-zierler-system lap laravel-framework larceny larch laris larp lasp lass lasso latex latino latte-js latte laure lav-format lava lawvere lazarus-editor lazy-k lazyml lc-3 lcf lcl ld-json ldap ldl ldl1 ldpl le-lisp leaf lean leap leazy leda legol lem-editor lemick lemon leo-editor leogo leopard les lesk lesma less lever levy lex lexon lexx-editor lezer lfe lg lgdf li-chen-wang liberty-basic libra libsvm-format life lift lighttpd-configuration-file ligo lil-pl lil lila-lang lila lily lilypond limbo limdep linc-4gl lincoln-reckoner lincos linda linden-scripting-language linearml lingo lingua-graphica link linked-markdown linker-script links-programming-language links linktext linoleum linotte linq linux-kernel-module linux liquid liquidity lis lisaac liseb liso lisp-1-5 lisp-2 lisp-a lisp-machine-lisp lisp lispme lisptalk lispworks lispyscript listdown lite-c literate-agda literate-coffeescript literate-haskell litescript lithe little-b little-smalltalk little livecode livescript livr lkif llhd lll lllpg llvmir lmdb lnf lo lobster local loci locomotive-basic locs logal logica logicon login logist loglan loglisp loglo logo logol logos logowriter logres logscheme logtalk lol lola-2 lola lolcode lookml loom loomscript loopnpp loops lore lorel-1 lorel lotis lotos lotusscript lowstar lpc lpl lrltran lsd lse lsif-format lsl lua luajit luarocks-pm luau lucene-query-syntax lucid-chart-app lucid-lang lucid-representations lucid lucinda luna-1 luna lunar lush lustre lux lyapas lygon lynx lyric lyx-editor m-expressions m-lisp m-programming-language m2001 m3db m4 m4sugar mac macaims macbasic macbook-air-machine macchiato mace machiavelli macintosh-common-lisp macintosh-machine macro-10 macro-11 macro-spitbol macro macroml macsyma mad madcap-vi madcap mads mages magic-paper magik magit magma magma2 magritte mai-basic-four mai make makedoc makefile mako mal malbolge mallard-basic malus mama-software man-machine-language manchester-syntax mangle manhood manim manool manticore manuscript map mapbasic maple maplesoft-app-center-pm mapper mapquery maps maraca-lang margin maria-db-column-store maria-xml mariadb mark-iv markdeep markdown marklogic marko markovjunior markus markwhen marlais marmot marp marsyas marten mary-2 mary mascara masim maskjs masm mass-energy-equation material-exchange-format math-matic mathcad mathematica-editor mathematica-packagedata-pm mathematica mathics mathjax mathlab mathlingua mathml mathpix-markdown mathsy mathtype mathworks-file-exchange-pm matita matlab matplotlib matrix-pascal matrix-protocol maude maven-pm maven-pom mavis mavo mawk max maxima maxscript maya mbasic mbox mckeeman-form mcleyvier-command-language mcobol md5-hash-function mdbs-qrs mdl mdx-lang mdx meanscriptcli mech-lang mediawiki medic medusa megalog megaparsec meld melody melpha-pm memcached memex-machine mendel mentat mercurial mercury-programming-system mercury merd mermaid meroon mesa meson messagepack met-english meta-assembler meta-ii meta-lisp meta-plus metacomco metafont metah metal-programming-language metal metalang99 metalex metaml metapi metapost metasim metatem metaweb-query-language methodology-description-language mewl mewmew mgmt mheg-5 michelson micro-cpp micro-editor micro-flowcharts micro-mitten micro-prolog microarchitecture-description-language microdare microdata microl microplanner micropython microsoft-access microsoft-azure-cosmos-db microsoft-basic microsoft-equation-editor microsoft-macro-assembler microsoft-mysql-server microsoft-small-basic microtal midas miis mike mime mimic mimium mimix-stream-language min minc mini-ml minid minidsdb minihaskell minikanren minilang miniml-error miniml minion miniprolog minivital minizinc minopt mint mips mir mirager mirah miranda miranim mirc mirfac mirth miso-framework miva mizar ml mlab mlatu mlir mlisp2 mlite mlpolyr mmix mmsearch mmx mobl-lang mobl moby-programming-language mochajs mochi mockingbird-notation mocklisp modcap model-204 model-k modelica modl modlisp modsim-iii modula-2 modula-2p modula-3-star modula-3 modula-p modula-r modula modular-prolog module-management-system moescript moinmoin mojo molecular-query-language molfile-format molog monaco mond monesa mongodb monkey monodevelop-editor monte moo mool moonrock-basic-compiler moonscript moose morfa morfik morphe morphism morse-code mortran motif-software mountain mouse mouse4 moxie moya mp3-format mpgs mpl mps mpsx mql mqtt mrdb ms2 mscgen msg-84 msl msp430 msx-basic mtml mu muddl mudlle muf mufp mul-t multi-user-basic multiaddr multibase multicodec multics multigame multihash-hash-function mumath mumps mums mun-lang munin muon mupad murmur-hash-function mushroom music-sp musicxml musimp musp mustache musys mvel mvl mxml mybb mycroft myghty myia mypy myrddin mys mysql mythryl n-prolog n-triples n nadesiko nail nakl nano-editor napier88 napss narpl nasal nasm nassi-shneiderman-charts native-structured-storage nato-phonetic-alphabet natural navier-stokes-equation nawk ncar-command-language ncl ndl nearley neater nebula nectar neeilang neko neliac nelua nemerle neo4j neovim-editor neralie-format nesc nesl ness nested-context-language nestedtext net-format netbasic netbeans-editor netform netlib netlinx netlogo netrexx netscript network-control-language neuronc neut neutron never newclay newick-format newlisp newp newspeak newsqueak newton newtonscript nexml nextflow nexus-format nfql nginx-config ngl-programming-language ngql ngs nhx nial nianiolang nice nickle nikl nil nilscript nim nimble-pm nimrod nimskull ninja nios nirvana nit nix nixos njcl nl nlpl nltk nml noah nodal nodejs noisecraft nomad-software noms-db none noodle nop-2 nord normal-distribution-equation northstar-basic nosica notation3 note notepad-editor notepad-plus-plus-editor noulith nova-editor noweb np npl-lang npl npm-pm npy nqc nrl nroff ns-basic nsis nsl ntfs ntp nu-prolog nu nua-prolog nuget-pm nul-lang nulan numba numbers-app numerica numpad numpy nuprl nushell nut nuua nvdl nwscript nxc nxt-g nydp nylo nymph nyquist o-matrix o-xml o o2 o42a oak oaklisp oasis-operating-system oasis oberon-2 oberon obj obj2 objdump object-definition-language object-oberon object-pascal object-query-language object-rexx object-z objectcharts objective-c objective-cpp objective-j objective-modula-2 objective-s objectlogo objectpal objectscript objectworld objvlisp objvprolog obliq obscure observable-lang obsidian ocaml occam-2 occam-pi occam ocl octave octopus octune odata odbc oden odin odrl oem ofl oforth ofx ogdl ognl ohaskell ohayo ohm oil ok oldas ole-protocol olga oli oliver olog om omar omega ometa omg-idl omgrofl omikron-basic omnimark omnis-studio omnitab-80 omnitab-ii omnitab one-man-language onex oniguruma onnx onyx ooc ook oolp oopal oops oopsilon oopsp ooxml opa opal opam-pm open-nn open-shading-language openada opencl opencomal opendoc-protocol openedge-advanced-business-language openexr-format opengl opengraph openlisp openmusic openrc-runscript openroad openscad openspice opentype-feature-file openvera operational-control-language operon opl-langage-informatique opl opp ops-3 ops ops5 optimization-programming-language optimized-systems-software optimj oracle-java oracle orange orc-format orc-lang orca-lang orca-pl orca order oregano org orient-db orient84-k orlog osiris osl-2 osql ottawa-euclid otter owbasic owen-lang owl-dl owl ox oxide oxygene oxyl oz p-cl p-prolog p-star p-tac p p3l p4 p4p package-control-pm packagist-pm pacmanconf pacol pact-i pact-ia pact pactolus padl-1 pailisp paisley palasm palcode palingol pamela pan pancode pandas pandoc-app pandora panon-1 panon-1b panther-lang paperalgo papyrus par paragon parallax-propeller parallel-ellpack parallel-pascal paralog-e parasail parasolid parenscript parenthetic pari-gp parlog parmod parquet parrot-assembly parrot-basic parrot-internal-representation parrot-vm parse-tree-notation parser partiql pascal-abc.net pascal-fc pascal-i pascal-mtp pascal-plus pascal-s pascal-sc pascal-script pascal-xsc pascal pascals-calculator-machine pasion pasro passambler passerine pasukon patch patchwork path-pascal pawn-scripting-language pawn paxscript pbasic pbm-format pbt-omega pclos pcn pcol pcpp pcrap pcre pdel pdf pdl-ada pdl pdp-11-machine pear-pm pearl pearscript pearson-correlation-coefficient-equation pebble peg pegasus-autocode pegjs pei penguor penrose peoplecode pep pep8 perfectscript peridot perl-6 perl-data-language perl petr pfort pfortran pgbouncer pgen pgm-format pgolog pgql pharen pharo phel phigs phocus phoenix-object-basic phorth php phpstorm-editor phylip phyloxml-format physictran pi-calculus pic-microcontroller pic picasso picat piccola pick-operating-system pickcode pickle-format pico picolisp pict pictol picturebalm pie-lang pie piet-programming-language pig pikachu pike pikelet pikt pilib pilot pin pinto pipelines pisc pit pixin pizza pkgconfig pl-0 pl-11 pl-as pl-c pl-exus pl-i-formac pl-i-subset-g pl-i pl-ll pl-m pl-p pl-s-ii pl-s pl-sql pl-x pl360 pl4 placa plaid-programming-language plain-english plain plam plan2d planguage planit plankalkul planner-73 planner plantuml plasma playground plb please-build please plex plexil pliant plink-bed-format plink-bim-format plink-fam-format plink-map-format plink-ped-format plist plot-lang plot plpgsql pluk plum plumb plunk plus plush plz pm2 pml png-format pnuts po pocket-smalltalk pod pod6 pogol pogoscript pointless polac polly poly polyglot-compiler polylith polymath polymorphic-programming-language polyp polytoil pomsky pony pop-11 pop-2 pop-pl pop-protocol popasm popcorn-linux poplog popr popsy port-alg portable-standard-lisp portal-langage pose post-canonical-system post-x postcss postgresql postscript potential potion pov-ray-sdl power-bi-app power-query-m powerbasic powerbuilder powerhouse-programming-language powerisa powerlanguage powerloom-knowledgebase powerpc powershell-gallery-pm powershell ppm-format pqq praat-script praxis-lang praxis preferred-executable-format preforth presto price-equation principle-of-sufficient-reason prism prisma-schema-language prismjs priz pro-star-c probevue proc-procedure-language processing processor-technology procfile procol prodel profit progol prograph progres progsbase proiv project-mentat prolog-d-linda prolog-elf prolog-iii prolog-kr prolog-linda prolog-pack-pm prolog prologpp promal promela prometheus prompter promql property-specification-language prophet proplan proset prosper protel proteus-programming-language protium proto-gnosis protobuf protos-l protosynthex proverif-lang providex prow proxy prql ps-algol psather pseint psg psi psl psyche-c psyche psyco pt ptx public-key-file pufft pug pumpkin punched-tape punycode puppet pure purebasic puredata purescript pursuit-pm push pv-wave pvs py pycharm-editor pycket pygmalion pygments pyke pypi-pm pyret-lang pyret pyrex pyth pythagorean-equation python-cl-compiler python-for-s60 python-format-spec python pytorch q-equational-programming-language q-gert q-sharp q qa4 qalb qas qb64 qbasic qbe qcl qed-editor qed-lang qfx qif qlisp qmake qml qoir qore qr-code qt qtscript quadril quaint-lang quaint quake quakec quanta quel query-by-example quexal quick-macros quickbasic quicklisp-pm quicksight-app quikscript quiktran quilt qunity quorum qute quty r r2ml r3 r4 ra rack racket raco-pm radish ragel rails rainbow raku ralph ramdascript ramen ramis-software raml rand-abel rant rapid rapidbatch rapidgen-rpl rapidq rapidwrite rapira raptor raptorjit rascal rascalmpl rason rasp ratfiv ratfor ratsno ravenscar-profile razor rbasic rbs rbscript rc rcpp rdata-format rdf-schema rdf rdfa rdml rdoc rds-format react-native readable-lisp readable real-time-cmix real-time-concurrent-c real-time-euclid real-time-mentat realbasic reason rebeca-modeling-language rebol rebus rec-sm rec-studio recfiles recol red-lang red redcode redis redpanda-app redprl redscript redshift reduce ref-arf refal refer refined-c reflex-framework reflisp reforth regent regex regina regulus reia reko-decompiler rel-english rel-lang rel relational-data-file relational-production-language relationlog relax relaxng relfun relix remix ren-c ren-notation renderman-shading-language renderscript renpy report-writer-language rescript resharper-editor rest restructuredtext retdec retroforth reuse-description-language reverse-polish-notation revit-app revolution-programming-language rexon rexx rf-maple rfc rgb-format rhet rhine rholang rhoscript rhtml ricscript rider-editor riff rigal rigc ring rio ripple risc-v rise rita rlab rlisp rlmeta rlox rmarkdown robic robomind robot-battle robotalk robotc robotframework robots.txt roc rocket rockstar-rkt rockstar rocky-mountain-basic roff roku-brightscript rol rol2 roman-abacus-machine roman-numerals ron roop root-format root-lib ros-msg roscoe rosetta-2 rosetta-smalltalk rosette-lang rosette rosie roslyn-compiler rouge roy royalscript rpg-ii rpg-iii rpl-lang rpl rpm-package-manager rpm-spec rpp rpscript rpython rql rsharp rsl rss rstudio-editor rt-aslan rt-cdl rt-z rtf rtl-2 rtp-protocol ru ruby-document-format ruby-mine-editor ruby rubygems-pm ruleml run-basic runcible runescript runic runiq runoff runrev ruri russell rust-hir rust-mir rust rustscript ruth rye s-algol s-expressions s-lang s-plus s-sl s-snobol s s2 s3 sa-c-programming-language sa saal sac-1 sac-2 sac-programming-language safari sagemath sako sale salem salsa saltstack sam-coupe sam-format sam76 saml sampletalk saol sap-hana sapphire sarl sartex sas sasl-programming-language sass sassy sather-k sather satysfi saustall savi sawzall sb-one sba sbasic sbcl sbml sbol scala-js scala scalpel scaml scan scat scenic schemal schemaorg schematron scheme-2-d scheme school schoonschip schrodingers-equation scieneer-common-lisp scikit-learn scil-vp scilab scipy scl sclipting scm scoop-pm scoop scopes score scrapscript scratch scratchpad-ii scratchpad screamer scribble scribe scrimshaw script scriptbasic scriptease scriptol scriptx scroll-lang scroll scsh scss sdf-format sdf sdl sdlbasic sdms sdtm search sectorc secure-operations-language sed seed7 segras self semanol semi-thue-system semicolon semver send-standard sensetalk sentient seph-programming-language sepi seq seque sequel-2 sequencel sequential-function-chart sequential-pascal serious service-modeling-language sespath sespool set-builder-notation setl setlog setlx setun seval seymour sgml sh sha-1-hash-function sha-2-hash-function sha-3-hash-function shacl shadama shade shaderlab shadow shakespeare-programming-language shakti sham shapefile shapeup shared-prolog sharpscript sheep-lang sheep sheerpower4gl shen shex shift shill shiv shml shoe short-code-computer-language shrdlu si-library si sibelius-software sibilant sidopsp sierra sieve sigma-76 signal sil sile silk sill siman-iv siman simcal simcode simdis simfactory simit simkin-programming-language siml-i simnet simodula simons-basic simpas simpl simple-binary-encoding simple-stackless-lisp simple simplescript simplictiy simpp simscript simul simula-67 simula simulink sina sinclair-basic sing-sharp singular siphash-hash-function siprol siri sisal sisc sitemap sixten sizzle sk8 sketchpad-iii sketchpad skew skil skip skookumscript skulpt sky sl sl5 slam-ii slang slash sleuth slice slick slideshow slim-framework slim-pl slim slip slips slog slony slope slpl smalgol smali small-c small-euclid small-x small smallbasic smalltalk-76 smalltalk-80 smalltalk-mt smalltalk-v smalltalk-yx smalltalk smalltalkhub-pm smallvdm smart smartgameformat smarts smartsheet-app smarty smdl smile smiles-format smithy smoke smolcs smpl smsl smt smtp smx-computer-language snakemake snap snaptag snbt snit snobat snobol snobol3 snobol4 snoop snostorm snowball-programming-language snowman-decompiler snql soap soaplang soar-ml social-networks-query-language socialite solaris-pm solaris solid solidity solmar son sophia soql-lang soql sora sorca sort-merge-generator sosl souffle soul soulver souper sourcelair-editor sourcepawn sourcetree southampton-basic-system sox soy sp-k space sparc spark-pl spark-pm spark sparqcode sparql spatial speakeasy spec-sharp spec specl specol specrtl speedcoding speedie spf-standard spice-lisp spice spider spiderbasic spidermonkey spil spill spin spip spir-v spir spiral spitbol spl splaw spline-font-database split-c sporth sprint sprite-os spry sps spss spyder-editor sqhtml sql-92 sql-psm sql sqlalchemy sqlar-format sqlite-storage-format sqlite sqlmp sqlpl sqr sqrl square squeak squidconf squiggle squire squirrel squoze squrl sr-programming-language sr srecode-template srl srv ssb ssc-pm ssharp ssi ssl-lang ssl ssml stacklang stackless-python stage2 stalin stan standard-lisp standard-ml staple star-prolog star starlark starlogo staroffice-basic starpial stata statebox statemate static-typescript statsplorer status-quo-function status-quo-script steinhaus-moser-notation stella stencil stl stockholm-format stoical ston stonecutter stoneknifeforth storymatic storyscript stos-basic strand-programming-language strat stratego strcmacs streamit streem strema stress string-diagrams-notation stringbean stringcomp stripe strips strongtalk structured-storage structured-text strudel strudl struql stutter-lang stx stylus sub subl subleq sublime-editor sublime-syntax-test sublime-syntax subrip-text subscript subtext subversion subx sue sugar sugarj sugarss sugartex sugi summer sun-raster-format suneido superbasic supercollider superforth superjson supermac superplan supertalk superxpp surge svelte svg svgbob svl sw2 swagger swallow sweave sweet-expressions sweetjs swi-prolog swift-il swift swizzle swrl swym sybyl-notation symbal symbmath symbol symbolic-assembly sympl sympy synapse synchronized-multimedia-integration-language syndicate synergist synglish synon synproc syntex syntol sysml system-v-abi systemverilog systemz t-lang t t2b t3x tab tablam tablatal tableau-app tablog tabloid tabsol tabtran tac tacl tacpol-programming-language tactics tads taf tahoe-lafs taichi taijilang taktentus tal tale tall tamgu tampio tangledown tao-lang tao tao3d tap-code tap taql tarmac tarot tasm tawa taxa taxis tbox-lib tcc tcl tcoz tcp tcsh tcsp tdfl tdms tea-pl tea-pm tea teal teasharp teco tefkat tektronix tela telcomp telefile-assembly telnet-protocol telos telsim templar template-attribute-language tempo temporal-prolog ten tengo tensorflow teradata-aster teradata tern ternary-notation terra terse tetra tetruss-app tex texpr text-executive-programming-language textadept-editor textframe texti textile textmate-editor texy tfl the-message-system theos-multi-user-basic thinbasic thinglab think-c thorn threaded-lists thrift tht thue-programming-language thune thymeleaf ti-89-basic ti-basic-assembly ti-basic tibbo-basic tibet tick-c tics tidb tiddler tiddlywiki tidyverse tiff-format tiger-basic tikiwiki tiledb tilton timber-programming-language timed-csp timpani tinkertoy tiny-basic tinyc-compiler tinygo-compiler tiscript titan titanium tl-isa tl tla tlc tldr tls tmg tmlanguage tmtp toadskin todotxt toffeescript toi toki-sona tom-oopl tom tomal toml toolbus toontalk topaz-lang topaz topshell torchscript tornado tosh touch touchdevelop toy-lang tpdl-star tql trac trace trafola-h traits tramp tranquil transact-sql transaction-language-1 transcode transforma translang tree-annotation-operator treelang treenotation treesheets treet trellis tremor-query trex tridash trig-syntax trio triple triroff triton troff tromp-diagrams trs-80-color-computer truck true-basic truth ts tsar tscript tsl tsql2 tsquery tsv ttcn ttm ttsneo tuple-space tuplemarkup turbo-assembler turbo-basic-xl turbo-basic turbo-pascal turing-plus turing turnstile-plus turnstile turtle tutor tutorial-d twelf twig twiki two-d twoducks txl txr txt2tags txtzyme tyco tymshare-superbasic tynker type-language typecastjs typecobol typedefs typescript typographical-number-theory typoscript typst tyruba u-datalog u uan ubasic ubercode uberscript ubik ubjson uc ucg ucl ucsd-pascal udp ufl ufo ugbasic ugnis uiml uiua ujml ulisp ultralisp-pm umka uml uml2-sp umple umta uncol underlay unicode-lang unicode unicon-adl unicon unicorn uniface unified-diff unified-parallel-c unisim unison unity-engine unity unity3d-asset universe unix unlambda unlws uno unql-lang unql unravel unrealscript unseemly up-arrow-notation upic urbiscript url urn urweb usb-standard uscript uscript2 usd ussa utc-format utf-8 utopia-84 uxf v-golf v-promela v-visual-language v v8 v8torque val-ii val vala vale-assembly vale varlist vba vbscript vcard vcf-format vcl vcpkg-pm vdm-sl vdscript vector-pascal vega-editor-app velato vely venus verifpal verilog verona verse versioned-text-markup-language verve vex vga-standard vhdl-ams vhdl vi-editor video vienna-definition-language vienna-fortran vigil vilnius-basic vim-editor vim-script vim-scripts-pm vimwiki violent-es viptran virgil viron virt visavis visdown vissim visual-basic.net visual-basic visual-dataflex visual-dialogscript visual-eiffel visual-foxpro visual-logic visual-objects visual-occam visual-paradigm-app visual-prolog visual-smalltalk-enterprise visual-studio-code-editor visual-studio-editor visual-studio-marketplace-pm visual-test visual visualworks viva vivaldi viz vlibtemplate vml volt vortex voxml vpl vrml vspl vsxu vtl-lang vtl vtml vuejs vulcan vvvv vyper vyxal w wah walt wart wasm wasmer wasp-lang wast watbol watcom water watfiv watfor wats wavefront-material wavefront-object wcl wcps wddx wdf wdl web-idl webdna webgl webkit webl webp-format webql webstorm-editor weebasic wescheme wgsl whack whalecalf whiley whirl whirlwind whitespace whois-protocol wikitax winbatch windev windows-registry-entries wing winwrap-basic winxed wireless-markup-language wirth-syntax-notation wisp wiswesser-line-notation wizml wizor wlambda wlanguage wml wmlscript woe wol wolfram wolontis-bell-interpreter wonkey woofjs wordpress work-flow-language workfl world-of-warcraft-addon-data world worst wren writeacourse wsdl wsfn-programming-language wu wxbasic wylbur wyvern x-basic x-bitmap-format x-bitmap x-font-directory-index x-it x-klaim x-pixmap x10 x11-basic x86-64-isa x86-assembly x86-isa xadl xaml xbase xbasepp xbasic xbel xbl xblite xbrl xc xcard xcas xcompose xcore xcy xdr xduce xe xetex xgboost-model xgboost xgmml xhtml xidoc xl-lang xl xlwings-editor xmi xmind xml-gl xml-ql xml-query-algebra xml xmpp-protocol xmtc xoc-compiler xodio xojo xotcl xpages xpath xpl xpl0 xpm-format xpop xproc xprofan xql-lang xql xquery xs-lang xs xsd xsharp xsim xslt xsv-app xt3d xtao xtclang xtend xtext xtran xuml xupdate xxl y-lang y yabasic yacas yacc yakou-lang yaml yamp yang yap-prolog yara yarv yasl yasnippet yawl ycp yedalog yess yeti yii yinyang yoga yoix yoptascript yorick yugabytedb yum-pm z-expressions z-flat z-machine z-notation z-shell z z2 z80 zbasic zccs zed zeek zeno zenscript zephir zephyr-asdl zeta zgrass zig zigzag zil zim-format zimbu zimpl zip-format zish zl zlang zoem zolang zone zonnon zope zopl zot zpl zpp zuo zz
regexCell
 highlightScope string
numberCell
 highlightScope constant.numeric
numberOrStringCell
 highlightScope constant.numeric
commentCell
 highlightScope comment
javascriptCell
 description Javascript code
 extends stringCell
customColumnNameCell
 highlightScope constant.numeric
columnNameCell
 description The column to search on.
 highlightScope constant.numeric
 enum annualReportsUrl antlr hopl jupyterKernel meetup meetup_memberCount meetup_groupCount subreddit subreddit_memberCount replit rosettaCode twitter twitter_followers discord discourse irc zulip cheatSheetUrl conference demoVideo documentation devDocumentation downloadPageUrl ebook emailList esolang eventsPageUrl faqPageUrl gitRepo githubRepo githubRepo_created githubRepo_updated githubRepo_firstCommit githubRepo_subscribers githubRepo_forks githubRepo_stars githubRepo_issues gitlabRepo sourcehutRepo gource firstAnnouncement screenshot photo languageServerProtocolProject linguistGrammarRepo linguistGrammarRepo_commitCount linguistGrammarRepo_firstCommit linguistGrammarRepo_lastCommit linguistGrammarRepo_sampleCount linguistGrammarRepo_committerCount officialBlogUrl packageRepository proposals redditDiscussion reference releaseNotesUrl rijuRepl roadmap spec website webRepl wikipedia wikipedia_related wikipedia_summary wikipedia_created wikipedia_appeared wikipedia_dailyPageViews wikipedia_backlinksCount wikipedia_revisionCount wikipedia_pageId canDoShebang canReadCommandLineArgs canUseQuestionMarksAsPartOfIdentifier canWriteToDisk hasAbstractTypes hasAccessModifiers hasAlgebraicTypes hasAnonymousFunctions hasArraySlicingSyntax hasAssertStatements hasAssignment hasAsyncAwait hasBinaryNumbers hasBinaryOperators hasBitWiseOperators hasBlobs hasBooleans hasBoundedCheckedArrays hasBreak hasBuiltInRegex hasCaseInsensitiveIdentifiers hasCharacters hasClasses hasClobs hasComments hasConditionals hasConstants hasConstructors hasContinue hasDecimals hasDefaultParameters hasDependentTypes hasDestructuring hasDirectives hasDisposeBlocks hasDocComments hasDuckTyping hasDynamicProperties hasDynamicSizedArrays hasDynamicTyping hasEnums hasEscapeCharacters hasExceptions hasExplicitTypeCasting hasExports hasExpressions hasFirstClassFunctions hasFixedPoint hasFloats hasFnArguments hasForEachLoops hasForLoops hasFunctionComposition hasFunctionOverloading hasFunctions hasGarbageCollection hasGenerators hasGenerics hasGlobalScope hasGotos hasHereDocs hasHexadecimals hasHomoiconicity hasIds hasIfElses hasIfs hasImplicitArguments hasImplicitTypeConversions hasImports hasIncrementAndDecrementOperators hasInfixNotation hasInheritance hasIntegers hasInterfaces hasIterators hasLabels hasLazyEvaluation hasLineComments hasLists hasMacros hasMagicGettersAndSetters hasManualMemoryManagement hasMapFunctions hasMaps hasMemberVariables hasMessagePassing hasMethodChaining hasMethodOverloading hasMethods hasMixins hasModules hasMonads hasMultiLineComments hasMultilineStrings hasMultipleDispatch hasMultipleInheritance hasNamespaces hasNull hasOctals hasOperatorOverloading hasOperators hasPairs hasPartialApplication hasPatternMatching hasPipes hasPointers hasPolymorphism hasPostfixNotation hasPrefixNotation hasPrintDebugging hasProcessorRegisters hasRangeOperators hasReferences hasRefinementTypes hasRegularExpressionsSyntaxSugar hasRequiredMainFunction hasReservedWords hasRunTimeGuards hasSExpressions hasScientificNotation hasSelfOrThisWord hasSemanticIndentation hasSets hasSingleDispatch hasSingleTypeArrays hasSourceMaps hasStatementTerminatorCharacter hasStatements hasStaticMethods hasStaticTyping hasStreams hasStringConcatOperator hasStrings hasStructs hasSwitch hasSymbolTables hasSymbols hasTemplates hasTernaryOperators hasThreads hasTimestamps hasTraits hasTriples hasTryCatch hasTypeAnnotations hasTypeInference hasTypeParameters hasTypedHoles hasUnaryOperators hasUnicodeIdentifiers hasUnionTypes hasUnitsOfMeasure hasUserDefinedOperators hasValueReturnedFunctions hasVariableSubstitutionSyntax hasVariadicFunctions hasVirtualFunctions hasVoidFunctions hasWhileLoops hasZeroBasedNumbering hasZippers isCaseSensitive isLisp letterFirstIdentifiers mergesWhitespace supportsBreakpoints isLanguage isOpenSource isPublicDomain gdbSupport githubCopilotOptimized isDead visualParadigm usesSemanticVersioning codeMirror monaco tryItOnline ubuntuPackage compilerExplorer githubBigQuery githubBigQuery_users githubBigQuery_repos githubLanguage githubLanguage_repos githubLanguage_wrap githubLanguage_trendingProjectsCount githubLanguage_trendingProjects githubLanguage_group githubLanguage_aliases githubLanguage_interpreters githubLanguage_aceMode githubLanguage_codemirrorMode githubLanguage_codemirrorMimeType githubLanguage_tmScope githubLanguage_type leachim6 leachim6_filepath projectEuler projectEuler_memberCount pygmentsHighlighter pygmentsHighlighter_filename pypl quineRelay tiobe tiobe_currentRank id getSource description keywords lineCommentToken multiLineCommentTokens printToken stringToken assignmentToken booleanTokens includeToken fileExtensions filenames creators originCommunity forLanguages related runsOnVm influencedBy successorOf subsetOf implementationOf renamedTo supersetOf writtenIn extensionOf forkOf compilesTo inputLanguages title standsFor aka oldName hoplId bookCount paperCount exampleCount factCount numberOfUsersEstimate numberOfJobsEstimate centralPackageRepositoryCount packageInstallCount packageCount packageAuthors rank languageRank lastActivity appeared wordRank country dblp dblp_hits dblp_publications equation example helloWorldCollection funFact goodreads hackerNewsDiscussions isbndb semanticScholar fileType nativeLanguage announcementMethod type indeedJobs linkedInSkill repoStats repoStats_firstCommit repoStats_commits repoStats_committers repoStats_files stackOverflowSurvey stackOverflowSurvey_undefined_users stackOverflowSurvey_undefined_medianSalary stackOverflowSurvey_undefined_fans stackOverflowSurvey_undefined_percentageUsing versions domainName domainName_registered domainName_awisRank
blankCell

// Parsers
tqlParser
 root
 description TrueBase Query Language (TQL) is a new language for querying a TrueBase.
 catchAllParser catchAllErrorParser
 inScope abstractQueryParser blankLineParser commentParser abstractModifierParser abstractMetaParser compareParser
 javascript
  get tests() {
    const tests = this.filter(node => node.toPredicate).map(node => {
        const predicate = node.toPredicate()
        return node.flip ? (file) => !predicate(file)  : predicate
    })
    return tests
  }
  filterFolder(trueBaseFolder) {
    const {tests} = this
    const predicate = file => tests.every(fn => fn(file))
    return trueBaseFolder.filter(file => predicate(file))
  }
catchAllErrorParser
 baseParser errorParser
blankLineParser
 description Blank lines are ignored.
 cells blankCell
 compiler
  stringTemplate 
 pattern ^$
 tags doNotSynthesize
 boolean shouldSerialize false
commentParser
 description Comments are ignored.
 crux #
 cells commentCell
 catchAllCellType commentCell
 catchAllParser commentParser
 boolean suggestInAutocomplete false

abstractQueryParser
 cells keywordCell
 inScope abstractQueryParser commentParser
 javascript
  toPredicate() {
    return () => true
  }

whereParser
 description Find files whose value in the given column meet this condition.
 extends abstractQueryParser
 cells keywordCell columnNameCell comparisonCell
 catchAllCellType numberOrStringCell
 crux where
 javascript
  toPredicate() {
    const columnName = this.getWord(1)
    const operator = this.getWord(2)
    return file => {
      const value = file.getTypedValue(columnName)
      const valueType = typeof value
      const textQueryValue = this.getWordsFrom(3).join(" ")
      let queryValue = textQueryValue
      if (valueType === "number")
        queryValue = parseFloat(queryValue)
      if (operator === ">")
        return value > queryValue
      if (operator === "<")
        return value < queryValue
      if (operator === "=")
        return value == queryValue
      if (operator === "!=")
        return value != queryValue
      if (operator === "includes")
        return value ? value.includes(queryValue) : false
      if (operator === "doesNotInclude")
        return value ? !value.includes(queryValue) : true
      if (operator === "oneOf")
        return value ? textQueryValue.split(" ").includes(value.toString()) : false
    }
  }

includesTextParser
 extends abstractQueryParser
 description Find files that include this text somewhere. Case insensitive.
 catchAllCellType stringCell
 crux includes
 javascript
  toPredicate() {
    const query = (this.content ?? "").toLowerCase()
    return file => file.lowercase.includes(query)
  }
doesNotIncludeTextParser
 description Find files that do not include this text anywhere. Case insensitive.
 extends includesTextParser
 crux doesNotInclude
 boolean flip true

columnIsMissingParser
 description Find files whose value in the given column is missing.
 extends abstractQueryParser
 cells keywordCell columnNameCell
 crux missing
 javascript
  toPredicate() {
    const columnName = this.getWord(1)
    return file => !file.has(columnName.replaceAll("_", " ")) && !file.parent.isComputedColumn(columnName)
  }
columnIsNotMissingParser
 description Find files whose value in the given column is not missing.
 extends columnIsMissingParser
 crux notMissing
 boolean flip true

matchesRegexParser
 description Find files that match this regex on a full text search.
 extends abstractQueryParser
 catchAllCellType regexCell
 crux matchesRegex
 javascript
  toPredicate() {
    const regex = new RegExp(this.content ?? "")
    return file => regex.test(file.asString)
  }

abstractModifierParser
 cells keywordCell
 cruxFromId

// Sort and limit
reverseParser
 extends abstractModifierParser
 description Reverse the order of results.
 single
limitParser
 extends abstractModifierParser
 description Return a maximum of this many results.
 cells keywordCell numberCell
 single

// Add a column
addColumnParser
 description Add a custom column using Javascript template strings.
 cells keywordCell customColumnNameCell
 catchAllCellType javascriptCell
 extends abstractModifierParser
 example
  addColumn GoogleSearch <a href="https://www.google.com/search?q=\${row.title}">Search Google for \${row.title}</a>

// Compare command
compareParser
 single
 cruxFromId
 description Autogenerate an interesting comparison between the selected entities.
 catchAllCellType trueBaseIdCell
 cells keywordCell

// Columns specific
abstractColumnModifierParser
 extends abstractModifierParser
 catchAllCellType columnNameCell
selectParser
 description Choose which columns to return.
 extends abstractColumnModifierParser
selectAllParser
 description Select all the columns
 extends abstractColumnModifierParser
renameParser
 cells keywordCell columnNameCell customColumnNameCell
 example
  rename githubRepo.stars Stars
 description Rename a column.
 extends abstractColumnModifierParser
sortByParser
 description Sort by these columns.
 extends abstractColumnModifierParser
 single

// Display elements
abstractMetaParser
 cells keywordCell
 catchAllCellType stringCell
 cruxFromId
 single
 boolean suggestInAutocomplete false
titleParser
 description Give your query a title for display on the results page.
 extends abstractMetaParser
descriptionParser
 description Give your query a description for display on the results page.
 extends abstractMetaParser`)
        get handGrammarProgram() {
          return this.constructor.cachedHandGrammarProgramRoot
      }
static rootParser = tqlParser
    }

class catchAllErrorParser extends GrammarBackedNode {
      getErrors() { return this._getErrorParserErrors() }
    }

class blankLineParser extends GrammarBackedNode {
      get blankCell() {
      return this.getWord(0)
    }
get shouldSerialize() { return false }
    }

class commentParser extends GrammarBackedNode {
      createParserCombinator() {
  return new TreeNode.ParserCombinator(commentParser, undefined, undefined)
  }
get commentCell() {
      return this.getWord(0)
    }
get commentCell() {
      return this.getWordsFrom(1)
    }
get suggestInAutocomplete() { return false }
    }

class abstractQueryParser extends GrammarBackedNode {
      createParserCombinator() {
  return new TreeNode.ParserCombinator(undefined, Object.assign(Object.assign({}, super.createParserCombinator()._getFirstWordMapAsObject()), {"#" : commentParser,
"where" : whereParser,
"includes" : includesTextParser,
"doesNotInclude" : doesNotIncludeTextParser,
"missing" : columnIsMissingParser,
"notMissing" : columnIsNotMissingParser,
"matchesRegex" : matchesRegexParser}), undefined)
  }
get keywordCell() {
      return this.getWord(0)
    }
toPredicate() {
  return () => true
}
    }

class whereParser extends abstractQueryParser {
      get keywordCell() {
      return this.getWord(0)
    }
get columnNameCell() {
      return this.getWord(1)
    }
get comparisonCell() {
      return this.getWord(2)
    }
get numberOrStringCell() {
      return this.getWordsFrom(3)
    }
toPredicate() {
  const columnName = this.getWord(1)
  const operator = this.getWord(2)
  return file => {
    const value = file.getTypedValue(columnName)
    const valueType = typeof value
    const textQueryValue = this.getWordsFrom(3).join(" ")
    let queryValue = textQueryValue
    if (valueType === "number")
      queryValue = parseFloat(queryValue)
    if (operator === ">")
      return value > queryValue
    if (operator === "<")
      return value < queryValue
    if (operator === "=")
      return value == queryValue
    if (operator === "!=")
      return value != queryValue
    if (operator === "includes")
      return value ? value.includes(queryValue) : false
    if (operator === "doesNotInclude")
      return value ? !value.includes(queryValue) : true
    if (operator === "oneOf")
      return value ? textQueryValue.split(" ").includes(value.toString()) : false
  }
}
    }

class includesTextParser extends abstractQueryParser {
      get stringCell() {
      return this.getWordsFrom(0)
    }
toPredicate() {
  const query = (this.content ?? "").toLowerCase()
  return file => file.lowercase.includes(query)
}
    }

class doesNotIncludeTextParser extends includesTextParser {
      get flip() { return true }
    }

class columnIsMissingParser extends abstractQueryParser {
      get keywordCell() {
      return this.getWord(0)
    }
get columnNameCell() {
      return this.getWord(1)
    }
toPredicate() {
  const columnName = this.getWord(1)
  return file => !file.has(columnName.replaceAll("_", " ")) && !file.parent.isComputedColumn(columnName)
}
    }

class columnIsNotMissingParser extends columnIsMissingParser {
      get flip() { return true }
    }

class matchesRegexParser extends abstractQueryParser {
      get regexCell() {
      return this.getWordsFrom(0)
    }
toPredicate() {
  const regex = new RegExp(this.content ?? "")
  return file => regex.test(file.asString)
}
    }

class abstractModifierParser extends GrammarBackedNode {
      get keywordCell() {
      return this.getWord(0)
    }
    }

class reverseParser extends abstractModifierParser {
      
    }

class limitParser extends abstractModifierParser {
      get keywordCell() {
      return this.getWord(0)
    }
get numberCell() {
      return parseFloat(this.getWord(1))
    }
    }

class addColumnParser extends abstractModifierParser {
      get keywordCell() {
      return this.getWord(0)
    }
get customColumnNameCell() {
      return this.getWord(1)
    }
get javascriptCell() {
      return this.getWordsFrom(2)
    }
    }

class compareParser extends GrammarBackedNode {
      get keywordCell() {
      return this.getWord(0)
    }
get trueBaseIdCell() {
      return this.getWordsFrom(1)
    }
    }

class abstractColumnModifierParser extends abstractModifierParser {
      get columnNameCell() {
      return this.getWordsFrom(0)
    }
    }

class selectParser extends abstractColumnModifierParser {
      
    }

class selectAllParser extends abstractColumnModifierParser {
      
    }

class renameParser extends abstractColumnModifierParser {
      get keywordCell() {
      return this.getWord(0)
    }
get columnNameCell() {
      return this.getWord(1)
    }
get customColumnNameCell() {
      return this.getWord(2)
    }
    }

class sortByParser extends abstractColumnModifierParser {
      
    }

class abstractMetaParser extends GrammarBackedNode {
      get keywordCell() {
      return this.getWord(0)
    }
get stringCell() {
      return this.getWordsFrom(1)
    }
get suggestInAutocomplete() { return false }
    }

class titleParser extends abstractMetaParser {
      
    }

class descriptionParser extends abstractMetaParser {
      
    }

window.tqlParser = tqlParser
};

// prettier-ignore
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],E=C.document,r=Object.getPrototypeOf,s=t.slice,g=t.concat,u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.4.1",k=function(e,t){return new k.fn.init(e,t)},p=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;function d(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}k.fn=k.prototype={jquery:f,constructor:k,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=k.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return k.each(this,e)},map:function(n){return this.pushStack(k.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},k.extend=k.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(k.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||k.isPlainObject(n)?n:{},i=!1,a[t]=k.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},k.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t){b(e,{nonce:t&&t.nonce})},each:function(e,t){var n,r=0;if(d(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},trim:function(e){return null==e?"":(e+"").replace(p,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(d(Object(e))?k.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(d(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g.apply([],a)},guid:1,support:y}),"function"==typeof Symbol&&(k.fn[Symbol.iterator]=t[Symbol.iterator]),k.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var h=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,k="sizzle"+1*new Date,m=n.document,S=0,r=0,p=ue(),x=ue(),N=ue(),A=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",$=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",F=new RegExp(M+"+","g"),B=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp($),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+$),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),ne=function(e,t,n){var r="0x"+t-65536;return r!=r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(m.childNodes),m.childNodes),t[m.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&((e?e.ownerDocument||e:m)!==C&&T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!A[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&U.test(t)){(s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=k),o=(l=h(t)).length;while(o--)l[o]="#"+s+" "+xe(l[o]);c=l.join(","),f=ee.test(t)&&ye(e.parentNode)||e}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){A(t,!0)}finally{s===k&&e.removeAttribute("id")}}}return g(t.replace(B,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[k]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:m;return r!==C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),m!==C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=k,!C.getElementsByName||!C.getElementsByName(k).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){a.appendChild(e).innerHTML="<a id='"+k+"'></a><select id='"+k+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+k+"-]").length||v.push("~="),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+k+"+*").length||v.push(".#.+[+~]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",$)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e===C||e.ownerDocument===m&&y(m,e)?-1:t===C||t.ownerDocument===m&&y(m,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e===C?-1:t===C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]===m?-1:s[r]===m?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if((e.ownerDocument||e)!==C&&T(e),d.matchesSelector&&E&&!A[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){A(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!==C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!==C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=p[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&p(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(F," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[S,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[S,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[k]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace(B,"$1"));return s[k]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[S,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[k]||(e[k]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===S&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[k]&&(v=Ce(v)),y&&!y[k]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[k]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(B,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(B," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=N[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[k]?i.push(a):o.push(a);(a=N(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=S+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t===C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument===C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(S=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(S=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=k.split("").sort(D).join("")===k,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);k.find=h,k.expr=h.selectors,k.expr[":"]=k.expr.pseudos,k.uniqueSort=k.unique=h.uniqueSort,k.text=h.getText,k.isXMLDoc=h.isXML,k.contains=h.contains,k.escapeSelector=h.escape;var T=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&k(e).is(n))break;r.push(e)}return r},S=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},N=k.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var D=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function j(e,n,r){return m(n)?k.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?k.grep(e,function(e){return e===n!==r}):"string"!=typeof n?k.grep(e,function(e){return-1<i.call(n,e)!==r}):k.filter(n,e,r)}k.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?k.find.matchesSelector(r,e)?[r]:[]:k.find.matches(e,k.grep(t,function(e){return 1===e.nodeType}))},k.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(k(e).filter(function(){for(t=0;t<r;t++)if(k.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)k.find(e,i[t],n);return 1<r?k.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,"string"==typeof e&&N.test(e)?k(e):e||[],!1).length}});var q,L=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(k.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||q,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:L.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof k?t[0]:t,k.merge(this,k.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),D.test(r[1])&&k.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(k):k.makeArray(e,this)}).prototype=k.fn,q=k(E);var H=/^(?:parents|prev(?:Until|All))/,O={children:!0,contents:!0,next:!0,prev:!0};function P(e,t){while((e=e[t])&&1!==e.nodeType);return e}k.fn.extend({has:function(e){var t=k(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(k.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&k(e);if(!N.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&k.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?k.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(k(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(k.uniqueSort(k.merge(this.get(),k(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),k.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return T(e,"parentNode")},parentsUntil:function(e,t,n){return T(e,"parentNode",n)},next:function(e){return P(e,"nextSibling")},prev:function(e){return P(e,"previousSibling")},nextAll:function(e){return T(e,"nextSibling")},prevAll:function(e){return T(e,"previousSibling")},nextUntil:function(e,t,n){return T(e,"nextSibling",n)},prevUntil:function(e,t,n){return T(e,"previousSibling",n)},siblings:function(e){return S((e.parentNode||{}).firstChild,e)},children:function(e){return S(e.firstChild)},contents:function(e){return"undefined"!=typeof e.contentDocument?e.contentDocument:(A(e,"template")&&(e=e.content||e),k.merge([],e.childNodes))}},function(r,i){k.fn[r]=function(e,t){var n=k.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=k.filter(t,n)),1<this.length&&(O[r]||k.uniqueSort(n),H.test(r)&&n.reverse()),this.pushStack(n)}});var R=/[^\x20\t\r\n\f]+/g;function M(e){return e}function I(e){throw e}function W(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}k.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},k.each(e.match(R)||[],function(e,t){n[t]=!0}),n):k.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){k.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return k.each(arguments,function(e,t){var n;while(-1<(n=k.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<k.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},k.extend({Deferred:function(e){var o=[["notify","progress",k.Callbacks("memory"),k.Callbacks("memory"),2],["resolve","done",k.Callbacks("once memory"),k.Callbacks("once memory"),0,"resolved"],["reject","fail",k.Callbacks("once memory"),k.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return k.Deferred(function(r){k.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,M,s),l(u,o,I,s)):(u++,t.call(e,l(u,o,M,s),l(u,o,I,s),l(u,o,M,o.notifyWith))):(a!==M&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){k.Deferred.exceptionHook&&k.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==I&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(k.Deferred.getStackHook&&(t.stackTrace=k.Deferred.getStackHook()),C.setTimeout(t))}}return k.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:M,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:M)),o[2][3].add(l(0,e,m(n)?n:I))}).promise()},promise:function(e){return null!=e?k.extend(e,a):a}},s={};return k.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=k.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(W(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)W(i[t],a(t),o.reject);return o.promise()}});var $=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;k.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&$.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},k.readyException=function(e){C.setTimeout(function(){throw e})};var F=k.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),k.ready()}k.fn.ready=function(e){return F.then(e)["catch"](function(e){k.readyException(e)}),this},k.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--k.readyWait:k.isReady)||(k.isReady=!0)!==e&&0<--k.readyWait||F.resolveWith(E,[k])}}),k.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(k.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var _=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)_(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(k(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},z=/^-ms-/,U=/-([a-z])/g;function X(e,t){return t.toUpperCase()}function V(e){return e.replace(z,"ms-").replace(U,X)}var G=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function Y(){this.expando=k.expando+Y.uid++}Y.uid=1,Y.prototype={cache:function(e){var t=e[this.expando];return t||(t={},G(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[V(t)]=n;else for(r in t)i[V(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][V(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(V):(t=V(t))in r?[t]:t.match(R)||[]).length;while(n--)delete r[t[n]]}(void 0===t||k.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!k.isEmptyObject(t)}};var Q=new Y,J=new Y,K=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function ee(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(Z,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:K.test(i)?JSON.parse(i):i)}catch(e){}J.set(e,t,n)}else n=void 0;return n}k.extend({hasData:function(e){return J.hasData(e)||Q.hasData(e)},data:function(e,t,n){return J.access(e,t,n)},removeData:function(e,t){J.remove(e,t)},_data:function(e,t,n){return Q.access(e,t,n)},_removeData:function(e,t){Q.remove(e,t)}}),k.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=J.get(o),1===o.nodeType&&!Q.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=V(r.slice(5)),ee(o,r,i[r]));Q.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){J.set(this,n)}):_(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=J.get(o,n))?t:void 0!==(t=ee(o,n))?t:void 0;this.each(function(){J.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){J.remove(this,e)})}}),k.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Q.get(e,t),n&&(!r||Array.isArray(n)?r=Q.access(e,t,k.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=k.queue(e,t),r=n.length,i=n.shift(),o=k._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){k.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Q.get(e,n)||Q.access(e,n,{empty:k.Callbacks("once memory").add(function(){Q.remove(e,[t+"queue",n])})})}}),k.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?k.queue(this[0],t):void 0===n?this:this.each(function(){var e=k.queue(this,t,n);k._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&k.dequeue(this,t)})},dequeue:function(e){return this.each(function(){k.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=k.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Q.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var te=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ne=new RegExp("^(?:([+-])=|)("+te+")([a-z%]*)$","i"),re=["Top","Right","Bottom","Left"],ie=E.documentElement,oe=function(e){return k.contains(e.ownerDocument,e)},ae={composed:!0};ie.getRootNode&&(oe=function(e){return k.contains(e.ownerDocument,e)||e.getRootNode(ae)===e.ownerDocument});var se=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&oe(e)&&"none"===k.css(e,"display")},ue=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];for(o in i=n.apply(e,r||[]),t)e.style[o]=a[o];return i};function le(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return k.css(e,t,"")},u=s(),l=n&&n[3]||(k.cssNumber[t]?"":"px"),c=e.nodeType&&(k.cssNumber[t]||"px"!==l&&+u)&&ne.exec(k.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)k.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,k.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ce={};function fe(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Q.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&se(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ce[s])||(o=a.body.appendChild(a.createElement(s)),u=k.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ce[s]=u)))):"none"!==n&&(l[c]="none",Q.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}k.fn.extend({show:function(){return fe(this,!0)},hide:function(){return fe(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){se(this)?k(this).show():k(this).hide()})}});var pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i,ge={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?k.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Q.set(e[n],"globalEval",!t||Q.get(t[n],"globalEval"))}ge.optgroup=ge.option,ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td;var me,xe,be=/<|&#?\w+;/;function we(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))k.merge(p,o.nodeType?[o]:o);else if(be.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+k.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;k.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<k.inArray(o,r))i&&i.push(o);else if(l=oe(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}me=E.createDocumentFragment().appendChild(E.createElement("div")),(xe=E.createElement("input")).setAttribute("type","radio"),xe.setAttribute("checked","checked"),xe.setAttribute("name","t"),me.appendChild(xe),y.checkClone=me.cloneNode(!0).cloneNode(!0).lastChild.checked,me.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!me.cloneNode(!0).lastChild.defaultValue;var Te=/^key/,Ce=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ee=/^([^.]*)(?:\.(.+)|)/;function ke(){return!0}function Se(){return!1}function Ne(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function Ae(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Ae(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Se;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return k().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=k.guid++)),e.each(function(){k.event.add(this,t,i,r,n)})}function De(e,i,o){o?(Q.set(e,i,!1),k.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Q.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(k.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Q.set(this,i,r),t=o(this,i),this[i](),r!==(n=Q.get(this,i))||t?Q.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Q.set(this,i,{value:k.event.trigger(k.extend(r[0],k.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Q.get(e,i)&&k.event.add(e,i,ke)}k.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.get(t);if(v){n.handler&&(n=(o=n).handler,i=o.selector),i&&k.find.matchesSelector(ie,i),n.guid||(n.guid=k.guid++),(u=v.events)||(u=v.events={}),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof k&&k.event.triggered!==e.type?k.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(R)||[""]).length;while(l--)d=g=(s=Ee.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=k.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=k.event.special[d]||{},c=k.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&k.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),k.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.hasData(e)&&Q.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(R)||[""]).length;while(l--)if(d=g=(s=Ee.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=k.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||k.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)k.event.remove(e,d+t[l],n,r,!0);k.isEmptyObject(u)&&Q.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=k.event.fix(e),u=new Array(arguments.length),l=(Q.get(this,"events")||{})[s.type]||[],c=k.event.special[s.type]||{};for(u[0]=s,t=1;t<arguments.length;t++)u[t]=arguments[t];if(s.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,s)){a=k.event.handlers.call(this,s,l),t=0;while((i=a[t++])&&!s.isPropagationStopped()){s.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!s.isImmediatePropagationStopped())s.rnamespace&&!1!==o.namespace&&!s.rnamespace.test(o.namespace)||(s.handleObj=o,s.data=o.data,void 0!==(r=((k.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,u))&&!1===(s.result=r)&&(s.preventDefault(),s.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,s),s.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<k(i,this).index(l):k.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(k.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[k.expando]?e:new k.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click",ke),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Q.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},k.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},k.Event=function(e,t){if(!(this instanceof k.Event))return new k.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?ke:Se,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&k.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[k.expando]=!0},k.Event.prototype={constructor:k.Event,isDefaultPrevented:Se,isPropagationStopped:Se,isImmediatePropagationStopped:Se,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=ke,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=ke,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=ke,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},k.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&Te.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Ce.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},k.event.addProp),k.each({focus:"focusin",blur:"focusout"},function(e,t){k.event.special[e]={setup:function(){return De(this,e,Ne),!1},trigger:function(){return De(this,e),!0},delegateType:t}}),k.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){k.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||k.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),k.fn.extend({on:function(e,t,n,r){return Ae(this,e,t,n,r)},one:function(e,t,n,r){return Ae(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,k(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Se),this.each(function(){k.event.remove(this,e,n,t)})}});var je=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,qe=/<script|<style|<link/i,Le=/checked\s*(?:[^=]|=\s*.checked.)/i,He=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Oe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&k(e).children("tbody")[0]||e}function Pe(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function Re(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Me(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(Q.hasData(e)&&(o=Q.access(e),a=Q.set(t,o),l=o.events))for(i in delete a.handle,a.events={},l)for(n=0,r=l[i].length;n<r;n++)k.event.add(t,i,l[i][n]);J.hasData(e)&&(s=J.access(e),u=k.extend({},s),J.set(t,u))}}function Ie(n,r,i,o){r=g.apply([],r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&Le.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Ie(t,r,i,o)});if(f&&(t=(e=we(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=k.map(ve(e,"script"),Pe)).length;c<f;c++)u=e,c!==p&&(u=k.clone(u,!0,!0),s&&k.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,k.map(a,Re),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Q.access(u,"globalEval")&&k.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?k._evalUrl&&!u.noModule&&k._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")}):b(u.textContent.replace(He,""),u,l))}return n}function We(e,t,n){for(var r,i=t?k.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||k.cleanData(ve(r)),r.parentNode&&(n&&oe(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}k.extend({htmlPrefilter:function(e){return e.replace(je,"<$1></$2>")},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=oe(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||k.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Me(o[r],a[r]);else Me(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=k.event.special,o=0;void 0!==(n=e[o]);o++)if(G(n)){if(t=n[Q.expando]){if(t.events)for(r in t.events)i[r]?k.event.remove(n,r):k.removeEvent(n,r,t.handle);n[Q.expando]=void 0}n[J.expando]&&(n[J.expando]=void 0)}}}),k.fn.extend({detach:function(e){return We(this,e,!0)},remove:function(e){return We(this,e)},text:function(e){return _(this,function(e){return void 0===e?k.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Ie(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Oe(this,e).appendChild(e)})},prepend:function(){return Ie(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Oe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(k.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return k.clone(this,e,t)})},html:function(e){return _(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!qe.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=k.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(k.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Ie(this,arguments,function(e){var t=this.parentNode;k.inArray(this,n)<0&&(k.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),k.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){k.fn[e]=function(e){for(var t,n=[],r=k(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),k(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var $e=new RegExp("^("+te+")(?!px)[a-z%]+$","i"),Fe=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Be=new RegExp(re.join("|"),"i");function _e(e,t,n){var r,i,o,a,s=e.style;return(n=n||Fe(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||oe(e)||(a=k.style(e,t)),!y.pixelBoxStyles()&&$e.test(a)&&Be.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function ze(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(u){s.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",u.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",ie.appendChild(s).appendChild(u);var e=C.getComputedStyle(u);n="1%"!==e.top,a=12===t(e.marginLeft),u.style.right="60%",o=36===t(e.right),r=36===t(e.width),u.style.position="absolute",i=12===t(u.offsetWidth/3),ie.removeChild(s),u=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s=E.createElement("div"),u=E.createElement("div");u.style&&(u.style.backgroundClip="content-box",u.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===u.style.backgroundClip,k.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),a},scrollboxSize:function(){return e(),i}}))}();var Ue=["Webkit","Moz","ms"],Xe=E.createElement("div").style,Ve={};function Ge(e){var t=k.cssProps[e]||Ve[e];return t||(e in Xe?e:Ve[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Ue.length;while(n--)if((e=Ue[n]+t)in Xe)return e}(e)||e)}var Ye=/^(none|table(?!-c[ea]).+)/,Qe=/^--/,Je={position:"absolute",visibility:"hidden",display:"block"},Ke={letterSpacing:"0",fontWeight:"400"};function Ze(e,t,n){var r=ne.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function et(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=k.css(e,n+re[a],!0,i)),r?("content"===n&&(u-=k.css(e,"padding"+re[a],!0,i)),"margin"!==n&&(u-=k.css(e,"border"+re[a]+"Width",!0,i))):(u+=k.css(e,"padding"+re[a],!0,i),"padding"!==n?u+=k.css(e,"border"+re[a]+"Width",!0,i):s+=k.css(e,"border"+re[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function tt(e,t,n){var r=Fe(e),i=(!y.boxSizingReliable()||n)&&"border-box"===k.css(e,"boxSizing",!1,r),o=i,a=_e(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if($e.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||"auto"===a||!parseFloat(a)&&"inline"===k.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===k.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+et(e,t,n||(i?"border":"content"),o,r,a)+"px"}function nt(e,t,n,r,i){return new nt.prototype.init(e,t,n,r,i)}k.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=_e(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=V(t),u=Qe.test(t),l=e.style;if(u||(t=Ge(s)),a=k.cssHooks[t]||k.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=ne.exec(n))&&i[1]&&(n=le(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(k.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=V(t);return Qe.test(t)||(t=Ge(s)),(a=k.cssHooks[t]||k.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=_e(e,t,r)),"normal"===i&&t in Ke&&(i=Ke[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),k.each(["height","width"],function(e,u){k.cssHooks[u]={get:function(e,t,n){if(t)return!Ye.test(k.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?tt(e,u,n):ue(e,Je,function(){return tt(e,u,n)})},set:function(e,t,n){var r,i=Fe(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===k.css(e,"boxSizing",!1,i),s=n?et(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-et(e,u,"border",!1,i)-.5)),s&&(r=ne.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=k.css(e,u)),Ze(0,t,s)}}}),k.cssHooks.marginLeft=ze(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(_e(e,"marginLeft"))||e.getBoundingClientRect().left-ue(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),k.each({margin:"",padding:"",border:"Width"},function(i,o){k.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+re[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(k.cssHooks[i+o].set=Ze)}),k.fn.extend({css:function(e,t){return _(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Fe(e),i=t.length;a<i;a++)o[t[a]]=k.css(e,t[a],!1,r);return o}return void 0!==n?k.style(e,t,n):k.css(e,t)},e,t,1<arguments.length)}}),((k.Tween=nt).prototype={constructor:nt,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||k.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(k.cssNumber[n]?"":"px")},cur:function(){var e=nt.propHooks[this.prop];return e&&e.get?e.get(this):nt.propHooks._default.get(this)},run:function(e){var t,n=nt.propHooks[this.prop];return this.options.duration?this.pos=t=k.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):nt.propHooks._default.set(this),this}}).init.prototype=nt.prototype,(nt.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=k.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){k.fx.step[e.prop]?k.fx.step[e.prop](e):1!==e.elem.nodeType||!k.cssHooks[e.prop]&&null==e.elem.style[Ge(e.prop)]?e.elem[e.prop]=e.now:k.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=nt.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},k.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},k.fx=nt.prototype.init,k.fx.step={};var rt,it,ot,at,st=/^(?:toggle|show|hide)$/,ut=/queueHooks$/;function lt(){it&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(lt):C.setTimeout(lt,k.fx.interval),k.fx.tick())}function ct(){return C.setTimeout(function(){rt=void 0}),rt=Date.now()}function ft(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=re[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function pt(e,t,n){for(var r,i=(dt.tweeners[t]||[]).concat(dt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function dt(o,e,t){var n,a,r=0,i=dt.prefilters.length,s=k.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=rt||ct(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:k.extend({},e),opts:k.extend(!0,{specialEasing:{},easing:k.easing._default},t),originalProperties:e,originalOptions:t,startTime:rt||ct(),duration:t.duration,tweens:[],createTween:function(e,t){var n=k.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=V(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=k.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=dt.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(k._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return k.map(c,pt,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),k.fx.timer(k.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}k.Animation=k.extend(dt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return le(n.elem,e,ne.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(R);for(var n,r=0,i=e.length;r<i;r++)n=e[r],dt.tweeners[n]=dt.tweeners[n]||[],dt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&se(e),v=Q.get(e,"fxshow");for(r in n.queue||(null==(a=k._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,k.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],st.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||k.style(e,r)}if((u=!k.isEmptyObject(t))||!k.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Q.get(e,"display")),"none"===(c=k.css(e,"display"))&&(l?c=l:(fe([e],!0),l=e.style.display||l,c=k.css(e,"display"),fe([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===k.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Q.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&fe([e],!0),p.done(function(){for(r in g||fe([e]),Q.remove(e,"fxshow"),d)k.style(e,r,d[r])})),u=pt(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?dt.prefilters.unshift(e):dt.prefilters.push(e)}}),k.speed=function(e,t,n){var r=e&&"object"==typeof e?k.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return k.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in k.fx.speeds?r.duration=k.fx.speeds[r.duration]:r.duration=k.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&k.dequeue(this,r.queue)},r},k.fn.extend({fadeTo:function(e,t,n,r){return this.filter(se).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=k.isEmptyObject(t),o=k.speed(e,n,r),a=function(){var e=dt(this,k.extend({},t),o);(i||Q.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&!1!==i&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=k.timers,r=Q.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&ut.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||k.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Q.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=k.timers,o=n?n.length:0;for(t.finish=!0,k.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),k.each(["toggle","show","hide"],function(e,r){var i=k.fn[r];k.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(ft(r,!0),e,t,n)}}),k.each({slideDown:ft("show"),slideUp:ft("hide"),slideToggle:ft("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){k.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),k.timers=[],k.fx.tick=function(){var e,t=0,n=k.timers;for(rt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||k.fx.stop(),rt=void 0},k.fx.timer=function(e){k.timers.push(e),k.fx.start()},k.fx.interval=13,k.fx.start=function(){it||(it=!0,lt())},k.fx.stop=function(){it=null},k.fx.speeds={slow:600,fast:200,_default:400},k.fn.delay=function(r,e){return r=k.fx&&k.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},ot=E.createElement("input"),at=E.createElement("select").appendChild(E.createElement("option")),ot.type="checkbox",y.checkOn=""!==ot.value,y.optSelected=at.selected,(ot=E.createElement("input")).value="t",ot.type="radio",y.radioValue="t"===ot.value;var ht,gt=k.expr.attrHandle;k.fn.extend({attr:function(e,t){return _(this,k.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){k.removeAttr(this,e)})}}),k.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?k.prop(e,t,n):(1===o&&k.isXMLDoc(e)||(i=k.attrHooks[t.toLowerCase()]||(k.expr.match.bool.test(t)?ht:void 0)),void 0!==n?null===n?void k.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=k.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(R);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),ht={set:function(e,t,n){return!1===t?k.removeAttr(e,n):e.setAttribute(n,n),n}},k.each(k.expr.match.bool.source.match(/\w+/g),function(e,t){var a=gt[t]||k.find.attr;gt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=gt[o],gt[o]=r,r=null!=a(e,t,n)?o:null,gt[o]=i),r}});var vt=/^(?:input|select|textarea|button)$/i,yt=/^(?:a|area)$/i;function mt(e){return(e.match(R)||[]).join(" ")}function xt(e){return e.getAttribute&&e.getAttribute("class")||""}function bt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(R)||[]}k.fn.extend({prop:function(e,t){return _(this,k.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[k.propFix[e]||e]})}}),k.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&k.isXMLDoc(e)||(t=k.propFix[t]||t,i=k.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=k.find.attr(e,"tabindex");return t?parseInt(t,10):vt.test(e.nodeName)||yt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(k.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),k.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){k.propFix[this.toLowerCase()]=this}),k.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).addClass(t.call(this,e,xt(this)))});if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).removeClass(t.call(this,e,xt(this)))});if(!arguments.length)return this.attr("class","");if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){k(this).toggleClass(i.call(this,e,xt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=k(this),r=bt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=xt(this))&&Q.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Q.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+mt(xt(n))+" ").indexOf(t))return!0;return!1}});var wt=/\r/g;k.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,k(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=k.map(t,function(e){return null==e?"":e+""})),(r=k.valHooks[this.type]||k.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=k.valHooks[t.type]||k.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(wt,""):null==e?"":e:void 0}}),k.extend({valHooks:{option:{get:function(e){var t=k.find.attr(e,"value");return null!=t?t:mt(k.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=k(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=k.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<k.inArray(k.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),k.each(["radio","checkbox"],function(){k.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<k.inArray(k(e).val(),t)}},y.checkOn||(k.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var Tt=/^(?:focusinfocus|focusoutblur)$/,Ct=function(e){e.stopPropagation()};k.extend(k.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!Tt.test(d+k.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[k.expando]?e:new k.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:k.makeArray(t,[e]),c=k.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,Tt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Q.get(o,"events")||{})[e.type]&&Q.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&G(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!G(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),k.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,Ct),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,Ct),k.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=k.extend(new k.Event,n,{type:e,isSimulated:!0});k.event.trigger(r,null,t)}}),k.fn.extend({trigger:function(e,t){return this.each(function(){k.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return k.event.trigger(e,t,n,!0)}}),y.focusin||k.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){k.event.simulate(r,e.target,k.event.fix(e))};k.event.special[r]={setup:function(){var e=this.ownerDocument||this,t=Q.access(e,r);t||e.addEventListener(n,i,!0),Q.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this,t=Q.access(e,r)-1;t?Q.access(e,r,t):(e.removeEventListener(n,i,!0),Q.remove(e,r))}}});var Et=C.location,kt=Date.now(),St=/\?/;k.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||k.error("Invalid XML: "+e),t};var Nt=/\[\]$/,At=/\r?\n/g,Dt=/^(?:submit|button|image|reset|file)$/i,jt=/^(?:input|select|textarea|keygen)/i;function qt(n,e,r,i){var t;if(Array.isArray(e))k.each(e,function(e,t){r||Nt.test(n)?i(n,t):qt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)qt(n+"["+t+"]",e[t],r,i)}k.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!k.isPlainObject(e))k.each(e,function(){i(this.name,this.value)});else for(n in e)qt(n,e[n],t,i);return r.join("&")},k.fn.extend({serialize:function(){return k.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=k.prop(this,"elements");return e?k.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!k(this).is(":disabled")&&jt.test(this.nodeName)&&!Dt.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=k(this).val();return null==n?null:Array.isArray(n)?k.map(n,function(e){return{name:t.name,value:e.replace(At,"\r\n")}}):{name:t.name,value:n.replace(At,"\r\n")}}).get()}});var Lt=/%20/g,Ht=/#.*$/,Ot=/([?&])_=[^&]*/,Pt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Rt=/^(?:GET|HEAD)$/,Mt=/^\/\//,It={},Wt={},$t="*/".concat("*"),Ft=E.createElement("a");function Bt(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(R)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function _t(t,i,o,a){var s={},u=t===Wt;function l(e){var r;return s[e]=!0,k.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function zt(e,t){var n,r,i=k.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&k.extend(!0,e,r),e}Ft.href=Et.href,k.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Et.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":$t,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":k.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?zt(zt(e,k.ajaxSettings),t):zt(k.ajaxSettings,e)},ajaxPrefilter:Bt(It),ajaxTransport:Bt(Wt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=k.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?k(y):k.event,x=k.Deferred(),b=k.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Pt.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Et.href)+"").replace(Mt,Et.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(R)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Ft.protocol+"//"+Ft.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=k.param(v.data,v.traditional)),_t(It,v,t,T),h)return T;for(i in(g=k.event&&v.global)&&0==k.active++&&k.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Rt.test(v.type),f=v.url.replace(Ht,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(Lt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(St.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Ot,"$1"),o=(St.test(f)?"&":"?")+"_="+kt+++o),v.url=f+o),v.ifModified&&(k.lastModified[f]&&T.setRequestHeader("If-Modified-Since",k.lastModified[f]),k.etag[f]&&T.setRequestHeader("If-None-Match",k.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+$t+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=_t(Wt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(k.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(k.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--k.active||k.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return k.get(e,t,n,"json")},getScript:function(e,t){return k.get(e,void 0,t,"script")}}),k.each(["get","post"],function(e,i){k[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),k.ajax(k.extend({url:e,type:i,dataType:r,data:t,success:n},k.isPlainObject(e)&&e))}}),k._evalUrl=function(e,t){return k.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){k.globalEval(e,t)}})},k.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=k(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){k(this).wrapInner(n.call(this,e))}):this.each(function(){var e=k(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){k(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){k(this).replaceWith(this.childNodes)}),this}}),k.expr.pseudos.hidden=function(e){return!k.expr.pseudos.visible(e)},k.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},k.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var Ut={0:200,1223:204},Xt=k.ajaxSettings.xhr();y.cors=!!Xt&&"withCredentials"in Xt,y.ajax=Xt=!!Xt,k.ajaxTransport(function(i){var o,a;if(y.cors||Xt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(Ut[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),k.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),k.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return k.globalEval(e),e}}}),k.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),k.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=k("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Vt,Gt=[],Yt=/(=)\?(?=&|$)|\?\?/;k.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Gt.pop()||k.expando+"_"+kt++;return this[e]=!0,e}}),k.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Yt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Yt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Yt,"$1"+r):!1!==e.jsonp&&(e.url+=(St.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||k.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?k(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Gt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Vt=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Vt.childNodes.length),k.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=D.exec(e))?[t.createElement(i[1])]:(i=we([e],t,o),o&&o.length&&k(o).remove(),k.merge([],i.childNodes)));var r,i,o},k.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=mt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&k.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?k("<div>").append(k.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},k.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){k.fn[t]=function(e){return this.on(t,e)}}),k.expr.pseudos.animated=function(t){return k.grep(k.timers,function(e){return t===e.elem}).length},k.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=k.css(e,"position"),c=k(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=k.css(e,"top"),u=k.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,k.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},k.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){k.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===k.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===k.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=k(e).offset()).top+=k.css(e,"borderTopWidth",!0),i.left+=k.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-k.css(r,"marginTop",!0),left:t.left-i.left-k.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===k.css(e,"position"))e=e.offsetParent;return e||ie})}}),k.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;k.fn[t]=function(e){return _(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),k.each(["top","left"],function(e,n){k.cssHooks[n]=ze(y.pixelPosition,function(e,t){if(t)return t=_e(e,n),$e.test(t)?k(e).position()[n]+"px":t})}),k.each({Height:"height",Width:"width"},function(a,s){k.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){k.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return _(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?k.css(e,t,i):k.style(e,t,n,i)},s,n?e:void 0,n)}})}),k.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){k.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}}),k.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),k.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}}),k.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||k.guid++,i},k.holdReady=function(e){e?k.readyWait++:k.ready(!0)},k.isArray=Array.isArray,k.parseJSON=JSON.parse,k.nodeName=A,k.isFunction=m,k.isWindow=x,k.camelCase=V,k.type=w,k.now=Date.now,k.isNumeric=function(e){var t=k.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},"function"==typeof define&&define.amd&&define("jquery",[],function(){return k});var Qt=C.jQuery,Jt=C.$;return k.noConflict=function(e){return C.$===k&&(C.$=Jt),e&&C.jQuery===k&&(C.jQuery=Qt),k},e||(C.jQuery=C.$=k),k});
// *! jQuery v3.4.1 */

// prettier-ignore
(function(q,u,c){function v(a,b,g){a.addEventListener?a.addEventListener(b,g,!1):a.attachEvent("on"+b,g)}function z(a){if("keypress"==a.type){var b=String.fromCharCode(a.which);a.shiftKey||(b=b.toLowerCase());return b}return n[a.which]?n[a.which]:r[a.which]?r[a.which]:String.fromCharCode(a.which).toLowerCase()}function F(a){var b=[];a.shiftKey&&b.push("shift");a.altKey&&b.push("alt");a.ctrlKey&&b.push("ctrl");a.metaKey&&b.push("meta");return b}function w(a){return"shift"==a||"ctrl"==a||"alt"==a||
"meta"==a}function A(a,b){var g,d=[];var e=a;"+"===e?e=["+"]:(e=e.replace(/\+{2}/g,"+plus"),e=e.split("+"));for(g=0;g<e.length;++g){var m=e[g];B[m]&&(m=B[m]);b&&"keypress"!=b&&C[m]&&(m=C[m],d.push("shift"));w(m)&&d.push(m)}e=m;g=b;if(!g){if(!p){p={};for(var c in n)95<c&&112>c||n.hasOwnProperty(c)&&(p[n[c]]=c)}g=p[e]?"keydown":"keypress"}"keypress"==g&&d.length&&(g="keydown");return{key:m,modifiers:d,action:g}}function D(a,b){return null===a||a===u?!1:a===b?!0:D(a.parentNode,b)}function d(a){function b(a){a=
a||{};var b=!1,l;for(l in p)a[l]?b=!0:p[l]=0;b||(x=!1)}function g(a,b,t,f,g,d){var l,E=[],h=t.type;if(!k._callbacks[a])return[];"keyup"==h&&w(a)&&(b=[a]);for(l=0;l<k._callbacks[a].length;++l){var c=k._callbacks[a][l];if((f||!c.seq||p[c.seq]==c.level)&&h==c.action){var e;(e="keypress"==h&&!t.metaKey&&!t.ctrlKey)||(e=c.modifiers,e=b.sort().join(",")===e.sort().join(","));e&&(e=f&&c.seq==f&&c.level==d,(!f&&c.combo==g||e)&&k._callbacks[a].splice(l,1),E.push(c))}}return E}function c(a,b,c,f){k.stopCallback(b,
b.target||b.srcElement,c,f)||!1!==a(b,c)||(b.preventDefault?b.preventDefault():b.returnValue=!1,b.stopPropagation?b.stopPropagation():b.cancelBubble=!0)}function e(a){"number"!==typeof a.which&&(a.which=a.keyCode);var b=z(a);b&&("keyup"==a.type&&y===b?y=!1:k.handleKey(b,F(a),a))}function m(a,g,t,f){function h(c){return function(){x=c;++p[a];clearTimeout(q);q=setTimeout(b,1E3)}}function l(g){c(t,g,a);"keyup"!==f&&(y=z(g));setTimeout(b,10)}for(var d=p[a]=0;d<g.length;++d){var e=d+1===g.length?l:h(f||
A(g[d+1]).action);n(g[d],e,f,a,d)}}function n(a,b,c,f,d){k._directMap[a+":"+c]=b;a=a.replace(/\s+/g," ");var e=a.split(" ");1<e.length?m(a,e,b,c):(c=A(a,c),k._callbacks[c.key]=k._callbacks[c.key]||[],g(c.key,c.modifiers,{type:c.action},f,a,d),k._callbacks[c.key][f?"unshift":"push"]({callback:b,modifiers:c.modifiers,action:c.action,seq:f,level:d,combo:a}))}var k=this;a=a||u;if(!(k instanceof d))return new d(a);k.target=a;k._callbacks={};k._directMap={};var p={},q,y=!1,r=!1,x=!1;k._handleKey=function(a,
d,e){var f=g(a,d,e),h;d={};var k=0,l=!1;for(h=0;h<f.length;++h)f[h].seq&&(k=Math.max(k,f[h].level));for(h=0;h<f.length;++h)f[h].seq?f[h].level==k&&(l=!0,d[f[h].seq]=1,c(f[h].callback,e,f[h].combo,f[h].seq)):l||c(f[h].callback,e,f[h].combo);f="keypress"==e.type&&r;e.type!=x||w(a)||f||b(d);r=l&&"keydown"==e.type};k._bindMultiple=function(a,b,c){for(var d=0;d<a.length;++d)n(a[d],b,c)};v(a,"keypress",e);v(a,"keydown",e);v(a,"keyup",e)}if(q){var n={8:"backspace",9:"tab",13:"enter",16:"shift",17:"ctrl",
18:"alt",20:"capslock",27:"esc",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down",45:"ins",46:"del",91:"meta",93:"meta",224:"meta"},r={106:"*",107:"+",109:"-",110:".",111:"/",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},C={"~":"`","!":"1","@":"2","#":"3",$:"4","%":"5","^":"6","&":"7","*":"8","(":"9",")":"0",_:"-","+":"=",":":";",'"':"'","<":",",">":".","?":"/","|":"\\"},B={option:"alt",command:"meta","return":"enter",
escape:"esc",plus:"+",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?"meta":"ctrl"},p;for(c=1;20>c;++c)n[111+c]="f"+c;for(c=0;9>=c;++c)n[c+96]=c.toString();d.prototype.bind=function(a,b,c){a=a instanceof Array?a:[a];this._bindMultiple.call(this,a,b,c);return this};d.prototype.unbind=function(a,b){return this.bind.call(this,a,function(){},b)};d.prototype.trigger=function(a,b){if(this._directMap[a+":"+b])this._directMap[a+":"+b]({},a);return this};d.prototype.reset=function(){this._callbacks={};
this._directMap={};return this};d.prototype.stopCallback=function(a,b){if(-1<(" "+b.className+" ").indexOf(" mousetrap ")||D(b,this.target))return!1;if("composedPath"in a&&"function"===typeof a.composedPath){var c=a.composedPath()[0];c!==a.target&&(b=c)}return"INPUT"==b.tagName||"SELECT"==b.tagName||"TEXTAREA"==b.tagName||b.isContentEditable};d.prototype.handleKey=function(){return this._handleKey.apply(this,arguments)};d.addKeycodes=function(a){for(var b in a)a.hasOwnProperty(b)&&(n[b]=a[b]);p=null};
d.init=function(){var a=d(u),b;for(b in a)"_"!==b.charAt(0)&&(d[b]=function(b){return function(){return a[b].apply(a,arguments)}}(b))};d.init();q.Mousetrap=d;"undefined"!==typeof module&&module.exports&&(module.exports=d);"function"===typeof define&&define.amd&&define(function(){return d})}})("undefined"!==typeof window?window:null,"undefined"!==typeof window?document:null);
/* mousetrap v1.6.5 craig.is/killing/mice */

// prettier-ignore
!function(t,e){!function t(e,n,a,i){var o=!!(e.Worker&&e.Blob&&e.Promise&&e.OffscreenCanvas&&e.OffscreenCanvasRenderingContext2D&&e.HTMLCanvasElement&&e.HTMLCanvasElement.prototype.transferControlToOffscreen&&e.URL&&e.URL.createObjectURL);function r(){}function l(t){var a=n.exports.Promise,i=void 0!==a?a:e.Promise;return"function"==typeof i?new i(t):(t(r,r),null)}var c,s,u,h,f,d,m,g,b,v=(u=Math.floor(1e3/60),h={},f=0,"function"==typeof requestAnimationFrame&&"function"==typeof cancelAnimationFrame?(c=function(t){var e=Math.random();return h[e]=requestAnimationFrame((function n(a){f===a||f+u-1<a?(f=a,delete h[e],t()):h[e]=requestAnimationFrame(n)})),e},s=function(t){h[t]&&cancelAnimationFrame(h[t])}):(c=function(t){return setTimeout(t,u)},s=function(t){return clearTimeout(t)}),{frame:c,cancel:s}),M=(g={},function(){if(d)return d;if(!a&&o){var e=["var CONFETTI, SIZE = {}, module = {};","("+t.toString()+")(this, module, true, SIZE);","onmessage = function(msg) {","  if (msg.data.options) {","    CONFETTI(msg.data.options).then(function () {","      if (msg.data.callback) {","        postMessage({ callback: msg.data.callback });","      }","    });","  } else if (msg.data.reset) {","    CONFETTI && CONFETTI.reset();","  } else if (msg.data.resize) {","    SIZE.width = msg.data.resize.width;","    SIZE.height = msg.data.resize.height;","  } else if (msg.data.canvas) {","    SIZE.width = msg.data.canvas.width;","    SIZE.height = msg.data.canvas.height;","    CONFETTI = module.exports.create(msg.data.canvas);","  }","}"].join("\n");try{d=new Worker(URL.createObjectURL(new Blob([e])))}catch(t){return void 0!==typeof console&&"function"==typeof console.warn&&console.warn("🎊 Could not load worker",t),null}!function(t){function e(e,n){t.postMessage({options:e||{},callback:n})}t.init=function(e){var n=e.transferControlToOffscreen();t.postMessage({canvas:n},[n])},t.fire=function(n,a,i){if(m)return e(n,null),m;var o=Math.random().toString(36).slice(2);return m=l((function(a){function r(e){e.data.callback===o&&(delete g[o],t.removeEventListener("message",r),m=null,i(),a())}t.addEventListener("message",r),e(n,o),g[o]=r.bind(null,{data:{callback:o}})}))},t.reset=function(){for(var e in t.postMessage({reset:!0}),g)g[e](),delete g[e]}}(d)}return d}),p={particleCount:50,angle:90,spread:45,startVelocity:45,decay:.9,gravity:1,drift:0,ticks:200,x:.5,y:.5,shapes:["square","circle"],zIndex:100,colors:["#26ccff","#a25afd","#ff5e7e","#88ff5a","#fcff42","#ffa62d","#ff36ff"],disableForReducedMotion:!1,scalar:1};function y(t,e,n){return function(t,e){return e?e(t):t}(t&&null!=t[e]?t[e]:p[e],n)}function w(t){return t<0?0:Math.floor(t)}function x(t){return parseInt(t,16)}function C(t){return t.map(T)}function T(t){var e=String(t).replace(/[^0-9a-f]/gi,"");return e.length<6&&(e=e[0]+e[0]+e[1]+e[1]+e[2]+e[2]),{r:x(e.substring(0,2)),g:x(e.substring(2,4)),b:x(e.substring(4,6))}}function I(t){t.width=document.documentElement.clientWidth,t.height=document.documentElement.clientHeight}function k(t){var e=t.getBoundingClientRect();t.width=e.width,t.height=e.height}function E(t,e,n,o,r){var c,s,u=e.slice(),h=t.getContext("2d"),f=l((function(e){function l(){c=s=null,h.clearRect(0,0,o.width,o.height),r(),e()}c=v.frame((function e(){!a||o.width===i.width&&o.height===i.height||(o.width=t.width=i.width,o.height=t.height=i.height),o.width||o.height||(n(t),o.width=t.width,o.height=t.height),h.clearRect(0,0,o.width,o.height),u=u.filter((function(t){return function(t,e){e.x+=Math.cos(e.angle2D)*e.velocity+e.drift,e.y+=Math.sin(e.angle2D)*e.velocity+e.gravity,e.wobble+=e.wobbleSpeed,e.velocity*=e.decay,e.tiltAngle+=.1,e.tiltSin=Math.sin(e.tiltAngle),e.tiltCos=Math.cos(e.tiltAngle),e.random=Math.random()+2,e.wobbleX=e.x+10*e.scalar*Math.cos(e.wobble),e.wobbleY=e.y+10*e.scalar*Math.sin(e.wobble);var n=e.tick++/e.totalTicks,a=e.x+e.random*e.tiltCos,i=e.y+e.random*e.tiltSin,o=e.wobbleX+e.random*e.tiltCos,r=e.wobbleY+e.random*e.tiltSin;if(t.fillStyle="rgba("+e.color.r+", "+e.color.g+", "+e.color.b+", "+(1-n)+")",t.beginPath(),"circle"===e.shape)t.ellipse?t.ellipse(e.x,e.y,Math.abs(o-a)*e.ovalScalar,Math.abs(r-i)*e.ovalScalar,Math.PI/10*e.wobble,0,2*Math.PI):function(t,e,n,a,i,o,r,l,c){t.save(),t.translate(e,n),t.rotate(o),t.scale(a,i),t.arc(0,0,1,r,l,c),t.restore()}(t,e.x,e.y,Math.abs(o-a)*e.ovalScalar,Math.abs(r-i)*e.ovalScalar,Math.PI/10*e.wobble,0,2*Math.PI);else if("star"===e.shape)for(var l=Math.PI/2*3,c=4*e.scalar,s=8*e.scalar,u=e.x,h=e.y,f=5,d=Math.PI/f;f--;)u=e.x+Math.cos(l)*s,h=e.y+Math.sin(l)*s,t.lineTo(u,h),l+=d,u=e.x+Math.cos(l)*c,h=e.y+Math.sin(l)*c,t.lineTo(u,h),l+=d;else t.moveTo(Math.floor(e.x),Math.floor(e.y)),t.lineTo(Math.floor(e.wobbleX),Math.floor(i)),t.lineTo(Math.floor(o),Math.floor(r)),t.lineTo(Math.floor(a),Math.floor(e.wobbleY));return t.closePath(),t.fill(),e.tick<e.totalTicks}(h,t)})),u.length?c=v.frame(e):l()})),s=l}));return{addFettis:function(t){return u=u.concat(t),f},canvas:t,promise:f,reset:function(){c&&v.cancel(c),s&&s()}}}function S(t,n){var a,i=!t,r=!!y(n||{},"resize"),c=y(n,"disableForReducedMotion",Boolean),s=o&&!!y(n||{},"useWorker")?M():null,u=i?I:k,h=!(!t||!s)&&!!t.__confetti_initialized,f="function"==typeof matchMedia&&matchMedia("(prefers-reduced-motion)").matches;function d(e,n,i){for(var o,r,l,c,s,h=y(e,"particleCount",w),f=y(e,"angle",Number),d=y(e,"spread",Number),m=y(e,"startVelocity",Number),g=y(e,"decay",Number),b=y(e,"gravity",Number),v=y(e,"drift",Number),M=y(e,"colors",C),p=y(e,"ticks",Number),x=y(e,"shapes"),T=y(e,"scalar"),I=function(t){var e=y(t,"origin",Object);return e.x=y(e,"x",Number),e.y=y(e,"y",Number),e}(e),k=h,S=[],F=t.width*I.x,N=t.height*I.y;k--;)S.push((o={x:F,y:N,angle:f,spread:d,startVelocity:m,color:M[k%M.length],shape:x[(c=0,s=x.length,Math.floor(Math.random()*(s-c))+c)],ticks:p,decay:g,gravity:b,drift:v,scalar:T},r=void 0,l=void 0,r=o.angle*(Math.PI/180),l=o.spread*(Math.PI/180),{x:o.x,y:o.y,wobble:10*Math.random(),wobbleSpeed:Math.min(.11,.1*Math.random()+.05),velocity:.5*o.startVelocity+Math.random()*o.startVelocity,angle2D:-r+(.5*l-Math.random()*l),tiltAngle:(.5*Math.random()+.25)*Math.PI,color:o.color,shape:o.shape,tick:0,totalTicks:o.ticks,decay:o.decay,drift:o.drift,random:Math.random()+2,tiltSin:0,tiltCos:0,wobbleX:0,wobbleY:0,gravity:3*o.gravity,ovalScalar:.6,scalar:o.scalar}));return a?a.addFettis(S):(a=E(t,S,u,n,i)).promise}function m(n){var o=c||y(n,"disableForReducedMotion",Boolean),m=y(n,"zIndex",Number);if(o&&f)return l((function(t){t()}));i&&a?t=a.canvas:i&&!t&&(t=function(t){var e=document.createElement("canvas");return e.style.position="fixed",e.style.top="0px",e.style.left="0px",e.style.pointerEvents="none",e.style.zIndex=t,e}(m),document.body.appendChild(t)),r&&!h&&u(t);var g={width:t.width,height:t.height};function b(){if(s){var e={getBoundingClientRect:function(){if(!i)return t.getBoundingClientRect()}};return u(e),void s.postMessage({resize:{width:e.width,height:e.height}})}g.width=g.height=null}function v(){a=null,r&&e.removeEventListener("resize",b),i&&t&&(document.body.removeChild(t),t=null,h=!1)}return s&&!h&&s.init(t),h=!0,s&&(t.__confetti_initialized=!0),r&&e.addEventListener("resize",b,!1),s?s.fire(n,g,v):d(n,g,v)}return m.reset=function(){s&&s.reset(),a&&a.reset()},m}function F(){return b||(b=S(null,{useWorker:!0,resize:!0})),b}n.exports=function(){return F().apply(this,arguments)},n.exports.reset=function(){F().reset()},n.exports.create=S}(function(){return void 0!==t?t:"undefined"!=typeof self?self:this||{}}(),e,!1),t.confetti=e.exports}(window,{});
// https://github.com/catdad/canvas-confetti
;

;(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory())
    : typeof define === "function" && define.amd
    ? define(factory)
    : ((global = typeof globalThis !== "undefined" ? globalThis : global || self), (global.autocomplete = factory()))
})(this, function() {
  "use strict"

  /**
   * Copyright (c) 2016 Denys Krasnoshchok
   *
   * Homepage: https://smartscheduling.com/en/documentation/autocomplete
   * Source: https://github.com/kraaden/autocomplete
   *
   * MIT License
   */
  function autocomplete(settings) {
    // just an alias to minimize JS file size
    var doc = document
    var container = settings.container || doc.createElement("div")
    container.id = container.id || "autocomplete-" + uid()
    var containerStyle = container.style
    var debounceWaitMs = settings.debounceWaitMs || 0
    var preventSubmit = settings.preventSubmit || false
    var disableAutoSelect = settings.disableAutoSelect || false
    var customContainerParent = container.parentElement
    var items = []
    var inputValue = ""
    var minLen = 2
    var showOnFocus = settings.showOnFocus
    var selected
    var fetchCounter = 0
    var debounceTimer
    var destroyed = false
    if (settings.minLength !== undefined) {
      minLen = settings.minLength
    }
    if (!settings.input) {
      throw new Error("input undefined")
    }
    var input = settings.input
    container.className = "autocomplete " + (settings.className || "")
    container.setAttribute("role", "listbox")
    input.setAttribute("role", "combobox")
    input.setAttribute("aria-expanded", "false")
    input.setAttribute("aria-autocomplete", "list")
    input.setAttribute("aria-controls", container.id)
    input.setAttribute("aria-owns", container.id)
    input.setAttribute("aria-activedescendant", "")
    input.setAttribute("aria-haspopup", "listbox")
    // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning
    containerStyle.position = "absolute"
    /**
     * Generate a very complex textual ID that greatly reduces the chance of a collision with another ID or text.
     */
    function uid() {
      return (
        Date.now().toString(36) +
        Math.random()
          .toString(36)
          .substring(2)
      )
    }
    /**
     * Detach the container from DOM
     */
    function detach() {
      var parent = container.parentNode
      if (parent) {
        parent.removeChild(container)
      }
    }
    /**
     * Clear debouncing timer if assigned
     */
    function clearDebounceTimer() {
      if (debounceTimer) {
        window.clearTimeout(debounceTimer)
      }
    }
    /**
     * Attach the container to DOM
     */
    function attach() {
      if (!container.parentNode) {
        ;(customContainerParent || doc.body).appendChild(container)
      }
    }
    /**
     * Check if container for autocomplete is displayed
     */
    function containerDisplayed() {
      return !!container.parentNode
    }
    /**
     * Clear autocomplete state and hide container
     */
    function clear() {
      // prevent the update call if there are pending AJAX requests
      fetchCounter++
      items = []
      inputValue = ""
      selected = undefined
      input.setAttribute("aria-activedescendant", "")
      input.setAttribute("aria-expanded", "false")
      detach()
    }
    /**
     * Update autocomplete position
     */
    function updatePosition() {
      if (!containerDisplayed()) {
        return
      }
      input.setAttribute("aria-expanded", "true")
      containerStyle.height = "auto"
      containerStyle.width = input.offsetWidth + "px"
      var maxHeight = 0
      var inputRect
      function calc() {
        var docEl = doc.documentElement
        var clientTop = docEl.clientTop || doc.body.clientTop || 0
        var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0
        var scrollTop = window.pageYOffset || docEl.scrollTop
        var scrollLeft = window.pageXOffset || docEl.scrollLeft
        inputRect = input.getBoundingClientRect()
        var top = inputRect.top + input.offsetHeight + scrollTop - clientTop
        var left = inputRect.left + scrollLeft - clientLeft
        containerStyle.top = top + "px"
        containerStyle.left = left + "px"
        maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight)
        if (maxHeight < 0) {
          maxHeight = 0
        }
        containerStyle.top = top + "px"
        containerStyle.bottom = ""
        containerStyle.left = left + "px"
        containerStyle.maxHeight = maxHeight + "px"
      }
      // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)
      calc()
      calc()
      if (settings.customize && inputRect) {
        settings.customize(input, inputRect, container, maxHeight)
      }
    }
    /**
     * Redraw the autocomplete div element with suggestions
     */
    function update() {
      container.innerHTML = ""
      input.setAttribute("aria-activedescendant", "")
      // function for rendering autocomplete suggestions
      var render = function(item, _, __) {
        var itemElement = doc.createElement("div")
        itemElement.textContent = item.label || ""
        return itemElement
      }
      if (settings.render) {
        render = settings.render
      }
      // function to render autocomplete groups
      var renderGroup = function(groupName, _) {
        var groupDiv = doc.createElement("div")
        groupDiv.textContent = groupName
        return groupDiv
      }
      if (settings.renderGroup) {
        renderGroup = settings.renderGroup
      }
      var fragment = doc.createDocumentFragment()
      var prevGroup = uid()
      items.forEach(function(item, index) {
        if (item.group && item.group !== prevGroup) {
          prevGroup = item.group
          var groupDiv = renderGroup(item.group, inputValue)
          if (groupDiv) {
            groupDiv.className += " group"
            fragment.appendChild(groupDiv)
          }
        }
        var div = render(item, inputValue, index)
        if (div) {
          div.id = container.id + "_" + index
          div.setAttribute("role", "option")
          div.addEventListener("click", function(ev) {
            settings.onSelect(item, input)
            clear()
            ev.preventDefault()
            ev.stopPropagation()
          })
          if (item === selected) {
            div.className += " selected"
            div.setAttribute("aria-selected", "true")
            input.setAttribute("aria-activedescendant", div.id)
          }
          fragment.appendChild(div)
        }
      })
      container.appendChild(fragment)
      if (items.length < 1) {
        if (settings.emptyMsg) {
          var empty = doc.createElement("div")
          empty.id = container.id + "_" + uid()
          empty.className = "empty"
          empty.textContent = settings.emptyMsg
          container.appendChild(empty)
          input.setAttribute("aria-activedescendant", empty.id)
        } else {
          clear()
          return
        }
      }
      attach()
      updatePosition()
      updateScroll()
    }
    function updateIfDisplayed() {
      if (containerDisplayed()) {
        update()
      }
    }
    function resizeEventHandler() {
      updateIfDisplayed()
    }
    function scrollEventHandler(e) {
      if (e.target !== container) {
        updateIfDisplayed()
      } else {
        e.preventDefault()
      }
    }
    function inputEventHandler() {
      fetch(0 /* Keyboard */)
    }
    /**
     * Automatically move scroll bar if selected item is not visible
     */
    function updateScroll() {
      var elements = container.getElementsByClassName("selected")
      if (elements.length > 0) {
        var element = elements[0]
        // make group visible
        var previous = element.previousElementSibling
        if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {
          element = previous
        }
        if (element.offsetTop < container.scrollTop) {
          container.scrollTop = element.offsetTop
        } else {
          var selectBottom = element.offsetTop + element.offsetHeight
          var containerBottom = container.scrollTop + container.offsetHeight
          if (selectBottom > containerBottom) {
            container.scrollTop += selectBottom - containerBottom
          }
        }
      }
    }
    function selectPreviousSuggestion() {
      var index = items.indexOf(selected)
      selected = index === -1 ? undefined : items[(index + items.length - 1) % items.length]
    }
    function selectNextSuggestion() {
      var index = items.indexOf(selected)
      selected = items.length < 1 ? undefined : index === -1 ? items[0] : items[(index + 1) % items.length]
    }
    function handleArrowAndEscapeKeys(ev, key) {
      var containerIsDisplayed = containerDisplayed()
      if (key === "Escape") {
        clear()
      } else {
        if (!containerIsDisplayed || items.length < 1) {
          return
        }
        key === "ArrowUp" ? selectPreviousSuggestion() : selectNextSuggestion()
        update()
      }
      ev.preventDefault()
      if (containerIsDisplayed) {
        ev.stopPropagation()
      }
    }
    function handleEnterKey(ev) {
      if (selected) {
        settings.onSelect(selected, input)
        clear()
      }
      if (preventSubmit && input.value) {
        // Monkey patched this line. If someone hits enter and the form is blank, do not prevent default=> submit form
        ev.preventDefault()
      }
    }
    function keydownEventHandler(ev) {
      var key = ev.key
      switch (key) {
        case "ArrowUp":
        case "ArrowDown":
        case "Escape":
          handleArrowAndEscapeKeys(ev, key)
          break
        case "Enter":
          handleEnterKey(ev)
          break
      }
    }
    function focusEventHandler() {
      if (showOnFocus) {
        fetch(1 /* Focus */)
      }
    }
    function fetch(trigger) {
      if (input.value.length >= minLen || trigger === 1 /* Focus */) {
        clearDebounceTimer()
        debounceTimer = window.setTimeout(
          function() {
            return startFetch(input.value, trigger, input.selectionStart || 0)
          },
          trigger === 0 /* Keyboard */ || trigger === 2 /* Mouse */ ? debounceWaitMs : 0
        )
      } else {
        clear()
      }
    }
    function startFetch(inputText, trigger, cursorPos) {
      if (destroyed) return
      var savedFetchCounter = ++fetchCounter
      settings.fetch(
        inputText,
        function(elements) {
          if (fetchCounter === savedFetchCounter && elements) {
            items = elements
            inputValue = inputText
            selected = items.length < 1 || disableAutoSelect ? undefined : items[0]
            update()
          }
        },
        trigger,
        cursorPos
      )
    }
    function keyupEventHandler(e) {
      if (settings.keyup) {
        settings.keyup({
          event: e,
          fetch: function() {
            return fetch(0 /* Keyboard */)
          }
        })
        return
      }
      if (!containerDisplayed() && e.key === "ArrowDown") {
        fetch(0 /* Keyboard */)
      }
    }
    function clickEventHandler(e) {
      settings.click &&
        settings.click({
          event: e,
          fetch: function() {
            return fetch(2 /* Mouse */)
          }
        })
    }
    function blurEventHandler() {
      // when an item is selected by mouse click, the blur event will be initiated before the click event and remove DOM elements,
      // so that the click event will never be triggered. In order to avoid this issue, DOM removal should be delayed.
      setTimeout(function() {
        if (doc.activeElement !== input) {
          clear()
        }
      }, 200)
    }
    function manualFetch() {
      startFetch(input.value, 3 /* Manual */, input.selectionStart || 0)
    }
    /**
     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called
     */
    container.addEventListener("mousedown", function(evt) {
      evt.stopPropagation()
      evt.preventDefault()
    })
    /**
     * Fixes #30: autocomplete closes when scrollbar is clicked in IE
     * See: https://stackoverflow.com/a/9210267/13172349
     */
    container.addEventListener("focus", function() {
      return input.focus()
    })
    /**
     * This function will remove DOM elements and clear event handlers
     */
    function destroy() {
      input.removeEventListener("focus", focusEventHandler)
      input.removeEventListener("keyup", keyupEventHandler)
      input.removeEventListener("click", clickEventHandler)
      input.removeEventListener("keydown", keydownEventHandler)
      input.removeEventListener("input", inputEventHandler)
      input.removeEventListener("blur", blurEventHandler)
      window.removeEventListener("resize", resizeEventHandler)
      doc.removeEventListener("scroll", scrollEventHandler, true)
      input.removeAttribute("role")
      input.removeAttribute("aria-expanded")
      input.removeAttribute("aria-autocomplete")
      input.removeAttribute("aria-controls")
      input.removeAttribute("aria-activedescendant")
      input.removeAttribute("aria-owns")
      input.removeAttribute("aria-haspopup")
      clearDebounceTimer()
      clear()
      destroyed = true
    }
    // setup event handlers
    input.addEventListener("keyup", keyupEventHandler)
    input.addEventListener("click", clickEventHandler)
    input.addEventListener("keydown", keydownEventHandler)
    input.addEventListener("input", inputEventHandler)
    input.addEventListener("blur", blurEventHandler)
    input.addEventListener("focus", focusEventHandler)
    window.addEventListener("resize", resizeEventHandler)
    doc.addEventListener("scroll", scrollEventHandler, true)
    return {
      destroy: destroy,
      fetch: manualFetch
    }
  }

  return autocomplete
})
//# sourceMappingURL=autocomplete.js.map
;

class TrueBaseBrowserApp {
  static getApp() {
    if (!window.app) window.app = new TrueBaseBrowserApp()
    return window.app
  }

  localStorageKeys = {
    email: "email",
    password: "password",
    staged: "staged",
    author: "author",
    confetti: "confetti"
  }

  get store() {
    return window.localStorage
  }

  get loggedInUser() {
    return this.store.getItem(this.localStorageKeys.email)
  }

  get isLoggedIn() {
    return !!this.loggedInUser
  }

  get author() {
    try {
      const author = this.store.getItem(this.localStorageKeys.author)
      if (author) return author
      const email = this.loggedInUser
      if (!email) return ""
      const name = email.split("@")[0]
      return `${name} <${email}>`
    } catch (err) {
      console.error(err)
    }

    return ""
  }

  render() {
    this.initAutocomplete("trueBaseThemeHeaderSearch")
    return this
  }

  // This method is currently used to enable autocomplete on: the header search, front page search, 404 page search
  initAutocomplete(elementId) {
    const autocompleteSearchIndex = window.autocompleteJs || [] // todo: cleanup?
    const input = document.getElementById(elementId)
    const urlParams = new URLSearchParams(window.location.search)
    const query = urlParams.get("q")
    if (query) input.value = query
    autocomplete({
      input,
      minLength: 1,
      emptyMsg: "No matching entities found",
      preventSubmit: true,
      fetch: async (query, update) => {
        const text = query.toLowerCase()
        const suggestions = autocompleteSearchIndex.filter(entity => entity.label.toLowerCase().startsWith(text))

        const htmlEncodedQuery = query.replace(/</g, "&lt;")

        suggestions.push({
          label: `Full text search for "${htmlEncodedQuery}"`,
          id: "",
          url: `/fullTextSearch?q=${htmlEncodedQuery}`
        })
        update(suggestions)
      },
      onSelect: item => {
        const { url, id } = item
        if (id) window.location = url
        else window.location = "/fullTextSearch?q=" + encodeURIComponent(input.value)
      }
    })
  }

  hideUserAccountsButtons() {
    jQuery(".loggedIn,.notLoggedIn").hide()
  }

  revealUserAccountButtons() {
    if (this.loggedInUser) jQuery("#logoutButton").attr("title", `Logout of ${this.store.getItem(this.localStorageKeys.email)}`)
    else {
      jQuery(".loggedIn").hide()
      jQuery(".notLoggedIn").show()
    }
  }

  logoutCommand() {
    this.store.clear()
    this.redirectToLogoutPage()
  }

  redirectToLogoutPage() {
    window.location = "/loggedOut.html"
  }

  async attemptLoginCommand() {
    const params = new URLSearchParams(window.location.search)
    const email = params.get("email")
    const password = params.get("password")
    window.history.replaceState({}, null, "login.html")
    if (this.loggedInUser) {
      jQuery("#loginResult").html(`You are already logged in as ${this.loggedInUser}`)
      return
    }
    if (!email || !password) {
      jQuery("#loginResult").html(`Email and password not in url. Try clicking your link again? If you think this is a bug please email us.`)
      return
    }

    const response = await fetch("/login", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ email, password })
    })

    const el = document.querySelector("#loginResult")
    if (response.status === 200) {
      el.innerHTML = `You are logged in as ${email}`
      this.store.setItem(this.localStorageKeys.email, email)
      this.store.setItem(this.localStorageKeys.password, password)
      this.hideUserAccountsButtons()
      this.revealUserAccountButtons()
      this.shootConfettiCommand()
    } else {
      console.error(response)
      el.innerHTML = `Sorry. Something went wrong. If you think this is a bug please email us.`
    }
  }

  get loginMessageElement() {
    return document.querySelector("#loginMessage")
  }

  get loginEmailElement() {
    return document.querySelector("#loginEmail")
  }

  async verifyEmailAndSendLoginLinkCommand() {
    const { loginEmailElement, loginMessageElement } = this
    const email = loginEmailElement.value
    const htmlEscapedEmail = Utils.htmlEscaped(email)
    loginMessageElement.style.display = "inline-block"
    if (!Utils.isValidEmail(email)) {
      loginMessageElement.innerHTML = `<span class="error">'${htmlEscapedEmail}' is not a valid email.</span>`
      return
    }
    jQuery(".notLoggedIn").hide()

    let elapsed = 0
    const interval = setInterval(() => (loginMessageElement.innerHTML = `Sending login link... ${++elapsed / 10}s`), 100)

    const response = await fetch("/sendLoginLink", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ email })
    })
    clearInterval(interval)
    const text = await response.text()

    if (response.status === 200) loginMessageElement.innerHTML = `Login link sent to '${htmlEscapedEmail}'.`
    else loginMessageElement.innerHTML = `<span class="error">Error: ${text}</span>`
  }

  renderSearchPage() {
    this.startTQLCodeMirror()
    if (this.isLoggedIn) {
      if (this.store.getItem(this.localStorageKeys.confetti) === "true") {
        this.store.clear(this.localStorageKeys.confetti)
        this.shootConfettiCommand()
      }
      jQuery("#publishQuery").html(`<button onclick="app.publishQueryCommand()">Publish query</button>`)
    }
  }

  async publishQueryCommand() {
    const response = await fetch("/publishQuery", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ author: this.author, query: this.value })
    })
    const json = await response.json()
    if (response.status === 200) {
      this.store.setItem(this.localStorageKeys.confetti, "true")
      window.location = `/queries/${json.permalink}.html`
    } else jQuery("#publishQuery").html(`<span class="error">Error: ${response}</span>`)
  }

  startTQLCodeMirror() {
    this.fileParser = tqlParser
    this.codeMirrorInstance = new GrammarCodeMirrorMode("custom", () => tqlParser, undefined, CodeMirror).register().fromTextAreaWithAutocomplete(document.getElementById("tqlInput"), {
      lineWrapping: false,
      lineNumbers: false
    })

    this.codeMirrorInstance.setSize(400, 100)
    this.codeMirrorInstance.on("keyup", () => this._onCodeKeyUp())
  }

  _onCodeKeyUp() {
    const code = this.value
    if (this._code === code) return
    this._code = code
    this.program = new this.fileParser(code)
    const errs = this.program.scopeErrors.concat(this.program.getAllErrors())

    const errMessage = errs.length ? errs.map(err => err.message).join(" ") : "&nbsp;"
    document.getElementById("tqlErrors").innerHTML = errMessage
  }

  get value() {
    return this.codeMirrorInstance.getValue()
  }

  async renderEditPage() {
    this.renderCodeEditorStuff()
    await this.initEditData()
  }

  renderCreatePage() {
    this.renderCodeEditorStuff()
    try {
      // todo: there's gotta be a better way
      const example = new this.fileParser().root.definition.filter(node => node.has("root"))[0].examples[0].childrenToString()
      document.getElementById("exampleSection").innerHTML = `Example:<br><pre>${example}</pre>`
    } catch (err) {
      console.log(err)
    }
  }

  renderCodeEditorStuff() {
    this.renderForm()
    this.startCodeMirrorEditor()
    this.bindStageButton()
    this.renderStage()
  }

  async initEditData() {
    const { filename, currentFileId } = this
    const localValue = this.stagedFiles.getNode(filename)
    let response = await fetch(`/edit.json?id=${currentFileId}`)
    const data = await response.json()

    if (data.error) return (document.getElementById("formHolder").innerHTML = data.error)

    const id = this.currentFileId
    document.getElementById("pageTitle").innerHTML = `Improve <i><a href="/concepts/${id}.html">${filename}</a></i>`

    this.codeMirrorInstance.setValue(localValue ? localValue.childrenToString() : data.content)
    const title = new TreeNode(this.value).get("title") || filename
    document.getElementById("topUnansweredQuestions").innerHTML = `<h3>Open questions about ${title}</h3>
    ${data.topUnansweredQuestions
      .slice(0, 8)
      .map(question => `<div title="${question.column}">${question.question}</div>`)
      .join("")}`

    document.getElementById("helpfulResearchLinks").innerHTML = data.helpfulResearchLinks

    Mousetrap.bind("left", evt => {
      window.location = `/editPrevious/${id}`
      return false
    })

    Mousetrap.bind("right", evt => {
      window.location = `/editNext/${id}`
      return false
    })
  }

  renderStage() {
    const { stagedFiles } = this

    const isLoggedIn = false // Temporarily disabling login

    const fileCount = stagedFiles.length
    const el = document.getElementById("stagedStatus")
    el.style.display = "none"
    if (!stagedFiles.length) return
    el.innerHTML = `<div>You have <b>${fileCount} staged file${fileCount > 1 ? "s" : ""}</b> ready to submit. ${isLoggedIn ? "Author: " : ""}<span id="authorLabel" class="linkButton" onClick="app.changeAuthor()"></span></div>
 <textarea id="patch" name="patch" readonly></textarea><br>
 <input type="hidden" name="author" id="author" />
 ${isLoggedIn ? '<input type="submit" value="Commit and push" id="saveCommitAndPushButton"/>' : "" /* "<a href='/loginOrJoin.html'>Login</a> to submit." */}
  <a class="linkButton" onClick="app.clearChanges()">Clear local changes</a>`
    el.style.display = "block"
    document.getElementById("patch").value = stagedFiles.asString
    document.getElementById("authorLabel").innerHTML = Utils.htmlEscaped(this.author)
    document.getElementById("author").value = this.author
  }

  bindStageButton() {
    const el = document.getElementById("stageButton")
    el.onclick = () => {
      const tree = this.stagedFiles
      tree.touchNode(this.filename).setChildren(this.value)
      this.setStage(tree.asString)
    }

    Mousetrap.bind("mod+s", evt => {
      el.click()
      evt.preventDefault()
      return false
    })
  }

  setStage(str) {
    this.store.setItem(this.localStorageKeys.staged, str)
    this.renderStage()
  }

  get stagedFiles() {
    const str = this.store.getItem(this.localStorageKeys.staged)
    return str ? new TreeNode(str) : new TreeNode()
  }

  renderForm() {
    document.getElementById("formHolder").innerHTML = `<form method="POST" action="/saveCommitAndPush" id="stagedStatus" style="display: none;"></form>
<div id="editForm">
 <div class="cell" id="leftCell">
   <textarea id="fileContent"></textarea>
   <div id="tqlErrors"></div> <!-- todo: cleanup. -->
 </div>
 <div class="cell">
   <div id="topUnansweredQuestions"></div>
   <div id="helpfulResearchLinks"></div>
   <div id="exampleSection"></div>
 </div>
 <div>
   <button id="stageButton">Stage</button>
 </div>
</div>`
  }

  clearChanges() {
    if (confirm("Are you sure you want to delete all local changes? This cannot be undone.")) this.setStage("")
  }

  async startCodeMirrorEditor() {
    this.fileParser = pldbParser // replaced at server time.
    this.codeMirrorInstance = new GrammarCodeMirrorMode("custom", () => pldbParser, undefined, CodeMirror).register().fromTextAreaWithAutocomplete(document.getElementById("fileContent"), {
      lineWrapping: false,
      lineNumbers: true
    })

    this.codeMirrorInstance.setSize(this.codeMirrorWidth, 500)
    this.codeMirrorInstance.on("keyup", () => this._onCodeKeyUp())
  }

  get currentFileId() {
    return new URLSearchParams(window.location.search).get("id")
  }

  get fileExtension() {
    return new this.fileParser().fileExtension
  }

  get filename() {
    if (location.pathname.includes("create.html")) return "create"
    return this.currentFileId + "." + this.fileExtension
  }

  get codeMirrorWidth() {
    return document.getElementById("leftCell").width
  }

  get store() {
    return window.localStorage
  }

  saveAuthor(name) {
    try {
      this.store.setItem(this.localStorageKeys.author, name)
    } catch (err) {
      console.error(err)
    }
  }

  changeAuthor() {
    const newValue = prompt(`Enter author name and email formatted like "Breck Yunits <by@breckyunits.com>". This information is recorded in the public Git log.`, this.author)
    if (newValue === "") this.saveAuthor(this.defaultAuthor)
    if (newValue) this.saveAuthor(newValue)
    this.renderStage()
  }

  get route() {
    return location.pathname.split("/")[1]
  }

  renderThankYouCommand(GIT_URL) {
    // todo: clean up vars
    const commit = new URLSearchParams(window.location.search).get("commit") || ""
    document.getElementById("commitHash").innerHTML = `<a href="${GIT_URL}/commit/${commit}">${commit.substring(0, 7)}</a>`
    this.shootConfettiCommand()
  }

  async fetchAndVisualizeDb() {
    const response = await fetch("/visData.json", {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    })

    const json = await response.json()
    if (response.status === 200) {
      this.visualizeDb(json.columns, json.rows)
    }
  }

  visualizeDb(columnValues, rowValues, elementId = "modelVis") {
    // Use the golden ratio for visually appealing image dimensions
    let goldenRatio = 1.618
    let width = Math.round(Math.sqrt((columnValues.length + rowValues.length) * goldenRatio))
    let height = Math.round(width / goldenRatio)
    let canvas = document.createElement("canvas")
    canvas.width = width
    canvas.height = height
    let ctx = canvas.getContext("2d")
    let imageData = ctx.createImageData(width, height)

    const scale = `#ebedf0 8
#c7e9c0 16
#a1d99b 32
#74c476 64
#41ab5d 128
#238b45 256
#005a32 512`

    const hexToRGBA = hex => [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16), 255]

    const thresholds = []
    const colors = []
    scale.split("\n").map(line => {
      const parts = line.split(" ")
      thresholds.push(parseFloat(parts[1]))
      colors.push(hexToRGBA(parts[0]))
    })
    const colorCount = colors.length
    const heatMap = value => {
      if (isNaN(value)) return "" // #ebedf0
      for (let index = 0; index < colorCount; index++) {
        const threshold = thresholds[index]
        if (value <= threshold) return colors[index]
      }
      return colors[colorCount - 1]
    }

    for (let i = 0; i < columnValues.length; i++) {
      let x = i % width
      let y = Math.floor(i / width)
      let pixelIndex = (y * width + x) * 4
      let color = heatMap(columnValues[i])
      if (pixelIndex < imageData.data.length) {
        imageData.data.set(color, pixelIndex)
      }
    }

    let offset = Math.ceil(columnValues.length / width) * width

    for (let i = 0; i < rowValues.length; i++) {
      let x = (i + offset) % width
      let y = Math.floor((i + offset) / width)
      let pixelIndex = (y * width + x) * 4
      let color = heatMap(rowValues[i])
      if (pixelIndex < imageData.data.length) {
        imageData.data.set(color, pixelIndex)
      }
    }

    ctx.putImageData(imageData, 0, 0)

    // Append the image to a specific element on your HTML page
    document.getElementById(elementId).appendChild(canvas)
  }

  shootConfettiCommand(duration = 500) {
    var count = 200
    var defaults = {
      origin: { y: 0.7 }
    }

    function fire(particleRatio, opts) {
      confetti(
        Object.assign({}, defaults, opts, {
          particleCount: Math.floor(count * particleRatio)
        })
      )
    }

    fire(0.25, {
      spread: 26,
      startVelocity: 55
    })
    fire(0.2, {
      spread: 60
    })
    fire(0.35, {
      spread: 100,
      decay: 0.91,
      scalar: 0.8
    })
    fire(0.1, {
      spread: 120,
      startVelocity: 25,
      decay: 0.92,
      scalar: 1.2
    })
    fire(0.1, {
      spread: 120,
      startVelocity: 45
    })
    return this
  }
}
