import ../header.scroll
baseUrl https://pldb.com/concepts/
title dslx

title dslx - Programming language
 hidden

html
 <a class="trueBaseThemePreviousItem" href="rapira.html">&lt;</a>
 <a class="trueBaseThemeNextItem" href="plz.html">&gt;</a>

viewSourceUrl https://github.com/breck7/pldb/blob/main/concepts/dslx.pldb

startColumns 4

<div class="trueBaseThemeQuickLinks"><a href="/edit.html?id=dslx" class="material-symbols-outlined">edit</a></div>

* dslx is a <a href="/search.html?q=select+type%0D%0Awhere+type+%3D+pl">programming language</a> created in 2020.
 link /search.html?q=select+type+appeared%0D%0Awhere+appeared+%3D+2020 2020

dashboard
 #1106 <span title="TotalRank: 1664 Jobs: 103 Users: 2829 Facts: 575 Links: 986">on PLDB</span>
 4 Years Old

* DSLX is a domain specific, functional language to build hardware that can also run effectively as host software. The DSL targets the XLS compiler (by conversion to XLS IR) to enable flows for FPGAs and ASICs (note that other frontends will become available in the future). DSLX mimics Rust, while being an immutable expression-based dataflow DSL with hardware-oriented features; e.g. arbitrary bitwidths, entirely fixed size objects, fully analyzeable call graph, etc. To avoid arbitrary new syntax/semantics choices the DSL mimics Rust where it is reasonably possible; for example, integer conversions all follow the same semantics as Rust.

- dslx first developed in <a href="../lists/originCommunities.html#google">Google</a>
- Read more about dslx on the web: 1.
 https://google.github.io/xls/dslx_reference/ 1.

<br>

codeWithHeader Example from the web:
 fn cast_to_array(x: u6) -&gt; u2[3] {
   x as u2[3]
 }
 
 fn cast_from_array(a: u2[3]) -&gt; u6 {
   a as u6
 }
 
 fn concat_arrays(a: u2[3], b: u2[3]) -&gt; u2[6] {
   a ++ b
 }
 
 test cast_to_array {
   let a_value: u6 = u6:0b011011;
   let a: u2[3] = cast_to_array(a_value);
   let a_array = u2[3]:[1, 2, 3];
   let _ = assert_eq(a, a_array);
   // Note: converting back from array to bits gives the original value.
   let _ = assert_eq(a_value, cast_from_array(a));
 
   let b_value: u6 = u6:0b111001;
   let b_array: u2[3] = u2[3]:[3, 2, 1];
   let b: u2[3] = cast_to_array(b_value);
   let _ = assert_eq(b, b_array);
   let _ = assert_eq(b_value, cast_from_array(b));
 
   // Concatenation of bits is analogous to concatenation of their converted
   // arrays. That is:
   //
   //  convert(concat(a, b)) == concat(convert(a), convert(b))
   let concat_value: u12 = a_value ++ b_value;
   let concat_array: u2[6] = concat_value as u2[6];
   let _ = assert_eq(concat_array, concat_arrays(a_array, b_array));
 
   // Show a few classic &quot;endianness&quot; example using 8-bit array values.
   let x = u32:0xdeadbeef;
   let _ = assert_eq(x as u8[4], u8[4]:[0xde, 0xad, 0xbe, 0xef]);
   let y = u16:0xbeef;
   let _ = assert_eq(y as u8[2], u8[2]:[0xbe, 0xef]);
 
   ()
 }

endColumns

## Language <a href="../lists/features.html">features</a>

treeTable
 row
  Feature Comments
  FeatureLink ../features/hasComments.html
  Supported <span class="hasFeature">✓</span>
  Token 
  Example
   // A comment
 row
  Feature Line Comments
  FeatureLink ../features/hasLineComments.html
  Supported <span class="hasFeature">✓</span>
  Token //
  Example
   // A comment
 row
  Feature Semantic Indentation
  FeatureLink ../features/hasSemanticIndentation.html
  Supported <span class="doesNotHaveFeature">X</span>
  Token 
  Example

keyboardNav rapira.html plz.html

import ../footer.scroll
