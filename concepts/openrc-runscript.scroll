import ../header.scroll
baseUrl https://pldb.io/concepts/
title OpenRC runscript

title OpenRC runscript - Application
 hidden

html
 <a class="trueBaseThemePreviousItem" href="s-algol.html">&lt;</a>
 <a class="trueBaseThemeNextItem" href="ats.html">&gt;</a>

viewSourceUrl https://github.com/breck7/pldb/blob/main/concepts/openrc-runscript.pldb

startColumns 4

<div class="trueBaseThemeQuickLinks"><a href="https://github.com/OpenRC/openrc" class="material-symbols-outlined">code</a> <a href="/edit.html?id=openrc-runscript" class="material-symbols-outlined">edit</a></div>

* OpenRC runscript is an <a href="/search.html?q=select+type%0D%0Awhere+type+%3D+application">application</a> created in 2007 by Roy Marples.
 link /search.html?q=select+type+appeared%0D%0Awhere+appeared+%3D+2007 2007
 link ../lists/creators.html#royMarples Roy Marples

codeWithHeader Source code:
 git clone https://github.com/OpenRC/openrc

dashboard
 #311 on PLDB
 17 Years Old

* OpenRC is basically an interpreter for shell scripts which provides an easy interface to the often complex system commands and daemons. When a service runs a command it first loads its multiplexed configuration file, then its master configuration file, then /etc/rc.conf and finally the script itself. At this point then runs the command given.

- OpenRC runscript is developed on <a href="https://github.com/OpenRC/openrc">GitHub</a> and has 1,109 stars
- OpenRC runscript first developed in <a href="../lists/originCommunities.html#httpsRoyMarplesNameProjects">https://roy.marples.name/projects</a>
- GitHub supports <a href="https://github.com/atom/language-shellscript" title="The package used for syntax highlighting by GitHub Linguist.">syntax highlighting</a> for OpenRC runscript
- Read more about OpenRC runscript on the web: 1.
 http://www.linuxhowtos.org/manpages/8/openrc-run.htm 1.

<br>

codeWithHeader Example from the web:
 #!/sbin/openrc-run
 command=/usr/bin/foo
 command_args=&quot;${foo_args} --bar&quot;
 pidfile=/var/run/foo.pid
 name=&quot;FooBar Daemon&quot;
 
 description=&quot;FooBar is a daemon that eats and drinks&quot;
 extra_commands=&quot;show&quot;
 extra_started_commands=&quot;drink eat&quot;
 description_drink=&quot;Opens mouth and reflexively swallows&quot;
 description_eat=&quot;Chews food in mouth&quot;
 description_show=&quot;Shows what&#39;s in the tummy&quot;
 
 _need_dbus()
 {
     grep -q dbus /etc/foo/plugins
 }
 
 depend()
 {
     # We write a pidfile and to /var/cache, so we need localmount.
     need localmount
     # We can optionally use the network, but it&#39;s not essential.
     use net
     # We should be after bootmisc so that /var/run is cleaned before
     # we put our pidfile there.
     after bootmisc
 
     # Foo may use a dbus plugin.
     # However, if we add the dbus plugin whilst foo is running and
     # stop dbus, we don&#39;t need to stop foo as foo didn&#39;t use dbus.
     config /etc/foo/plugins
     local _need=
     if service_started; then
         _need=`service_get_value need`
     else
         if _need_dbus; then
            _need=&quot;${_need} dbus&quot;
         fi
     fi
     need ${_need}
 }
 
 # This function does any pre-start setup. If it fails, the service will
 # not be started.
 # If you need this function to behave differently for a restart command,
 # you should check the value of RC_CMD for &quot;restart&quot;.
 # This also applies to start_post, stop_pre and stop_post.
 start_pre()
 {
         if [ &quot;$RC_CMD&quot; = restart ]; then
                 # This block will only execute for a restart command. Use a
                 # structure like this if you need special processing for a
                 # restart which you do not need for a normal start.
                 # The function can also fail from here, which will mean that a
                 # restart can fail.
                 # This logic can also be used in start_post, stop_pre and
                 # stop_post.
         fi
     # Ensure that our dirs are correct
     checkpath --directory --owner foo:foo --mode 0775 \
         /var/run/foo /var/cache/foo
 }
 
 start_post()
 {
     # Save our need
     if _need_dbus; then
         service_set_value need dbus
     fi
 }
 
 stop_post() {
     # Clean any spills
     rm -rf /var/cache/foo/*
 }
 
 drink()
 {
     ebegin &quot;Starting to drink&quot;
     ${command} --drink beer
     eend $? &quot;Failed to drink any beer :(&quot;
 }
 
 eat()
 {
     local result=0 retval= ate= food=
     ebegin &quot;Starting to eat&quot;
 
     if yesno &quot;${foo_diet}&quot;; then
         eend 1 &quot;We are on a diet!&quot;
         return 1
     fi
 
     for food in /usr/share/food/*; do
         veinfo &quot;Eating `basename ${food}`&quot;
         ${command} --eat ${food}
         retval=$?
         : $(( result += retval ))
         [ ${retval} = 0 ] &amp;&amp; ate=&quot;${ate} `basename ${food}`&quot;
     done
 
     if eend ${result} &quot;Failed to eat all the food&quot;; then
         service_set_value ate &quot;${ate}&quot;
     fi
 }
 
 show()
 {
     einfo &quot;Foo has eaten: `service_get_value ate`&quot;
 }

codeWithHeader Example from <a href='https://github.com/atom/language-shellscript'>Linguist</a>:
 #!/sbin/openrc-run
 
 description=&quot;Daemon for Advanced Configuration and Power Interface&quot;
 
 extra_started_commands=&quot;reload&quot;
 command=&quot;/usr/sbin/acpid&quot;
 command_args=&quot;$ACPID_ARGS&quot;
 start_stop_daemon_args=&quot;--quiet&quot;
 
 depend() {
 	need localmount
 	use logger
 }
 
 reload() {
 	ebegin &quot;Reloading acpid configuration&quot;
 	start-stop-daemon --exec $command --signal HUP
 	eend $?
 }
 

endColumns

keyboardNav s-algol.html ats.html

import ../footer.scroll
