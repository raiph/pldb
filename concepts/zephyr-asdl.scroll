import ../header.scroll
baseUrl https://pldb.io/concepts/
title zephyr-asdl

title zephyr-asdl - Grammar language
 hidden

html
 <a class="trueBaseThemePreviousItem" href="component-pascal.html">&lt;</a>
 <a class="trueBaseThemeNextItem" href="joy.html">&gt;</a>

viewSourceUrl https://github.com/breck7/pldb/blob/main/concepts/zephyr-asdl.pldb

startColumns 4

<div class="trueBaseThemeQuickLinks"><a href="/edit.html?id=zephyr-asdl" class="material-symbols-outlined">edit</a></div>

* zephyr-asdl is a <a href="/search.html?q=select+type%0D%0Awhere+type+%3D+grammarLanguage">grammar language</a> created in 1997.
 link /search.html?q=select+type+appeared%0D%0Awhere+appeared+%3D+1997 1997

dashboard
 #747 <span title="TotalRank: 1316 Jobs: 103 Users: 2832 Facts: 227 Links: 986">on PLDB</span>
 27 Years Old

* 

- Read more about zephyr-asdl on the web: 1.
 https://github.com/python/cpython/blob/master/Parser/Python.asdl 1.

<br>

codeWithHeader Example from the web:
 -- ASDL&#39;s 5 builtin types are:
 -- identifier, int, string, object, constant
 module Python
 {
     mod = Module(stmt* body, type_ignore *type_ignores)
         | Interactive(stmt* body)
         | Expression(expr body)
         | FunctionType(expr* argtypes, expr returns)
         -- not really an actual node but useful in Jython&#39;s typesystem.
         | Suite(stmt* body)
     stmt = FunctionDef(identifier name, arguments args,
                        stmt* body, expr* decorator_list, expr? returns,
                        string? type_comment)
           | AsyncFunctionDef(identifier name, arguments args,
                              stmt* body, expr* decorator_list, expr? returns,
                              string? type_comment)
           | ClassDef(identifier name,
              expr* bases,
              keyword* keywords,
              stmt* body,
              expr* decorator_list)
           | Return(expr? value)
           | Delete(expr* targets)
           | Assign(expr* targets, expr value, string? type_comment)
           | AugAssign(expr target, operator op, expr value)
           -- &#39;simple&#39; indicates that we annotate simple name without parens
           | AnnAssign(expr target, expr annotation, expr? value, int simple)
           -- use &#39;orelse&#39; because else is a keyword in target languages
           | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
           | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
           | While(expr test, stmt* body, stmt* orelse)
           | If(expr test, stmt* body, stmt* orelse)
           | With(withitem* items, stmt* body, string? type_comment)
           | AsyncWith(withitem* items, stmt* body, string? type_comment)
           | Raise(expr? exc, expr? cause)
           | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
           | Assert(expr test, expr? msg)
           | Import(alias* names)
           | ImportFrom(identifier? module, alias* names, int? level)
           | Global(identifier* names)
           | Nonlocal(identifier* names)
           | Expr(expr value)
           | Pass | Break | Continue
           -- XXX Jython will be different
           -- col_offset is the byte offset in the utf8 string the parser uses
           attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)
           -- BoolOp() can use left &amp; right?
     expr = BoolOp(boolop op, expr* values)
          | NamedExpr(expr target, expr value)
          | BinOp(expr left, operator op, expr right)
          | UnaryOp(unaryop op, expr operand)
          | Lambda(arguments args, expr body)
          | IfExp(expr test, expr body, expr orelse)
          | Dict(expr* keys, expr* values)
          | Set(expr* elts)
          | ListComp(expr elt, comprehension* generators)
          | SetComp(expr elt, comprehension* generators)
          | DictComp(expr key, expr value, comprehension* generators)
          | GeneratorExp(expr elt, comprehension* generators)
          -- the grammar constrains where yield expressions can occur
          | Await(expr value)
          | Yield(expr? value)
          | YieldFrom(expr value)
          -- need sequences for compare to distinguish between
          -- x &lt; 4 &lt; 3 and (x &lt; 4) &lt; 3
          | Compare(expr left, cmpop* ops, expr* comparators)
          | Call(expr func, expr* args, keyword* keywords)
          | FormattedValue(expr value, int? conversion, expr? format_spec)
          | JoinedStr(expr* values)
          | Constant(constant value, string? kind)
          -- the following expression can appear in assignment context
          | Attribute(expr value, identifier attr, expr_context ctx)
          | Subscript(expr value, slice slice, expr_context ctx)
          | Starred(expr value, expr_context ctx)
          | Name(identifier id, expr_context ctx)
          | List(expr* elts, expr_context ctx)
          | Tuple(expr* elts, expr_context ctx)
           -- col_offset is the byte offset in the utf8 string the parser uses
           attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)
     expr_context = Load | Store | Del | AugLoad | AugStore | Param
     slice = Slice(expr? lower, expr? upper, expr? step)
           | ExtSlice(slice* dims)
           | Index(expr value)
     boolop = And | Or
     operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift
                  | RShift | BitOr | BitXor | BitAnd | FloorDiv
     unaryop = Invert | Not | UAdd | USub
     cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn
     comprehension = (expr target, expr iter, expr* ifs, int is_async)
     excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)
                     attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)
     arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,
                  expr* kw_defaults, arg? kwarg, expr* defaults)
     arg = (identifier arg, expr? annotation, string? type_comment)
            attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)
     -- keyword arguments supplied to call (NULL identifier for **kwargs)
     keyword = (identifier? arg, expr value)
     -- import name with optional &#39;as&#39; alias.
     alias = (identifier name, identifier? asname)
     withitem = (expr context_expr, expr? optional_vars)
     type_ignore = TypeIgnore(int lineno, string tag)
 }

endColumns

## Language <a href="../lists/features.html">features</a>

treeTable
 row
  Feature Comments
  FeatureLink ../features/hasComments.html
  Supported <span class="hasFeature">✓</span>
  Token 
  Example
   -- A comment
 row
  Feature Line Comments
  FeatureLink ../features/hasLineComments.html
  Supported <span class="hasFeature">✓</span>
  Token --
  Example
   -- A comment
 row
  Feature Semantic Indentation
  FeatureLink ../features/hasSemanticIndentation.html
  Supported <span class="doesNotHaveFeature">X</span>
  Token 
  Example

keyboardNav component-pascal.html joy.html

import ../footer.scroll
