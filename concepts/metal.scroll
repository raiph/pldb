import ../header.scroll
baseUrl https://pldb.io/concepts/
title Metal

title Metal - Library
 hidden

html
 <a class="trueBaseThemePreviousItem" href="netlogo.html">&lt;</a>
 <a class="trueBaseThemeNextItem" href="self.html">&gt;</a>

viewSourceUrl https://github.com/breck7/pldb/blob/main/concepts/metal.pldb

startColumns 4

<div class="trueBaseThemeQuickLinks"><a href="https://en.wikipedia.org/wiki/Metal_(API)"><svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="98.05px" height="98.05px" viewBox="0 0 98.05 98.05" style="enable-background:new 0 0 98.05 98.05;" xml:space="preserve"><path d="M98.023,17.465l-19.584-0.056c-0.004,0.711-0.006,1.563-0.017,2.121c1.664,0.039,5.922,0.822,7.257,4.327L66.92,67.155 c-0.919-2.149-9.643-21.528-10.639-24.02l9.072-18.818c1.873-2.863,5.455-4.709,8.918-4.843l-0.01-1.968L55.42,17.489 c-0.045,0.499,0.001,1.548-0.068,2.069c5.315,0.144,7.215,1.334,5.941,4.508c-2.102,4.776-6.51,13.824-7.372,15.475 c-2.696-5.635-4.41-9.972-7.345-16.064c-1.266-2.823,1.529-3.922,4.485-4.004v-1.981l-21.82-0.067 c0.016,0.93-0.021,1.451-0.021,2.131c3.041,0.046,6.988,0.371,8.562,3.019c2.087,4.063,9.044,20.194,11.149,24.514 c-2.685,5.153-9.207,17.341-11.544,21.913c-3.348-7.43-15.732-36.689-19.232-44.241c-1.304-3.218,3.732-5.077,6.646-5.213 l0.019-2.148L0,17.398c0.005,0.646,0.027,1.71,0.029,2.187c4.025-0.037,9.908,6.573,11.588,10.683 c7.244,16.811,14.719,33.524,21.928,50.349c0.002,0.029,2.256,0.059,2.281,0.008c4.717-9.653,10.229-19.797,15.206-29.56 L63.588,80.64c0.005,0.004,2.082,0.016,2.093,0.007c7.962-18.196,19.892-46.118,23.794-54.933c1.588-3.767,4.245-6.064,8.543-6.194 l0.032-1.956L98.023,17.465z"/></svg></a> <a href="/edit.html?id=metal" class="material-symbols-outlined">edit</a></div>

* Metal is a <a href="/search.html?q=select+type%0D%0Awhere+type+%3D+library">library</a> created in 2014.
 link /search.html?q=select+type+appeared%0D%0Awhere+appeared+%3D+2014 2014

dashboard
 #291 on PLDB
 10 Years Old
 79 <span title="Metal repos on GitHub.">Repos</span>

* Metal is a low-level, low-overhead hardware-accelerated 3D graphic and compute shader application programming interface (API) developed by Apple Inc., and which debuted in iOS 8. Metal combines functions similar to OpenGL and OpenCL under one API. It is intended to bring to iOS, macOS, and tvOS apps some of the performance benefits of similar APIs on other platforms, such as Vulkan (which debuted in mid-February 2016) and DirectX 12. Read more on Wikipedia...
 https://en.wikipedia.org/wiki/Metal_(API) Read more on Wikipedia...

- Metal Wikipedia page
 https://en.wikipedia.org/wiki/Metal_(API)
- There are at least 79 Metal repos on <a href="https://github.com/search?q=language:Metal">GitHub</a>
- Metal first developed in <a href="../lists/originCommunities.html#apple">Apple</a>
- file extensions for Metal include metal
- The  Google BigQuery Public Dataset GitHub snapshot shows 232 users using Metal in 256 repos on <a href="https://api.github.com/search/repositories?q=language:Metal">GitHub</a>
- GitHub supports <a href="https://github.com/textmate/c.tmbundle" title="The package used for syntax highlighting by GitHub Linguist.">syntax highlighting</a> for Metal
- See also: (7 related languages)<a href="ios.html">iOS</a>, <a href="opengl.html">OpenGL</a>, <a href="opencl.html">OpenCL</a>, <a href="swift.html">Swift</a>, <a href="objective-c.html">Objective-C</a>, <a href="llvmir.html">LLVM IR</a>, <a href="unity-engine.html">Unity</a>

<br>

codeWithHeader Example from <a href='https://github.com/textmate/c.tmbundle'>Linguist</a>:
 // Copyright 2014 Isis Innovation Limited and the authors of InfiniTAM
 
 #include &lt;metal_stdlib&gt;
 
 #include &quot;../../DeviceAgnostic/ITMSceneReconstructionEngine.h&quot;
 #include &quot;../../DeviceAgnostic/ITMVisualisationEngine.h&quot;
 #include &quot;ITMVisualisationEngine_Metal.h&quot;
 
 using namespace metal;
 
 kernel void genericRaycastVH_device(DEVICEPTR(Vector4f) *pointsRay                                  [[ buffer(0) ]],
                                     const CONSTPTR(ITMVoxel) *voxelData                             [[ buffer(1) ]],
                                     const CONSTPTR(typename ITMVoxelIndex::IndexData) *voxelIndex   [[ buffer(2) ]],
                                     const CONSTPTR(Vector2f) *minmaxdata                            [[ buffer(3) ]],
                                     const CONSTPTR(CreateICPMaps_Params) *params                    [[ buffer(4) ]],
                                     uint2 threadIdx                                                 [[ thread_position_in_threadgroup ]],
                                     uint2 blockIdx                                                  [[ threadgroup_position_in_grid ]],
                                     uint2 blockDim                                                  [[ threads_per_threadgroup ]])
 {
     int x = threadIdx.x + blockIdx.x * blockDim.x, y = threadIdx.y + blockIdx.y * blockDim.y;
     
     if (x &gt;= params-&gt;imgSize.x || y &gt;= params-&gt;imgSize.y) return;
     
     int locId = x + y * params-&gt;imgSize.x;
     int locId2 = (int)floor((float)x / minmaximg_subsample) + (int)floor((float)y / minmaximg_subsample) * params-&gt;imgSize.x;
     
     castRay&lt;ITMVoxel, ITMVoxelIndex&gt;(pointsRay[locId], x, y, voxelData, voxelIndex, params-&gt;invM, params-&gt;invProjParams,
                                      params-&gt;voxelSizes.y, params-&gt;lightSource.w, minmaxdata[locId2]);
 }
 
 kernel void genericRaycastVGMissingPoints_device(DEVICEPTR(Vector4f) *forwardProjection                         [[ buffer(0) ]],
                                                  const CONSTPTR(int) *fwdProjMissingPoints                      [[ buffer(1) ]],
                                                  const CONSTPTR(ITMVoxel) *voxelData                            [[ buffer(2) ]],
                                                  const CONSTPTR(typename ITMVoxelIndex::IndexData) *voxelIndex  [[ buffer(3) ]],
                                                  const CONSTPTR(Vector2f) *minmaxdata                           [[ buffer(4) ]],
                                                  const CONSTPTR(CreateICPMaps_Params) *params                   [[ buffer(5) ]],
                                                  uint2 threadIdx                                                [[ thread_position_in_threadgroup ]],
                                                  uint2 blockIdx                                                 [[ threadgroup_position_in_grid ]],
                                                  uint2 blockDim                                                 [[ threads_per_threadgroup ]])
 {
     int pointId = threadIdx.x + blockIdx.x * blockDim.x;
     
     if (pointId &gt;= params-&gt;imgSize.z) return;
     
     int locId = fwdProjMissingPoints[pointId];
     int y = locId / params-&gt;imgSize.x, x = locId - y * params-&gt;imgSize.x;
     int locId2 = (int)floor((float)x / minmaximg_subsample) + (int)floor((float)y / minmaximg_subsample) * params-&gt;imgSize.x;
     
     castRay&lt;ITMVoxel, ITMVoxelIndex&gt;(forwardProjection[locId], x, y, voxelData, voxelIndex, params-&gt;invM, params-&gt;invProjParams,
                                      params-&gt;voxelSizes.y, params-&gt;lightSource.w, minmaxdata[locId2]);
 }
 
 kernel void renderICP_device(const CONSTPTR(Vector4f) *pointsRay            [[ buffer(0) ]],
                              DEVICEPTR(Vector4f) *pointsMap                 [[ buffer(1) ]],
                              DEVICEPTR(Vector4f) *normalsMap                [[ buffer(2) ]],
                              DEVICEPTR(Vector4u) *outRendering              [[ buffer(3) ]],
                              const CONSTPTR(CreateICPMaps_Params) *params   [[ buffer(4) ]],
                              uint2 threadIdx                                [[ thread_position_in_threadgroup ]],
                              uint2 blockIdx                                 [[ threadgroup_position_in_grid ]],
                              uint2 blockDim                                 [[ threads_per_threadgroup ]])
 {
     int x = threadIdx.x + blockIdx.x * blockDim.x, y = threadIdx.y + blockIdx.y * blockDim.y;
     
     if (x &gt;= params-&gt;imgSize.x || y &gt;= params-&gt;imgSize.y) return;
     
     processPixelICP&lt;false&gt;(outRendering, pointsMap, normalsMap, pointsRay, params-&gt;imgSize.xy, x, y, params-&gt;voxelSizes.x, TO_VECTOR3(params-&gt;lightSource));
 }
 
 kernel void renderForward_device(DEVICEPTR(Vector4u) *outRendering              [[ buffer(0) ]],
                                  const CONSTPTR(Vector4f) *pointsRay            [[ buffer(1) ]],
                                  const CONSTPTR(CreateICPMaps_Params) *params   [[ buffer(2) ]],
                                  uint2 threadIdx                                [[ thread_position_in_threadgroup ]],
                                  uint2 blockIdx                                 [[ threadgroup_position_in_grid ]],
                                  uint2 blockDim                                 [[ threads_per_threadgroup ]])
 {
     int x = threadIdx.x + blockIdx.x * blockDim.x, y = threadIdx.y + blockIdx.y * blockDim.y;
     
     if (x &gt;= params-&gt;imgSize.x || y &gt;= params-&gt;imgSize.y) return;
     
     processPixelForwardRender&lt;false&gt;(outRendering, pointsRay, params-&gt;imgSize.xy, x, y, params-&gt;voxelSizes.x, TO_VECTOR3(params-&gt;lightSource));
 }
 
 kernel void forwardProject_device(DEVICEPTR(Vector4f) *forwardProjection         [[ buffer(0) ]],
                                   const CONSTPTR(Vector4f) *pointsRay            [[ buffer(1) ]],
                                   const CONSTPTR(CreateICPMaps_Params) *params   [[ buffer(2) ]],
                                   uint2 threadIdx                                [[ thread_position_in_threadgroup ]],
                                   uint2 blockIdx                                 [[ threadgroup_position_in_grid ]],
                                   uint2 blockDim                                 [[ threads_per_threadgroup ]])
 {
     int x = (threadIdx.x + blockIdx.x * blockDim.x), y = (threadIdx.y + blockIdx.y * blockDim.y);
     
     if (x &gt;= params-&gt;imgSize.x || y &gt;= params-&gt;imgSize.y) return;
     
     int locId = x + y * params-&gt;imgSize.x;
     Vector4f pixel = pointsRay[locId];
     
     int locId_new = forwardProjectPixel(pixel * params-&gt;voxelSizes.x, params-&gt;M, params-&gt;projParams, params-&gt;imgSize.xy);
     if (locId_new &gt;= 0) forwardProjection[locId_new] = pixel;
 }

endColumns

keyboardNav netlogo.html self.html

import ../footer.scroll
